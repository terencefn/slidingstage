"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapSetAnnouncer = exports.MapSetPortals = exports.MapSetSpawns = exports.MapSetSpawn = exports.MapSetNooks_NooksEntry = exports.MapSetNooks = exports.MapSetSpaces = exports.MapSetSprites = exports.MapSetForegroundImagePath = exports.MapSetBackgroundImagePath = exports.MapSetCollisions = exports.MapSetDimensions = exports.DBDesk = exports.WireArea = exports.AreaPosition = exports.Asset = exports.Announcer = exports.Portal = exports.SpawnPoint = exports.Point = exports.NookDiff = exports.RequestedUsers_UsersEntry = exports.RequestedUsers = exports.RequestUser = exports.AllowedUsers = exports.NookCoords = exports.Space = exports.ObjectTime = exports.Sound = exports.DeskInfoV2 = exports.DeskInfo = exports.DeskObjects_ObjectsEntry = exports.DeskObjects = exports.BackedUpDeskObject = exports.SpaceMemberInfo_RolesEntry = exports.SpaceMemberInfo = exports.WireObject = exports.WireObjectSpritesheet_AnimationsEntry = exports.WireObjectSpritesheet = exports.WireObjectSpriteAnimConfig = exports.WireObjectSpritesheetFraming = exports.DBOutfit = exports.PlayerInitInfo = exports.InteractionEnum = exports.MoveDirectionEnum = exports.SpriteDirectionEnum = exports.InteractionEnum_ENUM = exports.MoveDirectionEnum_ENUM = exports.SpriteDirectionEnum_ENUM = exports.protobufPackage = void 0;
exports.Timestamp = exports.PlayerWaves = exports.PlayerChats = exports.SetScreenPointerServer = exports.PlayerSetsImagePointer = exports.PlayerRings = exports.PlayerSpotlights = exports.PlayerSetsStatus = exports.PlayerMoves = exports.GotRequestMute = exports.PlayerJoins = exports.TransactionStatus = exports.Ready = exports.ErrorEvent = exports.Warn = exports.Info = exports.ServerHeartbeat = exports.ServerClientEvent = exports.ServerClientBatch = exports.MapLocation = exports.ItemAbility = exports.SpaceItem_AbilitiesEntry = exports.SpaceItem_MetaEntry = exports.SpaceItem = exports.InventoryItem = exports.Inventory_OrderEntry = exports.Inventory_ItemsEntry = exports.Inventory = exports.MapSetScript = exports.TutorialTaskMapArea = exports.WireTutorialTasks = exports.MapSetTutorialTasks = exports.MapSetDecoration = exports.MapSetDescription = exports.MapSetEnabledChats = exports.MapSetMiniMapImagePath = exports.MapDeleteObjectById = exports.MapDeleteObject = exports.MapSetAreas_AreasEntry = exports.MapSetAreas = exports.MapSetFloors_FloorsEntry = exports.MapSetFloors = exports.MapSetWalls_WallsEntry = exports.MapSetWalls = exports.MapSetUseDrawnBG = exports.MapSetMuteOnEntry = exports.MapSetName = exports.MapSetObjects_ObjectsEntry = exports.MapSetObjects = exports.MapSetAssets = void 0;
exports.PlayerSetsItemString = exports.PlayerUpdatesFocusModeStatus = exports.CustomEvent = exports.PlayerBlocks = exports.PlayerSetsFocusModeEndTime = exports.SpaceStopsSound = exports.SpacePlaysSound = exports.PlayerSetsIsAlone = exports.PlayerSetsSpeedModifier = exports.PlayerSetsVehicleId = exports.PlayerSetsGoKartId = exports.PlayerSetsCurrentArea = exports.PlayerSetsCurrentDesk = exports.PlayerSetsInConversation = exports.PlayerSetsEventStatus = exports.PlayerShootsConfetti = exports.SpaceSetsIdMapping = exports.CookieFound = exports.PlayerEntersPortal = exports.SpaceIsClosed = exports.SpaceSetsSpaceMembers_MembersEntry = exports.SpaceSetsSpaceMembers = exports.DynamicGates = exports.DynamicGate = exports.SpaceOverwrites = exports.RespawnComplete = exports.PlayerSetsIsSignedIn = exports.PlayerSetsOutfitString = exports.PlayerExits = exports.PlayerSetsAffiliation = exports.PlayerSetsEmojiStatus = exports.PlayerSetsIsMobile = exports.PlayerSetsPersonalImageUrl = exports.PlayerSetsProfileImageUrl = exports.PlayerSetsDescription = exports.PlayerSetsPhone = exports.PlayerSetsTimezone = exports.PlayerSetsTitle = exports.PlayerSetsPronouns = exports.PlayerSetsTextStatus = exports.PlayerSetsName = exports.PlayerSetsLastActive = exports.PlayerSetsWorkCondition = exports.PlayerSetsEmoteV2 = exports.PlayerActivelySpeaks = exports.PlayerLeavesWhisper = exports.PlayerEntersWhisperV2 = exports.PlayerEntersWhisper = exports.PlayerGhosts = exports.PlayerInteracts = void 0;
exports.Notify = exports.Chat = exports.SetImpassable = exports.Block = exports.Kick = exports.Ban = exports.SetScreenPointer = exports.SetImagePointer = exports.Ring = exports.Spotlight = exports.SetOutfitString = exports.SetStatus = exports.SetAffiliation = exports.RequestMute = exports.Move = exports.UpdateSubscriptions_MapUpdateIdsEntry = exports.UpdateSubscriptions_SubscriptionsEntry = exports.UpdateSubscriptions = exports.ClientBackupHeartbeat = exports.ClientHeartbeat = exports.ClientServerAction = exports.ClientServerBatch = exports.PlayerSetsAway = exports.SpaceOverCapacityDeniesUser = exports.SpaceSetsCapacity = exports.PlayerSetsDeskInfo = exports.PrecomputedEnterLocation = exports.PlayerSetsAllowScreenPointer = exports.PlayerTriggersInventoryItem = exports.SpaceUpdatesItems_ItemsEntry = exports.SpaceUpdatesItems = exports.PlayerUpdatesInventory_OrderEntry = exports.PlayerUpdatesInventory_ItemsEntry = exports.PlayerUpdatesInventory = exports.SpaceRegistersCommand = exports.PlayerSendsCommand = exports.PlayerHighFives = exports.FXShakeCamera = exports.FXShakeObject = exports.PlayerEditsChatMessage = exports.MapMoveObject = exports.PlayerCrafts_InputsEntry = exports.PlayerCrafts = exports.PlayerSetsSubtitle = exports.PlayerSetsIsNpc = exports.PlayerSetsManualVideoSrc = exports.PlayerRequestsToLead = exports.PlayerSetsFollowTarget = exports.PlayerNotifies = exports.PlayerTriggersItem = void 0;
exports.PlayerUpdatesSession = exports.MapCommitsChanges = exports.SetSubtitle = exports.SetManualVideoSrc = exports.EnterPortal = exports.RequestToLead = exports.SetFollowTarget = exports.CustomAction = exports.TriggerItem = exports.SetItemString = exports.SetFocusModeEndTime = exports.StopSound = exports.PlaySound = exports.SetIsMobile = exports.SetIsAlone = exports.SetSpeedModifier = exports.SetVehicleId = exports.SetGoKartId = exports.SetCurrentArea = exports.SetCurrentDesk = exports.SetInConversation = exports.SetEventStatus = exports.ShootConfetti = exports.MapAddObject = exports.Init = exports.UpdateNookPermission = exports.RequestToJoinNook = exports.Respawn = exports.Spawn = exports.SetWorkCondition = exports.Teleport = exports.SetEmojiStatus = exports.PrecomputeEnter = exports.Enter = exports.Exit = exports.SetPersonalImageUrl = exports.SetProfileImageUrl = exports.SetDescription = exports.SetPhone = exports.SetTimezone = exports.SetTitle = exports.SetPronouns = exports.SetTextStatus = exports.SetName = exports.SetEmoteV2 = exports.Ghost = exports.LeaveWhisper = exports.EnterWhisper = exports.ActivelySpeaking = exports.Interact = void 0;
exports.protobufWriterLibrary = exports.SetAway = exports.Wave = exports.SetDeskInfo = exports.SetAllowScreenPointer = exports.TriggerInventoryItem = exports.HipToBeSquare = exports.RemoveInventoryItem = exports.AddInventoryItem = exports.HighFive = exports.Craft_InputsEntry = exports.Craft = exports.RegisterCommand = exports.SendCommand = exports.ChatMessageUpdated = exports.ChatReply = exports.SpeakerUpdatesSession = void 0;
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "";
var SpriteDirectionEnum_ENUM;
(function (SpriteDirectionEnum_ENUM) {
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Stand"] = 0] = "Stand";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Down"] = 1] = "Down";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["DownAlt"] = 2] = "DownAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Up"] = 3] = "Up";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["UpAlt"] = 4] = "UpAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Left"] = 5] = "Left";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["LeftAlt"] = 6] = "LeftAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Right"] = 7] = "Right";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["RightAlt"] = 8] = "RightAlt";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance1"] = 9] = "Dance1";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance2"] = 10] = "Dance2";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance3"] = 11] = "Dance3";
    SpriteDirectionEnum_ENUM[SpriteDirectionEnum_ENUM["Dance4"] = 12] = "Dance4";
})(SpriteDirectionEnum_ENUM = exports.SpriteDirectionEnum_ENUM || (exports.SpriteDirectionEnum_ENUM = {}));
var MoveDirectionEnum_ENUM;
(function (MoveDirectionEnum_ENUM) {
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Left"] = 0] = "Left";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Right"] = 1] = "Right";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Up"] = 2] = "Up";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Down"] = 3] = "Down";
    MoveDirectionEnum_ENUM[MoveDirectionEnum_ENUM["Dance"] = 4] = "Dance";
})(MoveDirectionEnum_ENUM = exports.MoveDirectionEnum_ENUM || (exports.MoveDirectionEnum_ENUM = {}));
var InteractionEnum_ENUM;
(function (InteractionEnum_ENUM) {
    InteractionEnum_ENUM[InteractionEnum_ENUM["NONE"] = 0] = "NONE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EMBEDDED_WEBSITE"] = 1] = "EMBEDDED_WEBSITE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["POSTER"] = 2] = "POSTER";
    InteractionEnum_ENUM[InteractionEnum_ENUM["VIDEO"] = 3] = "VIDEO";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EXTERNAL_CALL"] = 4] = "EXTERNAL_CALL";
    InteractionEnum_ENUM[InteractionEnum_ENUM["EXTENSION"] = 5] = "EXTENSION";
    InteractionEnum_ENUM[InteractionEnum_ENUM["NOTE"] = 6] = "NOTE";
    InteractionEnum_ENUM[InteractionEnum_ENUM["MODAL_EXTENSION"] = 7] = "MODAL_EXTENSION";
    InteractionEnum_ENUM[InteractionEnum_ENUM["COMPONENT_MODAL"] = 8] = "COMPONENT_MODAL";
    InteractionEnum_ENUM[InteractionEnum_ENUM["SIDE_PANEL_TRIGGER"] = 9] = "SIDE_PANEL_TRIGGER";
})(InteractionEnum_ENUM = exports.InteractionEnum_ENUM || (exports.InteractionEnum_ENUM = {}));
const baseSpriteDirectionEnum = {};
exports.SpriteDirectionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpriteDirectionEnum);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMoveDirectionEnum = {};
exports.MoveDirectionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMoveDirectionEnum);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInteractionEnum = {};
exports.InteractionEnum = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInteractionEnum);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerInitInfo = {};
exports.PlayerInitInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== undefined) {
            writer.uint32(10).string(message.name);
        }
        if (message.x !== undefined) {
            writer.uint32(24).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(32).uint32(message.y);
        }
        if (message.map !== undefined) {
            writer.uint32(42).string(message.map);
        }
        if (message.affiliation !== undefined) {
            writer.uint32(50).string(message.affiliation);
        }
        if (message.busy !== undefined) {
            writer.uint32(56).bool(message.busy);
        }
        if (message.textStatus !== undefined) {
            writer.uint32(66).string(message.textStatus);
        }
        if (message.emojiStatus !== undefined) {
            writer.uint32(74).string(message.emojiStatus);
        }
        if (message.currentlyEquippedWearables !== undefined) {
            exports.DBOutfit.encode(message.currentlyEquippedWearables, writer.uint32(82).fork()).ldelim();
        }
        if (message.focusModeEndTime !== undefined) {
            writer.uint32(90).string(message.focusModeEndTime);
        }
        if (message.currentDesk !== undefined) {
            writer.uint32(106).string(message.currentDesk);
        }
        if (message.itemString !== undefined) {
            writer.uint32(114).string(message.itemString);
        }
        if (message.isNpc !== undefined) {
            writer.uint32(120).bool(message.isNpc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerInitInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 3:
                    message.x = reader.uint32();
                    break;
                case 4:
                    message.y = reader.uint32();
                    break;
                case 5:
                    message.map = reader.string();
                    break;
                case 6:
                    message.affiliation = reader.string();
                    break;
                case 7:
                    message.busy = reader.bool();
                    break;
                case 8:
                    message.textStatus = reader.string();
                    break;
                case 9:
                    message.emojiStatus = reader.string();
                    break;
                case 10:
                    message.currentlyEquippedWearables = exports.DBOutfit.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.focusModeEndTime = reader.string();
                    break;
                case 13:
                    message.currentDesk = reader.string();
                    break;
                case 14:
                    message.itemString = reader.string();
                    break;
                case 15:
                    message.isNpc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDBOutfit = {
    skin: "",
    hair: "",
    facial_hair: "",
    top: "",
    bottom: "",
    shoes: "",
    hat: "",
    glasses: "",
    other: "",
};
exports.DBOutfit = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.skin !== "") {
            writer.uint32(10).string(message.skin);
        }
        if (message.hair !== "") {
            writer.uint32(18).string(message.hair);
        }
        if (message.facial_hair !== "") {
            writer.uint32(26).string(message.facial_hair);
        }
        if (message.top !== "") {
            writer.uint32(34).string(message.top);
        }
        if (message.bottom !== "") {
            writer.uint32(42).string(message.bottom);
        }
        if (message.shoes !== "") {
            writer.uint32(50).string(message.shoes);
        }
        if (message.hat !== "") {
            writer.uint32(58).string(message.hat);
        }
        if (message.glasses !== "") {
            writer.uint32(66).string(message.glasses);
        }
        if (message.other !== "") {
            writer.uint32(74).string(message.other);
        }
        if (message.costume !== undefined) {
            writer.uint32(82).string(message.costume);
        }
        if (message.mobility !== undefined) {
            writer.uint32(90).string(message.mobility);
        }
        if (message.jacket !== undefined) {
            writer.uint32(98).string(message.jacket);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDBOutfit);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.skin = reader.string();
                    break;
                case 2:
                    message.hair = reader.string();
                    break;
                case 3:
                    message.facial_hair = reader.string();
                    break;
                case 4:
                    message.top = reader.string();
                    break;
                case 5:
                    message.bottom = reader.string();
                    break;
                case 6:
                    message.shoes = reader.string();
                    break;
                case 7:
                    message.hat = reader.string();
                    break;
                case 8:
                    message.glasses = reader.string();
                    break;
                case 9:
                    message.other = reader.string();
                    break;
                case 10:
                    message.costume = reader.string();
                    break;
                case 11:
                    message.mobility = reader.string();
                    break;
                case 12:
                    message.jacket = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireObjectSpritesheetFraming = { frameWidth: 0, frameHeight: 0 };
exports.WireObjectSpritesheetFraming = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.frameWidth !== 0) {
            writer.uint32(8).int32(message.frameWidth);
        }
        if (message.frameHeight !== 0) {
            writer.uint32(16).int32(message.frameHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireObjectSpritesheetFraming);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.frameWidth = reader.int32();
                    break;
                case 2:
                    message.frameHeight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireObjectSpriteAnimConfig = { sequence: 0, frameRate: 0 };
exports.WireObjectSpriteAnimConfig = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.useSequenceAsRange !== undefined) {
            writer.uint32(8).bool(message.useSequenceAsRange);
        }
        writer.uint32(18).fork();
        for (const v of message.sequence) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.loop !== undefined) {
            writer.uint32(24).bool(message.loop);
        }
        if (message.frameRate !== 0) {
            writer.uint32(32).uint32(message.frameRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireObjectSpriteAnimConfig);
        message.sequence = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.useSequenceAsRange = reader.bool();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.sequence.push(reader.uint32());
                        }
                    }
                    else {
                        message.sequence.push(reader.uint32());
                    }
                    break;
                case 3:
                    message.loop = reader.bool();
                    break;
                case 4:
                    message.frameRate = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireObjectSpritesheet = { spritesheetUrl: "" };
exports.WireObjectSpritesheet = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spritesheetUrl !== "") {
            writer.uint32(10).string(message.spritesheetUrl);
        }
        if (message.framing !== undefined) {
            exports.WireObjectSpritesheetFraming.encode(message.framing, writer.uint32(18).fork()).ldelim();
        }
        Object.entries(message.animations).forEach(([key, value]) => {
            exports.WireObjectSpritesheet_AnimationsEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        if (message.currentAnim !== undefined) {
            writer.uint32(34).string(message.currentAnim);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireObjectSpritesheet);
        message.animations = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spritesheetUrl = reader.string();
                    break;
                case 2:
                    message.framing = exports.WireObjectSpritesheetFraming.decode(reader, reader.uint32());
                    break;
                case 3:
                    const entry3 = exports.WireObjectSpritesheet_AnimationsEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.animations[entry3.key] = entry3.value;
                    }
                    break;
                case 4:
                    message.currentAnim = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireObjectSpritesheet_AnimationsEntry = { key: "" };
exports.WireObjectSpritesheet_AnimationsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.WireObjectSpriteAnimConfig.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireObjectSpritesheet_AnimationsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.WireObjectSpriteAnimConfig.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireObject = { _tags: "" };
exports.WireObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.templateId !== undefined) {
            writer.uint32(10).string(message.templateId);
        }
        if (message._name !== undefined) {
            writer.uint32(18).string(message._name);
        }
        for (const v of message._tags) {
            writer.uint32(26).string(v);
        }
        if (message.x !== undefined) {
            writer.uint32(32).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(40).uint32(message.y);
        }
        if (message.offsetX !== undefined) {
            writer.uint32(53).float(message.offsetX);
        }
        if (message.offsetY !== undefined) {
            writer.uint32(61).float(message.offsetY);
        }
        if (message.color !== undefined) {
            writer.uint32(66).string(message.color);
        }
        if (message.orientation !== undefined) {
            writer.uint32(72).uint32(message.orientation);
        }
        if (message.normal !== undefined) {
            writer.uint32(82).string(message.normal);
        }
        if (message.highlighted !== undefined) {
            writer.uint32(90).string(message.highlighted);
        }
        if (message.type !== undefined) {
            writer.uint32(96).int32(message.type);
        }
        if (message.width !== undefined) {
            writer.uint32(104).uint32(message.width);
        }
        if (message.height !== undefined) {
            writer.uint32(112).uint32(message.height);
        }
        if (message.extensionClass !== undefined) {
            writer.uint32(122).string(message.extensionClass);
        }
        if (message.previewMessage !== undefined) {
            writer.uint32(130).string(message.previewMessage);
        }
        if (message.distThreshold !== undefined) {
            writer.uint32(136).uint32(message.distThreshold);
        }
        if (message.propertiesJson !== undefined) {
            writer.uint32(146).string(message.propertiesJson);
        }
        if (message.sound !== undefined) {
            exports.Sound.encode(message.sound, writer.uint32(154).fork()).ldelim();
        }
        if (message.objectStartTime !== undefined) {
            exports.ObjectTime.encode(message.objectStartTime, writer.uint32(162).fork()).ldelim();
        }
        if (message.objectExpireTime !== undefined) {
            exports.ObjectTime.encode(message.objectExpireTime, writer.uint32(170).fork()).ldelim();
        }
        if (message.id !== undefined) {
            writer.uint32(178).string(message.id);
        }
        if (message.customState !== undefined) {
            writer.uint32(186).string(message.customState);
        }
        if (message.objectPlacerId !== undefined) {
            writer.uint32(194).string(message.objectPlacerId);
        }
        if (message.numGoKarts !== undefined) {
            writer.uint32(200).uint32(message.numGoKarts);
        }
        if (message.spritesheet !== undefined) {
            exports.WireObjectSpritesheet.encode(message.spritesheet, writer.uint32(210).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireObject);
        message._tags = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.templateId = reader.string();
                    break;
                case 2:
                    message._name = reader.string();
                    break;
                case 3:
                    message._tags.push(reader.string());
                    break;
                case 4:
                    message.x = reader.uint32();
                    break;
                case 5:
                    message.y = reader.uint32();
                    break;
                case 6:
                    message.offsetX = reader.float();
                    break;
                case 7:
                    message.offsetY = reader.float();
                    break;
                case 8:
                    message.color = reader.string();
                    break;
                case 9:
                    message.orientation = reader.uint32();
                    break;
                case 10:
                    message.normal = reader.string();
                    break;
                case 11:
                    message.highlighted = reader.string();
                    break;
                case 12:
                    message.type = reader.int32();
                    break;
                case 13:
                    message.width = reader.uint32();
                    break;
                case 14:
                    message.height = reader.uint32();
                    break;
                case 15:
                    message.extensionClass = reader.string();
                    break;
                case 16:
                    message.previewMessage = reader.string();
                    break;
                case 17:
                    message.distThreshold = reader.uint32();
                    break;
                case 18:
                    message.propertiesJson = reader.string();
                    break;
                case 19:
                    message.sound = exports.Sound.decode(reader, reader.uint32());
                    break;
                case 20:
                    message.objectStartTime = exports.ObjectTime.decode(reader, reader.uint32());
                    break;
                case 21:
                    message.objectExpireTime = exports.ObjectTime.decode(reader, reader.uint32());
                    break;
                case 22:
                    message.id = reader.string();
                    break;
                case 23:
                    message.customState = reader.string();
                    break;
                case 24:
                    message.objectPlacerId = reader.string();
                    break;
                case 25:
                    message.numGoKarts = reader.uint32();
                    break;
                case 26:
                    message.spritesheet = exports.WireObjectSpritesheet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceMemberInfo = {};
exports.SpaceMemberInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.roles).forEach(([key, value]) => {
            exports.SpaceMemberInfo_RolesEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        if (message.name !== undefined) {
            writer.uint32(18).string(message.name);
        }
        if (message.currentlyEquippedWearables !== undefined) {
            exports.DBOutfit.encode(message.currentlyEquippedWearables, writer.uint32(34).fork()).ldelim();
        }
        if (message.deskInfo !== undefined) {
            exports.DeskInfo.encode(message.deskInfo, writer.uint32(42).fork()).ldelim();
        }
        if (message.allowScreenPointer !== undefined) {
            writer.uint32(48).bool(message.allowScreenPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceMemberInfo);
        message.roles = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceMemberInfo_RolesEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.roles[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 4:
                    message.currentlyEquippedWearables = exports.DBOutfit.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.deskInfo = exports.DeskInfo.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.allowScreenPointer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceMemberInfo_RolesEntry = { key: "", value: false };
exports.SpaceMemberInfo_RolesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceMemberInfo_RolesEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseBackedUpDeskObject = { offsetX: 0, offsetY: 0 };
exports.BackedUpDeskObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.obj !== undefined) {
            exports.WireObject.encode(message.obj, writer.uint32(10).fork()).ldelim();
        }
        if (message.offsetX !== 0) {
            writer.uint32(16).uint32(message.offsetX);
        }
        if (message.offsetY !== 0) {
            writer.uint32(24).uint32(message.offsetY);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBackedUpDeskObject);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.obj = exports.WireObject.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.offsetX = reader.uint32();
                    break;
                case 3:
                    message.offsetY = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDeskObjects = {};
exports.DeskObjects = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.objects).forEach(([key, value]) => {
            exports.DeskObjects_ObjectsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeskObjects);
        message.objects = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.DeskObjects_ObjectsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.objects[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDeskObjects_ObjectsEntry = { key: "" };
exports.DeskObjects_ObjectsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.BackedUpDeskObject.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeskObjects_ObjectsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.BackedUpDeskObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDeskInfo = { deskId: "" };
exports.DeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskId !== "") {
            writer.uint32(10).string(message.deskId);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.locked !== undefined) {
            writer.uint32(24).bool(message.locked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeskInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDeskInfoV2 = {};
exports.DeskInfoV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskId !== undefined) {
            writer.uint32(10).string(message.deskId);
        }
        if (message.description !== undefined) {
            writer.uint32(18).string(message.description);
        }
        if (message.locked !== undefined) {
            writer.uint32(24).bool(message.locked);
        }
        if (message.lastDeskObjects !== undefined) {
            exports.DeskObjects.encode(message.lastDeskObjects, writer.uint32(34).fork()).ldelim();
        }
        if (message.mapId !== undefined) {
            writer.uint32(42).string(message.mapId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDeskInfoV2);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.locked = reader.bool();
                    break;
                case 4:
                    message.lastDeskObjects = exports.DeskObjects.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.mapId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSound = { src: "", volume: 0, loop: false, maxDistance: 0 };
exports.Sound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(21).float(message.volume);
        }
        if (message.loop === true) {
            writer.uint32(24).bool(message.loop);
        }
        if (message.maxDistance !== 0) {
            writer.uint32(32).uint32(message.maxDistance);
        }
        if (message.isPositional !== undefined) {
            writer.uint32(40).bool(message.isPositional);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.volume = reader.float();
                    break;
                case 3:
                    message.loop = reader.bool();
                    break;
                case 4:
                    message.maxDistance = reader.uint32();
                    break;
                case 5:
                    message.isPositional = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseObjectTime = { _seconds: 0 };
exports.ObjectTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message._seconds !== 0) {
            writer.uint32(8).uint32(message._seconds);
        }
        if (message._timezone !== undefined) {
            writer.uint32(18).string(message._timezone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseObjectTime);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message._seconds = reader.uint32();
                    break;
                case 2:
                    message._timezone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpace = { spaceId: "", x: 0, y: 0 };
exports.Space = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spaceId !== "") {
            writer.uint32(10).string(message.spaceId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.colored !== undefined) {
            writer.uint32(32).bool(message.colored);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpace);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.colored = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseNookCoords = {};
exports.NookCoords = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coords) {
            exports.Point.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseNookCoords);
        message.coords = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.coords.push(exports.Point.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseAllowedUsers = { users: "" };
exports.AllowedUsers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.users) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAllowedUsers);
        message.users = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.users.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestUser = {};
exports.RequestUser = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== undefined) {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestUser);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestedUsers = {};
exports.RequestedUsers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.users).forEach(([key, value]) => {
            exports.RequestedUsers_UsersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestedUsers);
        message.users = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.RequestedUsers_UsersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.users[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestedUsers_UsersEntry = { key: "" };
exports.RequestedUsers_UsersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.RequestUser.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestedUsers_UsersEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.RequestUser.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseNookDiff = {};
exports.NookDiff = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nookCoords !== undefined) {
            exports.NookCoords.encode(message.nookCoords, writer.uint32(10).fork()).ldelim();
        }
        if (message.colored !== undefined) {
            writer.uint32(16).bool(message.colored);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        if (message.bookable !== undefined) {
            writer.uint32(32).bool(message.bookable);
        }
        if (message.capacity !== undefined) {
            writer.uint32(40).uint32(message.capacity);
        }
        if (message.restricted !== undefined) {
            writer.uint32(48).bool(message.restricted);
        }
        if (message.allowedUsers !== undefined) {
            exports.AllowedUsers.encode(message.allowedUsers, writer.uint32(58).fork()).ldelim();
        }
        if (message.requestedUsers !== undefined) {
            exports.RequestedUsers.encode(message.requestedUsers, writer.uint32(66).fork()).ldelim();
        }
        if (message.isInMeeting !== undefined) {
            writer.uint32(72).bool(message.isInMeeting);
        }
        if (message.isDesk !== undefined) {
            writer.uint32(80).bool(message.isDesk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseNookDiff);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nookCoords = exports.NookCoords.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.colored = reader.bool();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 4:
                    message.bookable = reader.bool();
                    break;
                case 5:
                    message.capacity = reader.uint32();
                    break;
                case 6:
                    message.restricted = reader.bool();
                    break;
                case 7:
                    message.allowedUsers = exports.AllowedUsers.decode(reader, reader.uint32());
                    break;
                case 8:
                    message.requestedUsers = exports.RequestedUsers.decode(reader, reader.uint32());
                    break;
                case 9:
                    message.isInMeeting = reader.bool();
                    break;
                case 10:
                    message.isDesk = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePoint = { x: 0, y: 0 };
exports.Point = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePoint);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpawnPoint = { x: 0, y: 0 };
exports.SpawnPoint = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        if (message.spawnId !== undefined) {
            writer.uint32(26).string(message.spawnId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpawnPoint);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.spawnId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePortal = { x: 0, y: 0 };
exports.Portal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        if (message.targetMap !== undefined) {
            writer.uint32(26).string(message.targetMap);
        }
        if (message.targetUrl !== undefined) {
            writer.uint32(34).string(message.targetUrl);
        }
        if (message.targetX !== undefined) {
            writer.uint32(40).uint32(message.targetX);
        }
        if (message.targetY !== undefined) {
            writer.uint32(48).uint32(message.targetY);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePortal);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                case 3:
                    message.targetMap = reader.string();
                    break;
                case 4:
                    message.targetUrl = reader.string();
                    break;
                case 5:
                    message.targetX = reader.uint32();
                    break;
                case 6:
                    message.targetY = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseAnnouncer = { x: 0, y: 0 };
exports.Announcer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(8).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(16).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAnnouncer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.uint32();
                    break;
                case 2:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseAsset = { x: 0, y: 0, src: "" };
exports.Asset = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x !== 0) {
            writer.uint32(13).float(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(21).float(message.y);
        }
        if (message.src !== "") {
            writer.uint32(26).string(message.src);
        }
        if (message.width !== undefined) {
            writer.uint32(32).uint32(message.width);
        }
        if (message.height !== undefined) {
            writer.uint32(40).uint32(message.height);
        }
        if (message.inFront !== undefined) {
            writer.uint32(48).bool(message.inFront);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAsset);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x = reader.float();
                    break;
                case 2:
                    message.y = reader.float();
                    break;
                case 3:
                    message.src = reader.string();
                    break;
                case 4:
                    message.width = reader.uint32();
                    break;
                case 5:
                    message.height = reader.uint32();
                    break;
                case 6:
                    message.inFront = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseAreaPosition = { x1: 0, y1: 0, x2: 0, y2: 0 };
exports.AreaPosition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.x1 !== 0) {
            writer.uint32(8).uint32(message.x1);
        }
        if (message.y1 !== 0) {
            writer.uint32(16).uint32(message.y1);
        }
        if (message.x2 !== 0) {
            writer.uint32(24).uint32(message.x2);
        }
        if (message.y2 !== 0) {
            writer.uint32(32).uint32(message.y2);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAreaPosition);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.x1 = reader.uint32();
                    break;
                case 2:
                    message.y1 = reader.uint32();
                    break;
                case 3:
                    message.x2 = reader.uint32();
                    break;
                case 4:
                    message.y2 = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireArea = {};
exports.WireArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.category !== undefined) {
            writer.uint32(10).string(message.category);
        }
        for (const v of message.coords) {
            exports.AreaPosition.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireArea);
        message.coords = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.category = reader.string();
                    break;
                case 2:
                    message.coords.push(exports.AreaPosition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDBDesk = {};
exports.DBDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.coords) {
            exports.AreaPosition.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDBDesk);
        message.coords = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.coords.push(exports.AreaPosition.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetDimensions = { mapId: "", width: 0, height: 0 };
exports.MapSetDimensions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.width !== 0) {
            writer.uint32(16).uint32(message.width);
        }
        if (message.height !== 0) {
            writer.uint32(24).uint32(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetDimensions);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.width = reader.uint32();
                    break;
                case 3:
                    message.height = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetCollisions = { mapId: "", x: 0, y: 0, w: 0, h: 0, mask: "" };
exports.MapSetCollisions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.w !== 0) {
            writer.uint32(32).uint32(message.w);
        }
        if (message.h !== 0) {
            writer.uint32(40).uint32(message.h);
        }
        if (message.mask !== "") {
            writer.uint32(50).string(message.mask);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetCollisions);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.w = reader.uint32();
                    break;
                case 5:
                    message.h = reader.uint32();
                    break;
                case 6:
                    message.mask = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetBackgroundImagePath = { mapId: "", backgroundImagePath: "" };
exports.MapSetBackgroundImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.backgroundImagePath !== "") {
            writer.uint32(18).string(message.backgroundImagePath);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetBackgroundImagePath);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.backgroundImagePath = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetForegroundImagePath = { mapId: "", foregroundImagePath: "" };
exports.MapSetForegroundImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.foregroundImagePath !== "") {
            writer.uint32(18).string(message.foregroundImagePath);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetForegroundImagePath);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.foregroundImagePath = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetSprites = { mapId: "", sprites: 0 };
exports.MapSetSprites = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        writer.uint32(18).fork();
        for (const v of message.sprites) {
            writer.uint32(v);
        }
        writer.ldelim();
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetSprites);
        message.sprites = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    if ((tag & 7) === 2) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.sprites.push(reader.uint32());
                        }
                    }
                    else {
                        message.sprites.push(reader.uint32());
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetSpaces = { mapId: "" };
exports.MapSetSpaces = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.spaces) {
            exports.Space.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetSpaces);
        message.spaces = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spaces.push(exports.Space.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetNooks = { mapId: "" };
exports.MapSetNooks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.nooks).forEach(([key, value]) => {
            exports.MapSetNooks_NooksEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.overwrite !== undefined) {
            writer.uint32(24).bool(message.overwrite);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetNooks);
        message.nooks = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetNooks_NooksEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.nooks[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.overwrite = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetNooks_NooksEntry = { key: "" };
exports.MapSetNooks_NooksEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.NookDiff.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetNooks_NooksEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.NookDiff.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetSpawn = { mapId: "" };
exports.MapSetSpawn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.spawn !== undefined) {
            exports.Point.encode(message.spawn, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetSpawn);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spawn = exports.Point.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetSpawns = { mapId: "" };
exports.MapSetSpawns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.spawns) {
            exports.SpawnPoint.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetSpawns);
        message.spawns = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.spawns.push(exports.SpawnPoint.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetPortals = { mapId: "" };
exports.MapSetPortals = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.portals) {
            exports.Portal.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetPortals);
        message.portals = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.portals.push(exports.Portal.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetAnnouncer = { mapId: "" };
exports.MapSetAnnouncer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.announcer) {
            exports.Announcer.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetAnnouncer);
        message.announcer = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.announcer.push(exports.Announcer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetAssets = { mapId: "" };
exports.MapSetAssets = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.assets) {
            exports.Asset.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetAssets);
        message.assets = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.assets.push(exports.Asset.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetObjects = { mapId: "" };
exports.MapSetObjects = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.objects).forEach(([key, value]) => {
            exports.MapSetObjects_ObjectsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.updatesAreOverwrites !== undefined) {
            writer.uint32(24).bool(message.updatesAreOverwrites);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetObjects);
        message.objects = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetObjects_ObjectsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.objects[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.updatesAreOverwrites = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetObjects_ObjectsEntry = { key: 0 };
exports.MapSetObjects_ObjectsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== 0) {
            writer.uint32(8).uint32(message.key);
        }
        if (message.value !== undefined) {
            exports.WireObject.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetObjects_ObjectsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.uint32();
                    break;
                case 2:
                    message.value = exports.WireObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetName = { mapId: "", name: "" };
exports.MapSetName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetName);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetMuteOnEntry = { mapId: "", muteOnEntry: false };
exports.MapSetMuteOnEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.muteOnEntry === true) {
            writer.uint32(16).bool(message.muteOnEntry);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetMuteOnEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.muteOnEntry = reader.bool();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetUseDrawnBG = { mapId: "", useDrawnBG: false };
exports.MapSetUseDrawnBG = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.useDrawnBG === true) {
            writer.uint32(16).bool(message.useDrawnBG);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetUseDrawnBG);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.useDrawnBG = reader.bool();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetWalls = { mapId: "" };
exports.MapSetWalls = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.walls).forEach(([key, value]) => {
            exports.MapSetWalls_WallsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetWalls);
        message.walls = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetWalls_WallsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.walls[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetWalls_WallsEntry = { key: "", value: "" };
exports.MapSetWalls_WallsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetWalls_WallsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetFloors = { mapId: "" };
exports.MapSetFloors = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.floors).forEach(([key, value]) => {
            exports.MapSetFloors_FloorsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetFloors);
        message.floors = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetFloors_FloorsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.floors[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetFloors_FloorsEntry = { key: "", value: "" };
exports.MapSetFloors_FloorsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetFloors_FloorsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetAreas = { mapId: "" };
exports.MapSetAreas = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        Object.entries(message.areas).forEach(([key, value]) => {
            exports.MapSetAreas_AreasEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetAreas);
        message.areas = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    const entry2 = exports.MapSetAreas_AreasEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.areas[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetAreas_AreasEntry = { key: "" };
exports.MapSetAreas_AreasEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.WireArea.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetAreas_AreasEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.WireArea.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapDeleteObject = { mapId: "", key: 0 };
exports.MapDeleteObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.key !== 0) {
            writer.uint32(16).uint32(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapDeleteObject);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.key = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapDeleteObjectById = { mapId: "", id: "" };
exports.MapDeleteObjectById = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapDeleteObjectById);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetMiniMapImagePath = { mapId: "", miniMapImagePath: "" };
exports.MapSetMiniMapImagePath = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.miniMapImagePath !== "") {
            writer.uint32(18).string(message.miniMapImagePath);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetMiniMapImagePath);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.miniMapImagePath = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetEnabledChats = { mapId: "", enabledChats: "" };
exports.MapSetEnabledChats = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        for (const v of message.enabledChats) {
            writer.uint32(18).string(v);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetEnabledChats);
        message.enabledChats = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.enabledChats.push(reader.string());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetDescription = { mapId: "", description: "" };
exports.MapSetDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetDescription);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetDecoration = { mapId: "", decoration: "" };
exports.MapSetDecoration = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.decoration !== "") {
            writer.uint32(18).string(message.decoration);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetDecoration);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.decoration = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetTutorialTasks = { mapId: "" };
exports.MapSetTutorialTasks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.tutorialTasks !== undefined) {
            exports.WireTutorialTasks.encode(message.tutorialTasks, writer.uint32(18).fork()).ldelim();
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetTutorialTasks);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.tutorialTasks = exports.WireTutorialTasks.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWireTutorialTasks = { groupSetId: "" };
exports.WireTutorialTasks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.groupSetId !== "") {
            writer.uint32(10).string(message.groupSetId);
        }
        for (const v of message.areas) {
            exports.TutorialTaskMapArea.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.autoStart !== undefined) {
            writer.uint32(24).bool(message.autoStart);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWireTutorialTasks);
        message.areas = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.groupSetId = reader.string();
                    break;
                case 2:
                    message.areas.push(exports.TutorialTaskMapArea.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.autoStart = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTutorialTaskMapArea = { areaId: "", x: 0, y: 0, height: 0, width: 0 };
exports.TutorialTaskMapArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.areaId !== "") {
            writer.uint32(10).string(message.areaId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.height !== 0) {
            writer.uint32(32).uint32(message.height);
        }
        if (message.width !== 0) {
            writer.uint32(40).uint32(message.width);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTutorialTaskMapArea);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.areaId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.height = reader.uint32();
                    break;
                case 5:
                    message.width = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapSetScript = { mapId: "", script: "" };
exports.MapSetScript = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.script !== "") {
            writer.uint32(18).string(message.script);
        }
        if (message.delete !== undefined) {
            writer.uint32(24).bool(message.delete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapSetScript);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.script = reader.string();
                    break;
                case 3:
                    message.delete = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInventory = {};
exports.Inventory = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.items).forEach(([key, value]) => {
            exports.Inventory_ItemsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.order).forEach(([key, value]) => {
            exports.Inventory_OrderEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInventory);
        message.items = {};
        message.order = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.Inventory_ItemsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.items[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    const entry2 = exports.Inventory_OrderEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.order[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInventory_ItemsEntry = { key: "" };
exports.Inventory_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.InventoryItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInventory_ItemsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.InventoryItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInventory_OrderEntry = { key: "", value: "" };
exports.Inventory_OrderEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInventory_OrderEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInventoryItem = { count: 0 };
exports.InventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.count !== 0) {
            writer.uint32(8).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInventoryItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceItem = { name: "", previewUrl: "" };
exports.SpaceItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.category !== undefined) {
            writer.uint32(18).string(message.category);
        }
        if (message.description !== undefined) {
            writer.uint32(26).string(message.description);
        }
        if (message.previewUrl !== "") {
            writer.uint32(34).string(message.previewUrl);
        }
        Object.entries(message.meta).forEach(([key, value]) => {
            exports.SpaceItem_MetaEntry.encode({ key: key, value }, writer.uint32(42).fork()).ldelim();
        });
        Object.entries(message.abilities).forEach(([key, value]) => {
            exports.SpaceItem_AbilitiesEntry.encode({ key: key, value }, writer.uint32(50).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceItem);
        message.meta = {};
        message.abilities = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.category = reader.string();
                    break;
                case 3:
                    message.description = reader.string();
                    break;
                case 4:
                    message.previewUrl = reader.string();
                    break;
                case 5:
                    const entry5 = exports.SpaceItem_MetaEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.meta[entry5.key] = entry5.value;
                    }
                    break;
                case 6:
                    const entry6 = exports.SpaceItem_AbilitiesEntry.decode(reader, reader.uint32());
                    if (entry6.value !== undefined) {
                        message.abilities[entry6.key] = entry6.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceItem_MetaEntry = { key: "", value: "" };
exports.SpaceItem_MetaEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceItem_MetaEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceItem_AbilitiesEntry = { key: "" };
exports.SpaceItem_AbilitiesEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.ItemAbility.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceItem_AbilitiesEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.ItemAbility.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseItemAbility = { name: "" };
exports.ItemAbility = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseItemAbility);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapLocation = { map: "", x: 0, y: 0 };
exports.MapLocation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.map !== "") {
            writer.uint32(10).string(message.map);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapLocation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.map = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseServerClientBatch = {};
exports.ServerClientBatch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.events) {
            exports.ServerClientEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseServerClientBatch);
        message.events = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.events.push(exports.ServerClientEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseServerClientEvent = {};
exports.ServerClientEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87, _88, _89, _90, _91, _92, _93;
        if (((_a = message.event) === null || _a === void 0 ? void 0 : _a.$case) === "info") {
            exports.Info.encode(message.event.info, writer.uint32(802).fork()).ldelim();
        }
        if (((_b = message.event) === null || _b === void 0 ? void 0 : _b.$case) === "warn") {
            exports.Warn.encode(message.event.warn, writer.uint32(810).fork()).ldelim();
        }
        if (((_c = message.event) === null || _c === void 0 ? void 0 : _c.$case) === "error") {
            exports.ErrorEvent.encode(message.event.error, writer.uint32(818).fork()).ldelim();
        }
        if (((_d = message.event) === null || _d === void 0 ? void 0 : _d.$case) === "ready") {
            exports.Ready.encode(message.event.ready, writer.uint32(826).fork()).ldelim();
        }
        if (((_e = message.event) === null || _e === void 0 ? void 0 : _e.$case) === "serverHeartbeat") {
            exports.ServerHeartbeat.encode(message.event.serverHeartbeat, writer.uint32(842).fork()).ldelim();
        }
        if (((_f = message.event) === null || _f === void 0 ? void 0 : _f.$case) === "transactionStatus") {
            exports.TransactionStatus.encode(message.event.transactionStatus, writer.uint32(858).fork()).ldelim();
        }
        if (((_g = message.event) === null || _g === void 0 ? void 0 : _g.$case) === "playerMoves") {
            exports.PlayerMoves.encode(message.event.playerMoves, writer.uint32(10).fork()).ldelim();
        }
        if (((_h = message.event) === null || _h === void 0 ? void 0 : _h.$case) === "playerSetsStatus") {
            exports.PlayerSetsStatus.encode(message.event.playerSetsStatus, writer.uint32(42).fork()).ldelim();
        }
        if (((_j = message.event) === null || _j === void 0 ? void 0 : _j.$case) === "playerSpotlights") {
            exports.PlayerSpotlights.encode(message.event.playerSpotlights, writer.uint32(50).fork()).ldelim();
        }
        if (((_k = message.event) === null || _k === void 0 ? void 0 : _k.$case) === "playerRings") {
            exports.PlayerRings.encode(message.event.playerRings, writer.uint32(58).fork()).ldelim();
        }
        if (((_l = message.event) === null || _l === void 0 ? void 0 : _l.$case) === "playerChats") {
            exports.PlayerChats.encode(message.event.playerChats, writer.uint32(74).fork()).ldelim();
        }
        if (((_m = message.event) === null || _m === void 0 ? void 0 : _m.$case) === "playerInteracts") {
            exports.PlayerInteracts.encode(message.event.playerInteracts, writer.uint32(82).fork()).ldelim();
        }
        if (((_o = message.event) === null || _o === void 0 ? void 0 : _o.$case) === "playerGhosts") {
            exports.PlayerGhosts.encode(message.event.playerGhosts, writer.uint32(90).fork()).ldelim();
        }
        if (((_p = message.event) === null || _p === void 0 ? void 0 : _p.$case) === "playerEntersWhisper") {
            exports.PlayerEntersWhisper.encode(message.event.playerEntersWhisper, writer.uint32(98).fork()).ldelim();
        }
        if (((_q = message.event) === null || _q === void 0 ? void 0 : _q.$case) === "playerLeavesWhisper") {
            exports.PlayerLeavesWhisper.encode(message.event.playerLeavesWhisper, writer.uint32(106).fork()).ldelim();
        }
        if (((_r = message.event) === null || _r === void 0 ? void 0 : _r.$case) === "playerActivelySpeaks") {
            exports.PlayerActivelySpeaks.encode(message.event.playerActivelySpeaks, writer.uint32(114).fork()).ldelim();
        }
        if (((_s = message.event) === null || _s === void 0 ? void 0 : _s.$case) === "playerSetsWorkCondition") {
            exports.PlayerSetsWorkCondition.encode(message.event.playerSetsWorkCondition, writer.uint32(130).fork()).ldelim();
        }
        if (((_t = message.event) === null || _t === void 0 ? void 0 : _t.$case) === "playerSetsName") {
            exports.PlayerSetsName.encode(message.event.playerSetsName, writer.uint32(138).fork()).ldelim();
        }
        if (((_u = message.event) === null || _u === void 0 ? void 0 : _u.$case) === "playerSetsTextStatus") {
            exports.PlayerSetsTextStatus.encode(message.event.playerSetsTextStatus, writer.uint32(146).fork()).ldelim();
        }
        if (((_v = message.event) === null || _v === void 0 ? void 0 : _v.$case) === "playerSetsEmojiStatus") {
            exports.PlayerSetsEmojiStatus.encode(message.event.playerSetsEmojiStatus, writer.uint32(154).fork()).ldelim();
        }
        if (((_w = message.event) === null || _w === void 0 ? void 0 : _w.$case) === "playerSetsAffiliation") {
            exports.PlayerSetsAffiliation.encode(message.event.playerSetsAffiliation, writer.uint32(162).fork()).ldelim();
        }
        if (((_x = message.event) === null || _x === void 0 ? void 0 : _x.$case) === "playerExits") {
            exports.PlayerExits.encode(message.event.playerExits, writer.uint32(170).fork()).ldelim();
        }
        if (((_y = message.event) === null || _y === void 0 ? void 0 : _y.$case) === "respawnComplete") {
            exports.RespawnComplete.encode(message.event.respawnComplete, writer.uint32(314).fork()).ldelim();
        }
        if (((_z = message.event) === null || _z === void 0 ? void 0 : _z.$case) === "playerSetsOutfitString") {
            exports.PlayerSetsOutfitString.encode(message.event.playerSetsOutfitString, writer.uint32(322).fork()).ldelim();
        }
        if (((_0 = message.event) === null || _0 === void 0 ? void 0 : _0.$case) === "playerSetsIsSignedIn") {
            exports.PlayerSetsIsSignedIn.encode(message.event.playerSetsIsSignedIn, writer.uint32(330).fork()).ldelim();
        }
        if (((_1 = message.event) === null || _1 === void 0 ? void 0 : _1.$case) === "spaceOverwrites") {
            exports.SpaceOverwrites.encode(message.event.spaceOverwrites, writer.uint32(354).fork()).ldelim();
        }
        if (((_2 = message.event) === null || _2 === void 0 ? void 0 : _2.$case) === "spaceIsClosed") {
            exports.SpaceIsClosed.encode(message.event.spaceIsClosed, writer.uint32(362).fork()).ldelim();
        }
        if (((_3 = message.event) === null || _3 === void 0 ? void 0 : _3.$case) === "playerEntersPortal") {
            exports.PlayerEntersPortal.encode(message.event.playerEntersPortal, writer.uint32(370).fork()).ldelim();
        }
        if (((_4 = message.event) === null || _4 === void 0 ? void 0 : _4.$case) === "spaceSetsIdMapping") {
            exports.SpaceSetsIdMapping.encode(message.event.spaceSetsIdMapping, writer.uint32(378).fork()).ldelim();
        }
        if (((_5 = message.event) === null || _5 === void 0 ? void 0 : _5.$case) === "playerSetsLastActive") {
            exports.PlayerSetsLastActive.encode(message.event.playerSetsLastActive, writer.uint32(386).fork()).ldelim();
        }
        if (((_6 = message.event) === null || _6 === void 0 ? void 0 : _6.$case) === "playerShootsConfetti") {
            exports.PlayerShootsConfetti.encode(message.event.playerShootsConfetti, writer.uint32(394).fork()).ldelim();
        }
        if (((_7 = message.event) === null || _7 === void 0 ? void 0 : _7.$case) === "playerSetsEventStatus") {
            exports.PlayerSetsEventStatus.encode(message.event.playerSetsEventStatus, writer.uint32(402).fork()).ldelim();
        }
        if (((_8 = message.event) === null || _8 === void 0 ? void 0 : _8.$case) === "playerSetsInConversation") {
            exports.PlayerSetsInConversation.encode(message.event.playerSetsInConversation, writer.uint32(410).fork()).ldelim();
        }
        if (((_9 = message.event) === null || _9 === void 0 ? void 0 : _9.$case) === "playerSetsCurrentDesk") {
            exports.PlayerSetsCurrentDesk.encode(message.event.playerSetsCurrentDesk, writer.uint32(418).fork()).ldelim();
        }
        if (((_10 = message.event) === null || _10 === void 0 ? void 0 : _10.$case) === "playerSetsCurrentArea") {
            exports.PlayerSetsCurrentArea.encode(message.event.playerSetsCurrentArea, writer.uint32(426).fork()).ldelim();
        }
        if (((_11 = message.event) === null || _11 === void 0 ? void 0 : _11.$case) === "playerSetsImagePointer") {
            exports.PlayerSetsImagePointer.encode(message.event.playerSetsImagePointer, writer.uint32(434).fork()).ldelim();
        }
        if (((_12 = message.event) === null || _12 === void 0 ? void 0 : _12.$case) === "cookieFound") {
            exports.CookieFound.encode(message.event.cookieFound, writer.uint32(442).fork()).ldelim();
        }
        if (((_13 = message.event) === null || _13 === void 0 ? void 0 : _13.$case) === "playerEntersWhisperV2") {
            exports.PlayerEntersWhisperV2.encode(message.event.playerEntersWhisperV2, writer.uint32(450).fork()).ldelim();
        }
        if (((_14 = message.event) === null || _14 === void 0 ? void 0 : _14.$case) === "playerSetsGoKartId") {
            exports.PlayerSetsGoKartId.encode(message.event.playerSetsGoKartId, writer.uint32(458).fork()).ldelim();
        }
        if (((_15 = message.event) === null || _15 === void 0 ? void 0 : _15.$case) === "mapSetDimensions") {
            exports.MapSetDimensions.encode(message.event.mapSetDimensions, writer.uint32(466).fork()).ldelim();
        }
        if (((_16 = message.event) === null || _16 === void 0 ? void 0 : _16.$case) === "mapSetCollisions") {
            exports.MapSetCollisions.encode(message.event.mapSetCollisions, writer.uint32(474).fork()).ldelim();
        }
        if (((_17 = message.event) === null || _17 === void 0 ? void 0 : _17.$case) === "mapSetBackgroundImagePath") {
            exports.MapSetBackgroundImagePath.encode(message.event.mapSetBackgroundImagePath, writer.uint32(482).fork()).ldelim();
        }
        if (((_18 = message.event) === null || _18 === void 0 ? void 0 : _18.$case) === "mapSetForegroundImagePath") {
            exports.MapSetForegroundImagePath.encode(message.event.mapSetForegroundImagePath, writer.uint32(490).fork()).ldelim();
        }
        if (((_19 = message.event) === null || _19 === void 0 ? void 0 : _19.$case) === "mapSetSprites") {
            exports.MapSetSprites.encode(message.event.mapSetSprites, writer.uint32(498).fork()).ldelim();
        }
        if (((_20 = message.event) === null || _20 === void 0 ? void 0 : _20.$case) === "mapSetSpaces") {
            exports.MapSetSpaces.encode(message.event.mapSetSpaces, writer.uint32(506).fork()).ldelim();
        }
        if (((_21 = message.event) === null || _21 === void 0 ? void 0 : _21.$case) === "mapSetSpawns") {
            exports.MapSetSpawns.encode(message.event.mapSetSpawns, writer.uint32(514).fork()).ldelim();
        }
        if (((_22 = message.event) === null || _22 === void 0 ? void 0 : _22.$case) === "mapSetPortals") {
            exports.MapSetPortals.encode(message.event.mapSetPortals, writer.uint32(522).fork()).ldelim();
        }
        if (((_23 = message.event) === null || _23 === void 0 ? void 0 : _23.$case) === "mapSetAnnouncer") {
            exports.MapSetAnnouncer.encode(message.event.mapSetAnnouncer, writer.uint32(530).fork()).ldelim();
        }
        if (((_24 = message.event) === null || _24 === void 0 ? void 0 : _24.$case) === "mapSetAssets") {
            exports.MapSetAssets.encode(message.event.mapSetAssets, writer.uint32(554).fork()).ldelim();
        }
        if (((_25 = message.event) === null || _25 === void 0 ? void 0 : _25.$case) === "mapSetObjects") {
            exports.MapSetObjects.encode(message.event.mapSetObjects, writer.uint32(562).fork()).ldelim();
        }
        if (((_26 = message.event) === null || _26 === void 0 ? void 0 : _26.$case) === "mapSetName") {
            exports.MapSetName.encode(message.event.mapSetName, writer.uint32(570).fork()).ldelim();
        }
        if (((_27 = message.event) === null || _27 === void 0 ? void 0 : _27.$case) === "mapSetMuteOnEntry") {
            exports.MapSetMuteOnEntry.encode(message.event.mapSetMuteOnEntry, writer.uint32(586).fork()).ldelim();
        }
        if (((_28 = message.event) === null || _28 === void 0 ? void 0 : _28.$case) === "mapSetUseDrawnBG") {
            exports.MapSetUseDrawnBG.encode(message.event.mapSetUseDrawnBG, writer.uint32(594).fork()).ldelim();
        }
        if (((_29 = message.event) === null || _29 === void 0 ? void 0 : _29.$case) === "mapSetWalls") {
            exports.MapSetWalls.encode(message.event.mapSetWalls, writer.uint32(602).fork()).ldelim();
        }
        if (((_30 = message.event) === null || _30 === void 0 ? void 0 : _30.$case) === "mapSetFloors") {
            exports.MapSetFloors.encode(message.event.mapSetFloors, writer.uint32(610).fork()).ldelim();
        }
        if (((_31 = message.event) === null || _31 === void 0 ? void 0 : _31.$case) === "mapSetAreas") {
            exports.MapSetAreas.encode(message.event.mapSetAreas, writer.uint32(618).fork()).ldelim();
        }
        if (((_32 = message.event) === null || _32 === void 0 ? void 0 : _32.$case) === "mapDeleteObject") {
            exports.MapDeleteObject.encode(message.event.mapDeleteObject, writer.uint32(626).fork()).ldelim();
        }
        if (((_33 = message.event) === null || _33 === void 0 ? void 0 : _33.$case) === "mapSetSpawn") {
            exports.MapSetSpawn.encode(message.event.mapSetSpawn, writer.uint32(634).fork()).ldelim();
        }
        if (((_34 = message.event) === null || _34 === void 0 ? void 0 : _34.$case) === "playerSetsIsAlone") {
            exports.PlayerSetsIsAlone.encode(message.event.playerSetsIsAlone, writer.uint32(642).fork()).ldelim();
        }
        if (((_35 = message.event) === null || _35 === void 0 ? void 0 : _35.$case) === "playerJoins") {
            exports.PlayerJoins.encode(message.event.playerJoins, writer.uint32(650).fork()).ldelim();
        }
        if (((_36 = message.event) === null || _36 === void 0 ? void 0 : _36.$case) === "mapSetEnabledChats") {
            exports.MapSetEnabledChats.encode(message.event.mapSetEnabledChats, writer.uint32(658).fork()).ldelim();
        }
        if (((_37 = message.event) === null || _37 === void 0 ? void 0 : _37.$case) === "mapSetDescription") {
            exports.MapSetDescription.encode(message.event.mapSetDescription, writer.uint32(666).fork()).ldelim();
        }
        if (((_38 = message.event) === null || _38 === void 0 ? void 0 : _38.$case) === "mapSetDecoration") {
            exports.MapSetDecoration.encode(message.event.mapSetDecoration, writer.uint32(674).fork()).ldelim();
        }
        if (((_39 = message.event) === null || _39 === void 0 ? void 0 : _39.$case) === "mapSetTutorialTasks") {
            exports.MapSetTutorialTasks.encode(message.event.mapSetTutorialTasks, writer.uint32(682).fork()).ldelim();
        }
        if (((_40 = message.event) === null || _40 === void 0 ? void 0 : _40.$case) === "mapSetMiniMapImagePath") {
            exports.MapSetMiniMapImagePath.encode(message.event.mapSetMiniMapImagePath, writer.uint32(690).fork()).ldelim();
        }
        if (((_41 = message.event) === null || _41 === void 0 ? void 0 : _41.$case) === "spacePlaysSound") {
            exports.SpacePlaysSound.encode(message.event.spacePlaysSound, writer.uint32(698).fork()).ldelim();
        }
        if (((_42 = message.event) === null || _42 === void 0 ? void 0 : _42.$case) === "mapSetScript") {
            exports.MapSetScript.encode(message.event.mapSetScript, writer.uint32(706).fork()).ldelim();
        }
        if (((_43 = message.event) === null || _43 === void 0 ? void 0 : _43.$case) === "playerSetsIsMobile") {
            exports.PlayerSetsIsMobile.encode(message.event.playerSetsIsMobile, writer.uint32(722).fork()).ldelim();
        }
        if (((_44 = message.event) === null || _44 === void 0 ? void 0 : _44.$case) === "setScreenPointerServer") {
            exports.SetScreenPointerServer.encode(message.event.setScreenPointerServer, writer.uint32(730).fork()).ldelim();
        }
        if (((_45 = message.event) === null || _45 === void 0 ? void 0 : _45.$case) === "playerSetsEmoteV2") {
            exports.PlayerSetsEmoteV2.encode(message.event.playerSetsEmoteV2, writer.uint32(738).fork()).ldelim();
        }
        if (((_46 = message.event) === null || _46 === void 0 ? void 0 : _46.$case) === "playerSetsFocusModeEndTime") {
            exports.PlayerSetsFocusModeEndTime.encode(message.event.playerSetsFocusModeEndTime, writer.uint32(746).fork()).ldelim();
        }
        if (((_47 = message.event) === null || _47 === void 0 ? void 0 : _47.$case) === "spaceSetsSpaceMembers") {
            exports.SpaceSetsSpaceMembers.encode(message.event.spaceSetsSpaceMembers, writer.uint32(754).fork()).ldelim();
        }
        if (((_48 = message.event) === null || _48 === void 0 ? void 0 : _48.$case) === "customEvent") {
            exports.CustomEvent.encode(message.event.customEvent, writer.uint32(762).fork()).ldelim();
        }
        if (((_49 = message.event) === null || _49 === void 0 ? void 0 : _49.$case) === "playerBlocks") {
            exports.PlayerBlocks.encode(message.event.playerBlocks, writer.uint32(778).fork()).ldelim();
        }
        if (((_50 = message.event) === null || _50 === void 0 ? void 0 : _50.$case) === "playerUpdatesFocusModeStatus") {
            exports.PlayerUpdatesFocusModeStatus.encode(message.event.playerUpdatesFocusModeStatus, writer.uint32(786).fork()).ldelim();
        }
        if (((_51 = message.event) === null || _51 === void 0 ? void 0 : _51.$case) === "playerNotifies") {
            exports.PlayerNotifies.encode(message.event.playerNotifies, writer.uint32(794).fork()).ldelim();
        }
        if (((_52 = message.event) === null || _52 === void 0 ? void 0 : _52.$case) === "playerSetsItemString") {
            exports.PlayerSetsItemString.encode(message.event.playerSetsItemString, writer.uint32(866).fork()).ldelim();
        }
        if (((_53 = message.event) === null || _53 === void 0 ? void 0 : _53.$case) === "playerTriggersItem") {
            exports.PlayerTriggersItem.encode(message.event.playerTriggersItem, writer.uint32(874).fork()).ldelim();
        }
        if (((_54 = message.event) === null || _54 === void 0 ? void 0 : _54.$case) === "playerSetsFollowTarget") {
            exports.PlayerSetsFollowTarget.encode(message.event.playerSetsFollowTarget, writer.uint32(882).fork()).ldelim();
        }
        if (((_55 = message.event) === null || _55 === void 0 ? void 0 : _55.$case) === "playerRequestsToLead") {
            exports.PlayerRequestsToLead.encode(message.event.playerRequestsToLead, writer.uint32(890).fork()).ldelim();
        }
        if (((_56 = message.event) === null || _56 === void 0 ? void 0 : _56.$case) === "playerSetsManualVideoSrc") {
            exports.PlayerSetsManualVideoSrc.encode(message.event.playerSetsManualVideoSrc, writer.uint32(898).fork()).ldelim();
        }
        if (((_57 = message.event) === null || _57 === void 0 ? void 0 : _57.$case) === "playerSetsIsNpc") {
            exports.PlayerSetsIsNpc.encode(message.event.playerSetsIsNpc, writer.uint32(906).fork()).ldelim();
        }
        if (((_58 = message.event) === null || _58 === void 0 ? void 0 : _58.$case) === "playerSetsSubtitle") {
            exports.PlayerSetsSubtitle.encode(message.event.playerSetsSubtitle, writer.uint32(914).fork()).ldelim();
        }
        if (((_59 = message.event) === null || _59 === void 0 ? void 0 : _59.$case) === "mapCommitsChanges") {
            exports.MapCommitsChanges.encode(message.event.mapCommitsChanges, writer.uint32(922).fork()).ldelim();
        }
        if (((_60 = message.event) === null || _60 === void 0 ? void 0 : _60.$case) === "playerUpdatesSession") {
            exports.PlayerUpdatesSession.encode(message.event.playerUpdatesSession, writer.uint32(930).fork()).ldelim();
        }
        if (((_61 = message.event) === null || _61 === void 0 ? void 0 : _61.$case) === "mapMoveObject") {
            exports.MapMoveObject.encode(message.event.mapMoveObject, writer.uint32(938).fork()).ldelim();
        }
        if (((_62 = message.event) === null || _62 === void 0 ? void 0 : _62.$case) === "playerEditsChatMessage") {
            exports.PlayerEditsChatMessage.encode(message.event.playerEditsChatMessage, writer.uint32(946).fork()).ldelim();
        }
        if (((_63 = message.event) === null || _63 === void 0 ? void 0 : _63.$case) === "fxShakeObject") {
            exports.FXShakeObject.encode(message.event.fxShakeObject, writer.uint32(954).fork()).ldelim();
        }
        if (((_64 = message.event) === null || _64 === void 0 ? void 0 : _64.$case) === "fxShakeCamera") {
            exports.FXShakeCamera.encode(message.event.fxShakeCamera, writer.uint32(962).fork()).ldelim();
        }
        if (((_65 = message.event) === null || _65 === void 0 ? void 0 : _65.$case) === "playerSendsCommand") {
            exports.PlayerSendsCommand.encode(message.event.playerSendsCommand, writer.uint32(970).fork()).ldelim();
        }
        if (((_66 = message.event) === null || _66 === void 0 ? void 0 : _66.$case) === "spaceRegistersCommand") {
            exports.SpaceRegistersCommand.encode(message.event.spaceRegistersCommand, writer.uint32(978).fork()).ldelim();
        }
        if (((_67 = message.event) === null || _67 === void 0 ? void 0 : _67.$case) === "speakerUpdatesSession") {
            exports.SpeakerUpdatesSession.encode(message.event.speakerUpdatesSession, writer.uint32(986).fork()).ldelim();
        }
        if (((_68 = message.event) === null || _68 === void 0 ? void 0 : _68.$case) === "playerUpdatesInventory") {
            exports.PlayerUpdatesInventory.encode(message.event.playerUpdatesInventory, writer.uint32(994).fork()).ldelim();
        }
        if (((_69 = message.event) === null || _69 === void 0 ? void 0 : _69.$case) === "spaceUpdatesItems") {
            exports.SpaceUpdatesItems.encode(message.event.spaceUpdatesItems, writer.uint32(1002).fork()).ldelim();
        }
        if (((_70 = message.event) === null || _70 === void 0 ? void 0 : _70.$case) === "playerSetsVehicleId") {
            exports.PlayerSetsVehicleId.encode(message.event.playerSetsVehicleId, writer.uint32(1010).fork()).ldelim();
        }
        if (((_71 = message.event) === null || _71 === void 0 ? void 0 : _71.$case) === "playerSetsSpeedModifier") {
            exports.PlayerSetsSpeedModifier.encode(message.event.playerSetsSpeedModifier, writer.uint32(1018).fork()).ldelim();
        }
        if (((_72 = message.event) === null || _72 === void 0 ? void 0 : _72.$case) === "playerHighFives") {
            exports.PlayerHighFives.encode(message.event.playerHighFives, writer.uint32(1026).fork()).ldelim();
        }
        if (((_73 = message.event) === null || _73 === void 0 ? void 0 : _73.$case) === "spaceStopsSound") {
            exports.SpaceStopsSound.encode(message.event.spaceStopsSound, writer.uint32(1042).fork()).ldelim();
        }
        if (((_74 = message.event) === null || _74 === void 0 ? void 0 : _74.$case) === "hipToBeSquare") {
            exports.HipToBeSquare.encode(message.event.hipToBeSquare, writer.uint32(1050).fork()).ldelim();
        }
        if (((_75 = message.event) === null || _75 === void 0 ? void 0 : _75.$case) === "playerCrafts") {
            exports.PlayerCrafts.encode(message.event.playerCrafts, writer.uint32(1058).fork()).ldelim();
        }
        if (((_76 = message.event) === null || _76 === void 0 ? void 0 : _76.$case) === "playerTriggersInventoryItem") {
            exports.PlayerTriggersInventoryItem.encode(message.event.playerTriggersInventoryItem, writer.uint32(1066).fork()).ldelim();
        }
        if (((_77 = message.event) === null || _77 === void 0 ? void 0 : _77.$case) === "playerSetsAllowScreenPointer") {
            exports.PlayerSetsAllowScreenPointer.encode(message.event.playerSetsAllowScreenPointer, writer.uint32(1074).fork()).ldelim();
        }
        if (((_78 = message.event) === null || _78 === void 0 ? void 0 : _78.$case) === "precomputedEnterLocation") {
            exports.PrecomputedEnterLocation.encode(message.event.precomputedEnterLocation, writer.uint32(1082).fork()).ldelim();
        }
        if (((_79 = message.event) === null || _79 === void 0 ? void 0 : _79.$case) === "gotRequestMute") {
            exports.GotRequestMute.encode(message.event.gotRequestMute, writer.uint32(1090).fork()).ldelim();
        }
        if (((_80 = message.event) === null || _80 === void 0 ? void 0 : _80.$case) === "playerSetsDeskInfo") {
            exports.PlayerSetsDeskInfo.encode(message.event.playerSetsDeskInfo, writer.uint32(1098).fork()).ldelim();
        }
        if (((_81 = message.event) === null || _81 === void 0 ? void 0 : _81.$case) === "mapSetNooks") {
            exports.MapSetNooks.encode(message.event.mapSetNooks, writer.uint32(1106).fork()).ldelim();
        }
        if (((_82 = message.event) === null || _82 === void 0 ? void 0 : _82.$case) === "dynamicGates") {
            exports.DynamicGates.encode(message.event.dynamicGates, writer.uint32(1114).fork()).ldelim();
        }
        if (((_83 = message.event) === null || _83 === void 0 ? void 0 : _83.$case) === "playerWaves") {
            exports.PlayerWaves.encode(message.event.playerWaves, writer.uint32(1122).fork()).ldelim();
        }
        if (((_84 = message.event) === null || _84 === void 0 ? void 0 : _84.$case) === "playerSetsPronouns") {
            exports.PlayerSetsPronouns.encode(message.event.playerSetsPronouns, writer.uint32(1130).fork()).ldelim();
        }
        if (((_85 = message.event) === null || _85 === void 0 ? void 0 : _85.$case) === "playerSetsTitle") {
            exports.PlayerSetsTitle.encode(message.event.playerSetsTitle, writer.uint32(1138).fork()).ldelim();
        }
        if (((_86 = message.event) === null || _86 === void 0 ? void 0 : _86.$case) === "playerSetsTimezone") {
            exports.PlayerSetsTimezone.encode(message.event.playerSetsTimezone, writer.uint32(1146).fork()).ldelim();
        }
        if (((_87 = message.event) === null || _87 === void 0 ? void 0 : _87.$case) === "playerSetsDescription") {
            exports.PlayerSetsDescription.encode(message.event.playerSetsDescription, writer.uint32(1154).fork()).ldelim();
        }
        if (((_88 = message.event) === null || _88 === void 0 ? void 0 : _88.$case) === "playerSetsPhone") {
            exports.PlayerSetsPhone.encode(message.event.playerSetsPhone, writer.uint32(1162).fork()).ldelim();
        }
        if (((_89 = message.event) === null || _89 === void 0 ? void 0 : _89.$case) === "playerSetsPersonalImageUrl") {
            exports.PlayerSetsPersonalImageUrl.encode(message.event.playerSetsPersonalImageUrl, writer.uint32(1170).fork()).ldelim();
        }
        if (((_90 = message.event) === null || _90 === void 0 ? void 0 : _90.$case) === "playerSetsProfileImageUrl") {
            exports.PlayerSetsProfileImageUrl.encode(message.event.playerSetsProfileImageUrl, writer.uint32(1178).fork()).ldelim();
        }
        if (((_91 = message.event) === null || _91 === void 0 ? void 0 : _91.$case) === "spaceSetsCapacity") {
            exports.SpaceSetsCapacity.encode(message.event.spaceSetsCapacity, writer.uint32(1186).fork()).ldelim();
        }
        if (((_92 = message.event) === null || _92 === void 0 ? void 0 : _92.$case) === "spaceOverCapacityDeniesUser") {
            exports.SpaceOverCapacityDeniesUser.encode(message.event.spaceOverCapacityDeniesUser, writer.uint32(1194).fork()).ldelim();
        }
        if (((_93 = message.event) === null || _93 === void 0 ? void 0 : _93.$case) === "playerSetsAway") {
            exports.PlayerSetsAway.encode(message.event.playerSetsAway, writer.uint32(1202).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseServerClientEvent);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 100:
                    message.event = { $case: "info", info: exports.Info.decode(reader, reader.uint32()) };
                    break;
                case 101:
                    message.event = { $case: "warn", warn: exports.Warn.decode(reader, reader.uint32()) };
                    break;
                case 102:
                    message.event = { $case: "error", error: exports.ErrorEvent.decode(reader, reader.uint32()) };
                    break;
                case 103:
                    message.event = { $case: "ready", ready: exports.Ready.decode(reader, reader.uint32()) };
                    break;
                case 105:
                    message.event = {
                        $case: "serverHeartbeat",
                        serverHeartbeat: exports.ServerHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 107:
                    message.event = {
                        $case: "transactionStatus",
                        transactionStatus: exports.TransactionStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 1:
                    message.event = {
                        $case: "playerMoves",
                        playerMoves: exports.PlayerMoves.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.event = {
                        $case: "playerSetsStatus",
                        playerSetsStatus: exports.PlayerSetsStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 6:
                    message.event = {
                        $case: "playerSpotlights",
                        playerSpotlights: exports.PlayerSpotlights.decode(reader, reader.uint32()),
                    };
                    break;
                case 7:
                    message.event = {
                        $case: "playerRings",
                        playerRings: exports.PlayerRings.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.event = {
                        $case: "playerChats",
                        playerChats: exports.PlayerChats.decode(reader, reader.uint32()),
                    };
                    break;
                case 10:
                    message.event = {
                        $case: "playerInteracts",
                        playerInteracts: exports.PlayerInteracts.decode(reader, reader.uint32()),
                    };
                    break;
                case 11:
                    message.event = {
                        $case: "playerGhosts",
                        playerGhosts: exports.PlayerGhosts.decode(reader, reader.uint32()),
                    };
                    break;
                case 12:
                    message.event = {
                        $case: "playerEntersWhisper",
                        playerEntersWhisper: exports.PlayerEntersWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 13:
                    message.event = {
                        $case: "playerLeavesWhisper",
                        playerLeavesWhisper: exports.PlayerLeavesWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 14:
                    message.event = {
                        $case: "playerActivelySpeaks",
                        playerActivelySpeaks: exports.PlayerActivelySpeaks.decode(reader, reader.uint32()),
                    };
                    break;
                case 16:
                    message.event = {
                        $case: "playerSetsWorkCondition",
                        playerSetsWorkCondition: exports.PlayerSetsWorkCondition.decode(reader, reader.uint32()),
                    };
                    break;
                case 17:
                    message.event = {
                        $case: "playerSetsName",
                        playerSetsName: exports.PlayerSetsName.decode(reader, reader.uint32()),
                    };
                    break;
                case 18:
                    message.event = {
                        $case: "playerSetsTextStatus",
                        playerSetsTextStatus: exports.PlayerSetsTextStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 19:
                    message.event = {
                        $case: "playerSetsEmojiStatus",
                        playerSetsEmojiStatus: exports.PlayerSetsEmojiStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 20:
                    message.event = {
                        $case: "playerSetsAffiliation",
                        playerSetsAffiliation: exports.PlayerSetsAffiliation.decode(reader, reader.uint32()),
                    };
                    break;
                case 21:
                    message.event = {
                        $case: "playerExits",
                        playerExits: exports.PlayerExits.decode(reader, reader.uint32()),
                    };
                    break;
                case 39:
                    message.event = {
                        $case: "respawnComplete",
                        respawnComplete: exports.RespawnComplete.decode(reader, reader.uint32()),
                    };
                    break;
                case 40:
                    message.event = {
                        $case: "playerSetsOutfitString",
                        playerSetsOutfitString: exports.PlayerSetsOutfitString.decode(reader, reader.uint32()),
                    };
                    break;
                case 41:
                    message.event = {
                        $case: "playerSetsIsSignedIn",
                        playerSetsIsSignedIn: exports.PlayerSetsIsSignedIn.decode(reader, reader.uint32()),
                    };
                    break;
                case 44:
                    message.event = {
                        $case: "spaceOverwrites",
                        spaceOverwrites: exports.SpaceOverwrites.decode(reader, reader.uint32()),
                    };
                    break;
                case 45:
                    message.event = {
                        $case: "spaceIsClosed",
                        spaceIsClosed: exports.SpaceIsClosed.decode(reader, reader.uint32()),
                    };
                    break;
                case 46:
                    message.event = {
                        $case: "playerEntersPortal",
                        playerEntersPortal: exports.PlayerEntersPortal.decode(reader, reader.uint32()),
                    };
                    break;
                case 47:
                    message.event = {
                        $case: "spaceSetsIdMapping",
                        spaceSetsIdMapping: exports.SpaceSetsIdMapping.decode(reader, reader.uint32()),
                    };
                    break;
                case 48:
                    message.event = {
                        $case: "playerSetsLastActive",
                        playerSetsLastActive: exports.PlayerSetsLastActive.decode(reader, reader.uint32()),
                    };
                    break;
                case 49:
                    message.event = {
                        $case: "playerShootsConfetti",
                        playerShootsConfetti: exports.PlayerShootsConfetti.decode(reader, reader.uint32()),
                    };
                    break;
                case 50:
                    message.event = {
                        $case: "playerSetsEventStatus",
                        playerSetsEventStatus: exports.PlayerSetsEventStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 51:
                    message.event = {
                        $case: "playerSetsInConversation",
                        playerSetsInConversation: exports.PlayerSetsInConversation.decode(reader, reader.uint32()),
                    };
                    break;
                case 52:
                    message.event = {
                        $case: "playerSetsCurrentDesk",
                        playerSetsCurrentDesk: exports.PlayerSetsCurrentDesk.decode(reader, reader.uint32()),
                    };
                    break;
                case 53:
                    message.event = {
                        $case: "playerSetsCurrentArea",
                        playerSetsCurrentArea: exports.PlayerSetsCurrentArea.decode(reader, reader.uint32()),
                    };
                    break;
                case 54:
                    message.event = {
                        $case: "playerSetsImagePointer",
                        playerSetsImagePointer: exports.PlayerSetsImagePointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 55:
                    message.event = {
                        $case: "cookieFound",
                        cookieFound: exports.CookieFound.decode(reader, reader.uint32()),
                    };
                    break;
                case 56:
                    message.event = {
                        $case: "playerEntersWhisperV2",
                        playerEntersWhisperV2: exports.PlayerEntersWhisperV2.decode(reader, reader.uint32()),
                    };
                    break;
                case 57:
                    message.event = {
                        $case: "playerSetsGoKartId",
                        playerSetsGoKartId: exports.PlayerSetsGoKartId.decode(reader, reader.uint32()),
                    };
                    break;
                case 58:
                    message.event = {
                        $case: "mapSetDimensions",
                        mapSetDimensions: exports.MapSetDimensions.decode(reader, reader.uint32()),
                    };
                    break;
                case 59:
                    message.event = {
                        $case: "mapSetCollisions",
                        mapSetCollisions: exports.MapSetCollisions.decode(reader, reader.uint32()),
                    };
                    break;
                case 60:
                    message.event = {
                        $case: "mapSetBackgroundImagePath",
                        mapSetBackgroundImagePath: exports.MapSetBackgroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 61:
                    message.event = {
                        $case: "mapSetForegroundImagePath",
                        mapSetForegroundImagePath: exports.MapSetForegroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 62:
                    message.event = {
                        $case: "mapSetSprites",
                        mapSetSprites: exports.MapSetSprites.decode(reader, reader.uint32()),
                    };
                    break;
                case 63:
                    message.event = {
                        $case: "mapSetSpaces",
                        mapSetSpaces: exports.MapSetSpaces.decode(reader, reader.uint32()),
                    };
                    break;
                case 64:
                    message.event = {
                        $case: "mapSetSpawns",
                        mapSetSpawns: exports.MapSetSpawns.decode(reader, reader.uint32()),
                    };
                    break;
                case 65:
                    message.event = {
                        $case: "mapSetPortals",
                        mapSetPortals: exports.MapSetPortals.decode(reader, reader.uint32()),
                    };
                    break;
                case 66:
                    message.event = {
                        $case: "mapSetAnnouncer",
                        mapSetAnnouncer: exports.MapSetAnnouncer.decode(reader, reader.uint32()),
                    };
                    break;
                case 69:
                    message.event = {
                        $case: "mapSetAssets",
                        mapSetAssets: exports.MapSetAssets.decode(reader, reader.uint32()),
                    };
                    break;
                case 70:
                    message.event = {
                        $case: "mapSetObjects",
                        mapSetObjects: exports.MapSetObjects.decode(reader, reader.uint32()),
                    };
                    break;
                case 71:
                    message.event = {
                        $case: "mapSetName",
                        mapSetName: exports.MapSetName.decode(reader, reader.uint32()),
                    };
                    break;
                case 73:
                    message.event = {
                        $case: "mapSetMuteOnEntry",
                        mapSetMuteOnEntry: exports.MapSetMuteOnEntry.decode(reader, reader.uint32()),
                    };
                    break;
                case 74:
                    message.event = {
                        $case: "mapSetUseDrawnBG",
                        mapSetUseDrawnBG: exports.MapSetUseDrawnBG.decode(reader, reader.uint32()),
                    };
                    break;
                case 75:
                    message.event = {
                        $case: "mapSetWalls",
                        mapSetWalls: exports.MapSetWalls.decode(reader, reader.uint32()),
                    };
                    break;
                case 76:
                    message.event = {
                        $case: "mapSetFloors",
                        mapSetFloors: exports.MapSetFloors.decode(reader, reader.uint32()),
                    };
                    break;
                case 77:
                    message.event = {
                        $case: "mapSetAreas",
                        mapSetAreas: exports.MapSetAreas.decode(reader, reader.uint32()),
                    };
                    break;
                case 78:
                    message.event = {
                        $case: "mapDeleteObject",
                        mapDeleteObject: exports.MapDeleteObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 79:
                    message.event = {
                        $case: "mapSetSpawn",
                        mapSetSpawn: exports.MapSetSpawn.decode(reader, reader.uint32()),
                    };
                    break;
                case 80:
                    message.event = {
                        $case: "playerSetsIsAlone",
                        playerSetsIsAlone: exports.PlayerSetsIsAlone.decode(reader, reader.uint32()),
                    };
                    break;
                case 81:
                    message.event = {
                        $case: "playerJoins",
                        playerJoins: exports.PlayerJoins.decode(reader, reader.uint32()),
                    };
                    break;
                case 82:
                    message.event = {
                        $case: "mapSetEnabledChats",
                        mapSetEnabledChats: exports.MapSetEnabledChats.decode(reader, reader.uint32()),
                    };
                    break;
                case 83:
                    message.event = {
                        $case: "mapSetDescription",
                        mapSetDescription: exports.MapSetDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 84:
                    message.event = {
                        $case: "mapSetDecoration",
                        mapSetDecoration: exports.MapSetDecoration.decode(reader, reader.uint32()),
                    };
                    break;
                case 85:
                    message.event = {
                        $case: "mapSetTutorialTasks",
                        mapSetTutorialTasks: exports.MapSetTutorialTasks.decode(reader, reader.uint32()),
                    };
                    break;
                case 86:
                    message.event = {
                        $case: "mapSetMiniMapImagePath",
                        mapSetMiniMapImagePath: exports.MapSetMiniMapImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 87:
                    message.event = {
                        $case: "spacePlaysSound",
                        spacePlaysSound: exports.SpacePlaysSound.decode(reader, reader.uint32()),
                    };
                    break;
                case 88:
                    message.event = {
                        $case: "mapSetScript",
                        mapSetScript: exports.MapSetScript.decode(reader, reader.uint32()),
                    };
                    break;
                case 90:
                    message.event = {
                        $case: "playerSetsIsMobile",
                        playerSetsIsMobile: exports.PlayerSetsIsMobile.decode(reader, reader.uint32()),
                    };
                    break;
                case 91:
                    message.event = {
                        $case: "setScreenPointerServer",
                        setScreenPointerServer: exports.SetScreenPointerServer.decode(reader, reader.uint32()),
                    };
                    break;
                case 92:
                    message.event = {
                        $case: "playerSetsEmoteV2",
                        playerSetsEmoteV2: exports.PlayerSetsEmoteV2.decode(reader, reader.uint32()),
                    };
                    break;
                case 93:
                    message.event = {
                        $case: "playerSetsFocusModeEndTime",
                        playerSetsFocusModeEndTime: exports.PlayerSetsFocusModeEndTime.decode(reader, reader.uint32()),
                    };
                    break;
                case 94:
                    message.event = {
                        $case: "spaceSetsSpaceMembers",
                        spaceSetsSpaceMembers: exports.SpaceSetsSpaceMembers.decode(reader, reader.uint32()),
                    };
                    break;
                case 95:
                    message.event = {
                        $case: "customEvent",
                        customEvent: exports.CustomEvent.decode(reader, reader.uint32()),
                    };
                    break;
                case 97:
                    message.event = {
                        $case: "playerBlocks",
                        playerBlocks: exports.PlayerBlocks.decode(reader, reader.uint32()),
                    };
                    break;
                case 98:
                    message.event = {
                        $case: "playerUpdatesFocusModeStatus",
                        playerUpdatesFocusModeStatus: exports.PlayerUpdatesFocusModeStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 99:
                    message.event = {
                        $case: "playerNotifies",
                        playerNotifies: exports.PlayerNotifies.decode(reader, reader.uint32()),
                    };
                    break;
                case 108:
                    message.event = {
                        $case: "playerSetsItemString",
                        playerSetsItemString: exports.PlayerSetsItemString.decode(reader, reader.uint32()),
                    };
                    break;
                case 109:
                    message.event = {
                        $case: "playerTriggersItem",
                        playerTriggersItem: exports.PlayerTriggersItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 110:
                    message.event = {
                        $case: "playerSetsFollowTarget",
                        playerSetsFollowTarget: exports.PlayerSetsFollowTarget.decode(reader, reader.uint32()),
                    };
                    break;
                case 111:
                    message.event = {
                        $case: "playerRequestsToLead",
                        playerRequestsToLead: exports.PlayerRequestsToLead.decode(reader, reader.uint32()),
                    };
                    break;
                case 112:
                    message.event = {
                        $case: "playerSetsManualVideoSrc",
                        playerSetsManualVideoSrc: exports.PlayerSetsManualVideoSrc.decode(reader, reader.uint32()),
                    };
                    break;
                case 113:
                    message.event = {
                        $case: "playerSetsIsNpc",
                        playerSetsIsNpc: exports.PlayerSetsIsNpc.decode(reader, reader.uint32()),
                    };
                    break;
                case 114:
                    message.event = {
                        $case: "playerSetsSubtitle",
                        playerSetsSubtitle: exports.PlayerSetsSubtitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 115:
                    message.event = {
                        $case: "mapCommitsChanges",
                        mapCommitsChanges: exports.MapCommitsChanges.decode(reader, reader.uint32()),
                    };
                    break;
                case 116:
                    message.event = {
                        $case: "playerUpdatesSession",
                        playerUpdatesSession: exports.PlayerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 117:
                    message.event = {
                        $case: "mapMoveObject",
                        mapMoveObject: exports.MapMoveObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 118:
                    message.event = {
                        $case: "playerEditsChatMessage",
                        playerEditsChatMessage: exports.PlayerEditsChatMessage.decode(reader, reader.uint32()),
                    };
                    break;
                case 119:
                    message.event = {
                        $case: "fxShakeObject",
                        fxShakeObject: exports.FXShakeObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 120:
                    message.event = {
                        $case: "fxShakeCamera",
                        fxShakeCamera: exports.FXShakeCamera.decode(reader, reader.uint32()),
                    };
                    break;
                case 121:
                    message.event = {
                        $case: "playerSendsCommand",
                        playerSendsCommand: exports.PlayerSendsCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 122:
                    message.event = {
                        $case: "spaceRegistersCommand",
                        spaceRegistersCommand: exports.SpaceRegistersCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 123:
                    message.event = {
                        $case: "speakerUpdatesSession",
                        speakerUpdatesSession: exports.SpeakerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 124:
                    message.event = {
                        $case: "playerUpdatesInventory",
                        playerUpdatesInventory: exports.PlayerUpdatesInventory.decode(reader, reader.uint32()),
                    };
                    break;
                case 125:
                    message.event = {
                        $case: "spaceUpdatesItems",
                        spaceUpdatesItems: exports.SpaceUpdatesItems.decode(reader, reader.uint32()),
                    };
                    break;
                case 126:
                    message.event = {
                        $case: "playerSetsVehicleId",
                        playerSetsVehicleId: exports.PlayerSetsVehicleId.decode(reader, reader.uint32()),
                    };
                    break;
                case 127:
                    message.event = {
                        $case: "playerSetsSpeedModifier",
                        playerSetsSpeedModifier: exports.PlayerSetsSpeedModifier.decode(reader, reader.uint32()),
                    };
                    break;
                case 128:
                    message.event = {
                        $case: "playerHighFives",
                        playerHighFives: exports.PlayerHighFives.decode(reader, reader.uint32()),
                    };
                    break;
                case 130:
                    message.event = {
                        $case: "spaceStopsSound",
                        spaceStopsSound: exports.SpaceStopsSound.decode(reader, reader.uint32()),
                    };
                    break;
                case 131:
                    message.event = {
                        $case: "hipToBeSquare",
                        hipToBeSquare: exports.HipToBeSquare.decode(reader, reader.uint32()),
                    };
                    break;
                case 132:
                    message.event = {
                        $case: "playerCrafts",
                        playerCrafts: exports.PlayerCrafts.decode(reader, reader.uint32()),
                    };
                    break;
                case 133:
                    message.event = {
                        $case: "playerTriggersInventoryItem",
                        playerTriggersInventoryItem: exports.PlayerTriggersInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 134:
                    message.event = {
                        $case: "playerSetsAllowScreenPointer",
                        playerSetsAllowScreenPointer: exports.PlayerSetsAllowScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 135:
                    message.event = {
                        $case: "precomputedEnterLocation",
                        precomputedEnterLocation: exports.PrecomputedEnterLocation.decode(reader, reader.uint32()),
                    };
                    break;
                case 136:
                    message.event = {
                        $case: "gotRequestMute",
                        gotRequestMute: exports.GotRequestMute.decode(reader, reader.uint32()),
                    };
                    break;
                case 137:
                    message.event = {
                        $case: "playerSetsDeskInfo",
                        playerSetsDeskInfo: exports.PlayerSetsDeskInfo.decode(reader, reader.uint32()),
                    };
                    break;
                case 138:
                    message.event = {
                        $case: "mapSetNooks",
                        mapSetNooks: exports.MapSetNooks.decode(reader, reader.uint32()),
                    };
                    break;
                case 139:
                    message.event = {
                        $case: "dynamicGates",
                        dynamicGates: exports.DynamicGates.decode(reader, reader.uint32()),
                    };
                    break;
                case 140:
                    message.event = {
                        $case: "playerWaves",
                        playerWaves: exports.PlayerWaves.decode(reader, reader.uint32()),
                    };
                    break;
                case 141:
                    message.event = {
                        $case: "playerSetsPronouns",
                        playerSetsPronouns: exports.PlayerSetsPronouns.decode(reader, reader.uint32()),
                    };
                    break;
                case 142:
                    message.event = {
                        $case: "playerSetsTitle",
                        playerSetsTitle: exports.PlayerSetsTitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 143:
                    message.event = {
                        $case: "playerSetsTimezone",
                        playerSetsTimezone: exports.PlayerSetsTimezone.decode(reader, reader.uint32()),
                    };
                    break;
                case 144:
                    message.event = {
                        $case: "playerSetsDescription",
                        playerSetsDescription: exports.PlayerSetsDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 145:
                    message.event = {
                        $case: "playerSetsPhone",
                        playerSetsPhone: exports.PlayerSetsPhone.decode(reader, reader.uint32()),
                    };
                    break;
                case 146:
                    message.event = {
                        $case: "playerSetsPersonalImageUrl",
                        playerSetsPersonalImageUrl: exports.PlayerSetsPersonalImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 147:
                    message.event = {
                        $case: "playerSetsProfileImageUrl",
                        playerSetsProfileImageUrl: exports.PlayerSetsProfileImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 148:
                    message.event = {
                        $case: "spaceSetsCapacity",
                        spaceSetsCapacity: exports.SpaceSetsCapacity.decode(reader, reader.uint32()),
                    };
                    break;
                case 149:
                    message.event = {
                        $case: "spaceOverCapacityDeniesUser",
                        spaceOverCapacityDeniesUser: exports.SpaceOverCapacityDeniesUser.decode(reader, reader.uint32()),
                    };
                    break;
                case 150:
                    message.event = {
                        $case: "playerSetsAway",
                        playerSetsAway: exports.PlayerSetsAway.decode(reader, reader.uint32()),
                    };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseServerHeartbeat = { lastRTT: 0 };
exports.ServerHeartbeat = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.lastRTT !== 0) {
            writer.uint32(8).uint32(message.lastRTT);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseServerHeartbeat);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.lastRTT = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInfo = { message: "" };
exports.Info = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWarn = { message: "" };
exports.Warn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWarn);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseErrorEvent = { message: "", code: 0 };
exports.ErrorEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        if (message.code !== 0) {
            writer.uint32(16).uint32(message.code);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseErrorEvent);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.message = reader.string();
                    break;
                case 2:
                    message.code = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseReady = { id: "" };
exports.Ready = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseReady);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTransactionStatus = { txnId: 0, succeeded: false };
exports.TransactionStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.txnId !== 0) {
            writer.uint32(8).uint32(message.txnId);
        }
        if (message.succeeded === true) {
            writer.uint32(16).bool(message.succeeded);
        }
        if (message.reason !== undefined) {
            writer.uint32(26).string(message.reason);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTransactionStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.txnId = reader.uint32();
                    break;
                case 2:
                    message.succeeded = reader.bool();
                    break;
                case 3:
                    message.reason = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerJoins = { encId: 0 };
exports.PlayerJoins = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerJoins);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseGotRequestMute = { muterId: "", video: false };
exports.GotRequestMute = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.muterId !== "") {
            writer.uint32(10).string(message.muterId);
        }
        if (message.video === true) {
            writer.uint32(16).bool(message.video);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGotRequestMute);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.muterId = reader.string();
                    break;
                case 2:
                    message.video = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerMoves = { encId: 0, lastInputId: 0 };
exports.PlayerMoves = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.x !== undefined) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== undefined) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.direction !== undefined) {
            writer.uint32(32).int32(message.direction);
        }
        if (message.mapId !== undefined) {
            writer.uint32(42).string(message.mapId);
        }
        if (message.lastInputId !== 0) {
            writer.uint32(48).uint32(message.lastInputId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerMoves);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.direction = reader.int32();
                    break;
                case 5:
                    message.mapId = reader.string();
                    break;
                case 6:
                    message.lastInputId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsStatus = { encId: 0, busy: false };
exports.PlayerSetsStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.busy === true) {
            writer.uint32(16).bool(message.busy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.busy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSpotlights = { encId: 0, spotlightedBy: 0, spotlighted: 0 };
exports.PlayerSpotlights = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(16).uint32(message.encId);
        }
        if (message.spotlightedBy !== 0) {
            writer.uint32(8).uint32(message.spotlightedBy);
        }
        if (message.spotlighted !== 0) {
            writer.uint32(24).uint32(message.spotlighted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSpotlights);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.encId = reader.uint32();
                    break;
                case 1:
                    message.spotlightedBy = reader.uint32();
                    break;
                case 3:
                    message.spotlighted = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerRings = { encId: 0 };
exports.PlayerRings = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerRings);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsImagePointer = { encId: 0, objectId: "", x: 0, y: 0 };
exports.PlayerSetsImagePointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.objectId !== "") {
            writer.uint32(18).string(message.objectId);
        }
        if (message.x !== 0) {
            writer.uint32(25).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(33).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsImagePointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.objectId = reader.string();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetScreenPointerServer = { encId: 0, screenId: "", x: 0, y: 0, color: "" };
exports.SetScreenPointerServer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.screenId !== "") {
            writer.uint32(18).string(message.screenId);
        }
        if (message.x !== 0) {
            writer.uint32(25).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(33).double(message.y);
        }
        if (message.color !== "") {
            writer.uint32(42).string(message.color);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetScreenPointerServer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.screenId = reader.string();
                    break;
                case 3:
                    message.x = reader.double();
                    break;
                case 4:
                    message.y = reader.double();
                    break;
                case 5:
                    message.color = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerChats = {
    senderId: "",
    recipient: "",
    contents: "",
    senderName: "",
    messageType: "",
    unixTime: 0,
};
exports.PlayerChats = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderId !== "") {
            writer.uint32(10).string(message.senderId);
        }
        if (message.recipient !== "") {
            writer.uint32(18).string(message.recipient);
        }
        if (message.contents !== "") {
            writer.uint32(26).string(message.contents);
        }
        if (message.senderName !== "") {
            writer.uint32(34).string(message.senderName);
        }
        if (message.timestamp !== undefined) {
            exports.Timestamp.encode(message.timestamp, writer.uint32(42).fork()).ldelim();
        }
        if (message.messageType !== "") {
            writer.uint32(50).string(message.messageType);
        }
        if (message.unixTime !== 0) {
            writer.uint32(57).double(message.unixTime);
        }
        if (message.id !== undefined) {
            writer.uint32(66).string(message.id);
        }
        if (message.roomId !== undefined) {
            writer.uint32(74).string(message.roomId);
        }
        if (message.approved !== undefined) {
            writer.uint32(80).bool(message.approved);
        }
        if (message.nookId !== undefined) {
            writer.uint32(90).string(message.nookId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerChats);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderId = reader.string();
                    break;
                case 2:
                    message.recipient = reader.string();
                    break;
                case 3:
                    message.contents = reader.string();
                    break;
                case 4:
                    message.senderName = reader.string();
                    break;
                case 5:
                    message.timestamp = exports.Timestamp.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.messageType = reader.string();
                    break;
                case 7:
                    message.unixTime = reader.double();
                    break;
                case 8:
                    message.id = reader.string();
                    break;
                case 9:
                    message.roomId = reader.string();
                    break;
                case 10:
                    message.approved = reader.bool();
                    break;
                case 11:
                    message.nookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerWaves = { encId: 0, targetId: "", isReply: false };
exports.PlayerWaves = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.targetId !== "") {
            writer.uint32(18).string(message.targetId);
        }
        if (message.isReply === true) {
            writer.uint32(24).bool(message.isReply);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerWaves);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.isReply = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTimestamp = { seconds: 0, nanoseconds: 0 };
exports.Timestamp = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.seconds !== 0) {
            writer.uint32(13).float(message.seconds);
        }
        if (message.nanoseconds !== 0) {
            writer.uint32(21).float(message.nanoseconds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTimestamp);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.seconds = reader.float();
                    break;
                case 2:
                    message.nanoseconds = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerInteracts = { encId: 0, objId: "" };
exports.PlayerInteracts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.objId !== "") {
            writer.uint32(18).string(message.objId);
        }
        if (message.mapId !== undefined) {
            writer.uint32(34).string(message.mapId);
        }
        if (message.dataJson !== undefined) {
            writer.uint32(26).string(message.dataJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerInteracts);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.objId = reader.string();
                    break;
                case 4:
                    message.mapId = reader.string();
                    break;
                case 3:
                    message.dataJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerGhosts = { encId: 0, ghost: 0 };
exports.PlayerGhosts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.ghost !== 0) {
            writer.uint32(16).uint32(message.ghost);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerGhosts);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.ghost = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerEntersWhisper = { encId: 0, whisperRecipient: "", whisperId: "" };
exports.PlayerEntersWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.whisperRecipient !== "") {
            writer.uint32(18).string(message.whisperRecipient);
        }
        if (message.whisperId !== "") {
            writer.uint32(26).string(message.whisperId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerEntersWhisper);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.whisperRecipient = reader.string();
                    break;
                case 3:
                    message.whisperId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerEntersWhisperV2 = { encId: 0, encIdTarget: 0, whisperId: "" };
exports.PlayerEntersWhisperV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.encIdTarget !== 0) {
            writer.uint32(16).uint32(message.encIdTarget);
        }
        if (message.whisperId !== "") {
            writer.uint32(26).string(message.whisperId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerEntersWhisperV2);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.encIdTarget = reader.uint32();
                    break;
                case 3:
                    message.whisperId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerLeavesWhisper = { encId: 0 };
exports.PlayerLeavesWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerLeavesWhisper);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerActivelySpeaks = { encId: 0, activelySpeaking: 0 };
exports.PlayerActivelySpeaks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.activelySpeaking !== 0) {
            writer.uint32(16).uint32(message.activelySpeaking);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerActivelySpeaks);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.activelySpeaking = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsEmoteV2 = { encId: 0 };
exports.PlayerSetsEmoteV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.emote !== undefined) {
            writer.uint32(18).string(message.emote);
        }
        if (message.count !== undefined) {
            writer.uint32(24).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsEmoteV2);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.emote = reader.string();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsWorkCondition = { encId: 0, workCondition: 0 };
exports.PlayerSetsWorkCondition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.workCondition !== 0) {
            writer.uint32(16).uint32(message.workCondition);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsWorkCondition);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.workCondition = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsLastActive = { encId: 0, lastActive: "" };
exports.PlayerSetsLastActive = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.lastActive !== "") {
            writer.uint32(18).string(message.lastActive);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsLastActive);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.lastActive = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsName = { encId: 0, name: "" };
exports.PlayerSetsName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsName);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsTextStatus = { encId: 0, textStatus: "" };
exports.PlayerSetsTextStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.textStatus !== "") {
            writer.uint32(18).string(message.textStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsTextStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.textStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsPronouns = { encId: 0, pronouns: "" };
exports.PlayerSetsPronouns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.pronouns !== "") {
            writer.uint32(18).string(message.pronouns);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsPronouns);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.pronouns = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsTitle = { encId: 0, title: "" };
exports.PlayerSetsTitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.title !== "") {
            writer.uint32(18).string(message.title);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsTitle);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.title = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsTimezone = { encId: 0, timezone: "" };
exports.PlayerSetsTimezone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.timezone !== "") {
            writer.uint32(18).string(message.timezone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsTimezone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.timezone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsPhone = { encId: 0, phone: "" };
exports.PlayerSetsPhone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.phone !== "") {
            writer.uint32(18).string(message.phone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsPhone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.phone = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsDescription = { encId: 0, description: "" };
exports.PlayerSetsDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsDescription);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.description = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsProfileImageUrl = { encId: 0, profileImageUrl: "" };
exports.PlayerSetsProfileImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.profileImageUrl !== "") {
            writer.uint32(18).string(message.profileImageUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsProfileImageUrl);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.profileImageUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsPersonalImageUrl = { encId: 0, personalImageUrl: "" };
exports.PlayerSetsPersonalImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.personalImageUrl !== "") {
            writer.uint32(18).string(message.personalImageUrl);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsPersonalImageUrl);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.personalImageUrl = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsIsMobile = { encId: 0, isMobile: false };
exports.PlayerSetsIsMobile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isMobile === true) {
            writer.uint32(16).bool(message.isMobile);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsIsMobile);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isMobile = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsEmojiStatus = { encId: 0, emojiStatus: "" };
exports.PlayerSetsEmojiStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.emojiStatus !== "") {
            writer.uint32(18).string(message.emojiStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsEmojiStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.emojiStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsAffiliation = { encId: 0, affiliation: "" };
exports.PlayerSetsAffiliation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.affiliation !== "") {
            writer.uint32(18).string(message.affiliation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsAffiliation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.affiliation = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerExits = { encId: 0 };
exports.PlayerExits = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerExits);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsOutfitString = { encId: 0, outfitString: "" };
exports.PlayerSetsOutfitString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.outfitString !== "") {
            writer.uint32(18).string(message.outfitString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsOutfitString);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.outfitString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsIsSignedIn = { encId: 0, isSignedIn: false };
exports.PlayerSetsIsSignedIn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isSignedIn === true) {
            writer.uint32(16).bool(message.isSignedIn);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsIsSignedIn);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isSignedIn = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRespawnComplete = {};
exports.RespawnComplete = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRespawnComplete);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceOverwrites = { spaceData: "" };
exports.SpaceOverwrites = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spaceData !== "") {
            writer.uint32(10).string(message.spaceData);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceOverwrites);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceData = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDynamicGate = { exposure: 0, spaces: "" };
exports.DynamicGate = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exposure !== 0) {
            writer.uint32(13).float(message.exposure);
        }
        for (const v of message.spaces) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDynamicGate);
        message.spaces = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exposure = reader.float();
                    break;
                case 2:
                    message.spaces.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseDynamicGates = {};
exports.DynamicGates = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.livekitEnabled !== undefined) {
            exports.DynamicGate.encode(message.livekitEnabled, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseDynamicGates);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.livekitEnabled = exports.DynamicGate.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceSetsSpaceMembers = {};
exports.SpaceSetsSpaceMembers = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.members).forEach(([key, value]) => {
            exports.SpaceSetsSpaceMembers_MembersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceSetsSpaceMembers);
        message.members = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceSetsSpaceMembers_MembersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.members[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceSetsSpaceMembers_MembersEntry = { key: "" };
exports.SpaceSetsSpaceMembers_MembersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SpaceMemberInfo.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceSetsSpaceMembers_MembersEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SpaceMemberInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceIsClosed = {};
exports.SpaceIsClosed = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceIsClosed);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerEntersPortal = { targetUrl: "" };
exports.PlayerEntersPortal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetUrl !== "") {
            writer.uint32(10).string(message.targetUrl);
        }
        if (message.bypassPrompt !== undefined) {
            writer.uint32(16).bool(message.bypassPrompt);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerEntersPortal);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetUrl = reader.string();
                    break;
                case 2:
                    message.bypassPrompt = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseCookieFound = { encId: 0 };
exports.CookieFound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCookieFound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceSetsIdMapping = { uid: "", encId: 0 };
exports.SpaceSetsIdMapping = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.uid !== "") {
            writer.uint32(10).string(message.uid);
        }
        if (message.encId !== 0) {
            writer.uint32(16).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceSetsIdMapping);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.uid = reader.string();
                    break;
                case 2:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerShootsConfetti = { encId: 0 };
exports.PlayerShootsConfetti = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerShootsConfetti);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsEventStatus = { encId: 0, eventStatus: "" };
exports.PlayerSetsEventStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.eventStatus !== "") {
            writer.uint32(18).string(message.eventStatus);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsEventStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.eventStatus = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsInConversation = { encId: 0, inConversation: false };
exports.PlayerSetsInConversation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.inConversation === true) {
            writer.uint32(16).bool(message.inConversation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsInConversation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.inConversation = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsCurrentDesk = { encId: 0, currentDesk: "" };
exports.PlayerSetsCurrentDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.currentDesk !== "") {
            writer.uint32(18).string(message.currentDesk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsCurrentDesk);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.currentDesk = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsCurrentArea = { encId: 0, currentArea: "" };
exports.PlayerSetsCurrentArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.currentArea !== "") {
            writer.uint32(18).string(message.currentArea);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsCurrentArea);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.currentArea = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsGoKartId = { encId: 0, goKartId: "" };
exports.PlayerSetsGoKartId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.goKartId !== "") {
            writer.uint32(18).string(message.goKartId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsGoKartId);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.goKartId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsVehicleId = {
    encId: 0,
    vehicleId: "",
    action: "",
    previousVehicleId: "",
};
exports.PlayerSetsVehicleId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.vehicleId !== "") {
            writer.uint32(18).string(message.vehicleId);
        }
        if (message.action !== "") {
            writer.uint32(26).string(message.action);
        }
        if (message.previousVehicleId !== "") {
            writer.uint32(34).string(message.previousVehicleId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsVehicleId);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.vehicleId = reader.string();
                    break;
                case 3:
                    message.action = reader.string();
                    break;
                case 4:
                    message.previousVehicleId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsSpeedModifier = { encId: 0, speedModifier: 0 };
exports.PlayerSetsSpeedModifier = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.speedModifier !== 0) {
            writer.uint32(21).float(message.speedModifier);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsSpeedModifier);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.speedModifier = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsIsAlone = { encId: 0, isAlone: false };
exports.PlayerSetsIsAlone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isAlone === true) {
            writer.uint32(16).bool(message.isAlone);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsIsAlone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isAlone = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpacePlaysSound = { src: "", volume: 0 };
exports.SpacePlaysSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(18).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(29).float(message.volume);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpacePlaysSound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.src = reader.string();
                    break;
                case 3:
                    message.volume = reader.float();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceStopsSound = { src: "" };
exports.SpaceStopsSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(18).string(message.src);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceStopsSound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.src = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsFocusModeEndTime = { encId: 0, focusModeEndTime: "" };
exports.PlayerSetsFocusModeEndTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.focusModeEndTime !== "") {
            writer.uint32(18).string(message.focusModeEndTime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsFocusModeEndTime);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.focusModeEndTime = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerBlocks = { blockedBy: "", blocked: false };
exports.PlayerBlocks = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockedBy !== "") {
            writer.uint32(10).string(message.blockedBy);
        }
        if (message.blocked === true) {
            writer.uint32(16).bool(message.blocked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerBlocks);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockedBy = reader.string();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseCustomEvent = { name: "", payload: "" };
exports.CustomEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.payload !== "") {
            writer.uint32(18).string(message.payload);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCustomEvent);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.payload = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerUpdatesFocusModeStatus = { encId: 0, isInFocusMode: false };
exports.PlayerUpdatesFocusModeStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isInFocusMode === true) {
            writer.uint32(16).bool(message.isInFocusMode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerUpdatesFocusModeStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isInFocusMode = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsItemString = { encId: 0, itemString: "" };
exports.PlayerSetsItemString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.itemString !== "") {
            writer.uint32(18).string(message.itemString);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsItemString);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.itemString = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerTriggersItem = { encId: 0 };
exports.PlayerTriggersItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.closestObject !== undefined) {
            writer.uint32(18).string(message.closestObject);
        }
        if (message.closestObjectTemplate !== undefined) {
            writer.uint32(26).string(message.closestObjectTemplate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerTriggersItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.closestObject = reader.string();
                    break;
                case 3:
                    message.closestObjectTemplate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerNotifies = { encId: 0, notification: "" };
exports.PlayerNotifies = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.notification !== "") {
            writer.uint32(18).string(message.notification);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerNotifies);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.notification = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsFollowTarget = { encId: 0, followTarget: "" };
exports.PlayerSetsFollowTarget = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.followTarget !== "") {
            writer.uint32(18).string(message.followTarget);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsFollowTarget);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.followTarget = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerRequestsToLead = { encId: 0, snapshot: "" };
exports.PlayerRequestsToLead = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.snapshot !== "") {
            writer.uint32(18).string(message.snapshot);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerRequestsToLead);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.snapshot = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsManualVideoSrc = { encId: 0, manualVideoSrc: "" };
exports.PlayerSetsManualVideoSrc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.manualVideoSrc !== "") {
            writer.uint32(18).string(message.manualVideoSrc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsManualVideoSrc);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.manualVideoSrc = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsIsNpc = { encId: 0, isNpc: false };
exports.PlayerSetsIsNpc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.isNpc === true) {
            writer.uint32(16).bool(message.isNpc);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsIsNpc);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.isNpc = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsSubtitle = { encId: 0, subtitle: "" };
exports.PlayerSetsSubtitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.subtitle !== "") {
            writer.uint32(18).string(message.subtitle);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsSubtitle);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.subtitle = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerCrafts = { encId: 0 };
exports.PlayerCrafts = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        Object.entries(message.inputs).forEach(([key, value]) => {
            exports.PlayerCrafts_InputsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerCrafts);
        message.inputs = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    const entry2 = exports.PlayerCrafts_InputsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.inputs[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerCrafts_InputsEntry = { key: "", value: 0 };
exports.PlayerCrafts_InputsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerCrafts_InputsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapMoveObject = { mapId: "", objectId: "", targetX: 0, targetY: 0, duration: 0 };
exports.MapMoveObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.objectId !== "") {
            writer.uint32(18).string(message.objectId);
        }
        if (message.targetX !== 0) {
            writer.uint32(29).float(message.targetX);
        }
        if (message.targetY !== 0) {
            writer.uint32(37).float(message.targetY);
        }
        if (message.targetXOffset !== undefined) {
            writer.uint32(45).float(message.targetXOffset);
        }
        if (message.targetYOffset !== undefined) {
            writer.uint32(53).float(message.targetYOffset);
        }
        if (message.duration !== 0) {
            writer.uint32(61).float(message.duration);
        }
        if (message.easing !== undefined) {
            writer.uint32(66).string(message.easing);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapMoveObject);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.objectId = reader.string();
                    break;
                case 3:
                    message.targetX = reader.float();
                    break;
                case 4:
                    message.targetY = reader.float();
                    break;
                case 5:
                    message.targetXOffset = reader.float();
                    break;
                case 6:
                    message.targetYOffset = reader.float();
                    break;
                case 7:
                    message.duration = reader.float();
                    break;
                case 8:
                    message.easing = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerEditsChatMessage = { id: "" };
exports.PlayerEditsChatMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        if (message.likes !== undefined) {
            writer.uint32(16).uint32(message.likes);
        }
        if (message.replied !== undefined) {
            writer.uint32(24).bool(message.replied);
        }
        if (message.reply !== undefined) {
            exports.ChatReply.encode(message.reply, writer.uint32(34).fork()).ldelim();
        }
        if (message.approved !== undefined) {
            writer.uint32(40).bool(message.approved);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerEditsChatMessage);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.likes = reader.uint32();
                    break;
                case 3:
                    message.replied = reader.bool();
                    break;
                case 4:
                    message.reply = exports.ChatReply.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.approved = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseFXShakeObject = { mapId: "", targetId: "" };
exports.FXShakeObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.targetId !== "") {
            writer.uint32(18).string(message.targetId);
        }
        if (message.intensity !== undefined) {
            writer.uint32(29).float(message.intensity);
        }
        if (message.durationMs !== undefined) {
            writer.uint32(37).float(message.durationMs);
        }
        if (message.mode !== undefined) {
            writer.uint32(40).uint32(message.mode);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFXShakeObject);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.intensity = reader.float();
                    break;
                case 4:
                    message.durationMs = reader.float();
                    break;
                case 5:
                    message.mode = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseFXShakeCamera = {};
exports.FXShakeCamera = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.intensity !== undefined) {
            writer.uint32(13).float(message.intensity);
        }
        if (message.durationMs !== undefined) {
            writer.uint32(21).float(message.durationMs);
        }
        if (message.mapId !== undefined) {
            writer.uint32(26).string(message.mapId);
        }
        if (message.targetUserId !== undefined) {
            writer.uint32(34).string(message.targetUserId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFXShakeCamera);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.intensity = reader.float();
                    break;
                case 2:
                    message.durationMs = reader.float();
                    break;
                case 3:
                    message.mapId = reader.string();
                    break;
                case 4:
                    message.targetUserId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerHighFives = { encId: 0, encIdTarget: 0 };
exports.PlayerHighFives = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.encIdTarget !== 0) {
            writer.uint32(16).uint32(message.encIdTarget);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerHighFives);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.encIdTarget = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSendsCommand = { encId: 0, command: "" };
exports.PlayerSendsCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.command !== "") {
            writer.uint32(18).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSendsCommand);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceRegistersCommand = { command: "" };
exports.SpaceRegistersCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(18).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceRegistersCommand);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerUpdatesInventory = { encId: 0 };
exports.PlayerUpdatesInventory = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        Object.entries(message.items).forEach(([key, value]) => {
            exports.PlayerUpdatesInventory_ItemsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        Object.entries(message.order).forEach(([key, value]) => {
            exports.PlayerUpdatesInventory_OrderEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerUpdatesInventory);
        message.items = {};
        message.order = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    const entry2 = exports.PlayerUpdatesInventory_ItemsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.items[entry2.key] = entry2.value;
                    }
                    break;
                case 3:
                    const entry3 = exports.PlayerUpdatesInventory_OrderEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.order[entry3.key] = entry3.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerUpdatesInventory_ItemsEntry = { key: "" };
exports.PlayerUpdatesInventory_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.InventoryItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerUpdatesInventory_ItemsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.InventoryItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerUpdatesInventory_OrderEntry = { key: "", value: "" };
exports.PlayerUpdatesInventory_OrderEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerUpdatesInventory_OrderEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceUpdatesItems = {};
exports.SpaceUpdatesItems = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.items).forEach(([key, value]) => {
            exports.SpaceUpdatesItems_ItemsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceUpdatesItems);
        message.items = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.SpaceUpdatesItems_ItemsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.items[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceUpdatesItems_ItemsEntry = { key: "" };
exports.SpaceUpdatesItems_ItemsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            exports.SpaceItem.encode(message.value, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceUpdatesItems_ItemsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = exports.SpaceItem.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerTriggersInventoryItem = { encId: 0, itemId: "", abilityId: "" };
exports.PlayerTriggersInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.itemId !== "") {
            writer.uint32(18).string(message.itemId);
        }
        if (message.abilityId !== "") {
            writer.uint32(26).string(message.abilityId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerTriggersInventoryItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.itemId = reader.string();
                    break;
                case 3:
                    message.abilityId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsAllowScreenPointer = { encId: 0, allowScreenPointer: false };
exports.PlayerSetsAllowScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.allowScreenPointer === true) {
            writer.uint32(16).bool(message.allowScreenPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsAllowScreenPointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.allowScreenPointer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePrecomputedEnterLocation = {};
exports.PrecomputedEnterLocation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enterLocation !== undefined) {
            exports.MapLocation.encode(message.enterLocation, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePrecomputedEnterLocation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enterLocation = exports.MapLocation.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsDeskInfo = { encId: 0 };
exports.PlayerSetsDeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.deskInfo !== undefined) {
            exports.DeskInfoV2.encode(message.deskInfo, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsDeskInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.deskInfo = exports.DeskInfoV2.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceSetsCapacity = { capacity: 0 };
exports.SpaceSetsCapacity = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.capacity !== 0) {
            writer.uint32(8).uint32(message.capacity);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceSetsCapacity);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.capacity = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpaceOverCapacityDeniesUser = { userId: "" };
exports.SpaceOverCapacityDeniesUser = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.userId !== "") {
            writer.uint32(10).string(message.userId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpaceOverCapacityDeniesUser);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.userId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerSetsAway = { encId: 0, away: false };
exports.PlayerSetsAway = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.encId !== 0) {
            writer.uint32(8).uint32(message.encId);
        }
        if (message.away === true) {
            writer.uint32(16).bool(message.away);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerSetsAway);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.encId = reader.uint32();
                    break;
                case 2:
                    message.away = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseClientServerBatch = {};
exports.ClientServerBatch = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.actions) {
            exports.ClientServerAction.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientServerBatch);
        message.actions = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actions.push(exports.ClientServerAction.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseClientServerAction = {};
exports.ClientServerAction = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, _56, _57, _58, _59, _60, _61, _62, _63, _64, _65, _66, _67, _68, _69, _70, _71, _72, _73, _74, _75, _76, _77, _78, _79, _80, _81, _82, _83, _84, _85, _86, _87;
        if (message.txnId !== undefined) {
            writer.uint32(800).uint32(message.txnId);
        }
        if (((_a = message.action) === null || _a === void 0 ? void 0 : _a.$case) === "clientHeartbeat") {
            exports.ClientHeartbeat.encode(message.action.clientHeartbeat, writer.uint32(10).fork()).ldelim();
        }
        if (((_b = message.action) === null || _b === void 0 ? void 0 : _b.$case) === "clientBackupHeartbeat") {
            exports.ClientBackupHeartbeat.encode(message.action.clientBackupHeartbeat, writer.uint32(18).fork()).ldelim();
        }
        if (((_c = message.action) === null || _c === void 0 ? void 0 : _c.$case) === "updateSubscriptions") {
            exports.UpdateSubscriptions.encode(message.action.updateSubscriptions, writer.uint32(26).fork()).ldelim();
        }
        if (((_d = message.action) === null || _d === void 0 ? void 0 : _d.$case) === "move") {
            exports.Move.encode(message.action.move, writer.uint32(42).fork()).ldelim();
        }
        if (((_e = message.action) === null || _e === void 0 ? void 0 : _e.$case) === "setAffiliation") {
            exports.SetAffiliation.encode(message.action.setAffiliation, writer.uint32(58).fork()).ldelim();
        }
        if (((_f = message.action) === null || _f === void 0 ? void 0 : _f.$case) === "setStatus") {
            exports.SetStatus.encode(message.action.setStatus, writer.uint32(66).fork()).ldelim();
        }
        if (((_g = message.action) === null || _g === void 0 ? void 0 : _g.$case) === "spotlight") {
            exports.Spotlight.encode(message.action.spotlight, writer.uint32(74).fork()).ldelim();
        }
        if (((_h = message.action) === null || _h === void 0 ? void 0 : _h.$case) === "ring") {
            exports.Ring.encode(message.action.ring, writer.uint32(82).fork()).ldelim();
        }
        if (((_j = message.action) === null || _j === void 0 ? void 0 : _j.$case) === "ban") {
            exports.Ban.encode(message.action.ban, writer.uint32(98).fork()).ldelim();
        }
        if (((_k = message.action) === null || _k === void 0 ? void 0 : _k.$case) === "kick") {
            exports.Kick.encode(message.action.kick, writer.uint32(106).fork()).ldelim();
        }
        if (((_l = message.action) === null || _l === void 0 ? void 0 : _l.$case) === "setImpassable") {
            exports.SetImpassable.encode(message.action.setImpassable, writer.uint32(114).fork()).ldelim();
        }
        if (((_m = message.action) === null || _m === void 0 ? void 0 : _m.$case) === "chat") {
            exports.Chat.encode(message.action.chat, writer.uint32(122).fork()).ldelim();
        }
        if (((_o = message.action) === null || _o === void 0 ? void 0 : _o.$case) === "interact") {
            exports.Interact.encode(message.action.interact, writer.uint32(146).fork()).ldelim();
        }
        if (((_p = message.action) === null || _p === void 0 ? void 0 : _p.$case) === "enterWhisper") {
            exports.EnterWhisper.encode(message.action.enterWhisper, writer.uint32(154).fork()).ldelim();
        }
        if (((_q = message.action) === null || _q === void 0 ? void 0 : _q.$case) === "leaveWhisper") {
            exports.LeaveWhisper.encode(message.action.leaveWhisper, writer.uint32(162).fork()).ldelim();
        }
        if (((_r = message.action) === null || _r === void 0 ? void 0 : _r.$case) === "setEmojiStatus") {
            exports.SetEmojiStatus.encode(message.action.setEmojiStatus, writer.uint32(170).fork()).ldelim();
        }
        if (((_s = message.action) === null || _s === void 0 ? void 0 : _s.$case) === "activelySpeaking") {
            exports.ActivelySpeaking.encode(message.action.activelySpeaking, writer.uint32(178).fork()).ldelim();
        }
        if (((_t = message.action) === null || _t === void 0 ? void 0 : _t.$case) === "setName") {
            exports.SetName.encode(message.action.setName, writer.uint32(194).fork()).ldelim();
        }
        if (((_u = message.action) === null || _u === void 0 ? void 0 : _u.$case) === "setTextStatus") {
            exports.SetTextStatus.encode(message.action.setTextStatus, writer.uint32(202).fork()).ldelim();
        }
        if (((_v = message.action) === null || _v === void 0 ? void 0 : _v.$case) === "teleport") {
            exports.Teleport.encode(message.action.teleport, writer.uint32(210).fork()).ldelim();
        }
        if (((_w = message.action) === null || _w === void 0 ? void 0 : _w.$case) === "exit") {
            exports.Exit.encode(message.action.exit, writer.uint32(218).fork()).ldelim();
        }
        if (((_x = message.action) === null || _x === void 0 ? void 0 : _x.$case) === "enter") {
            exports.Enter.encode(message.action.enter, writer.uint32(226).fork()).ldelim();
        }
        if (((_y = message.action) === null || _y === void 0 ? void 0 : _y.$case) === "setWorkCondition") {
            exports.SetWorkCondition.encode(message.action.setWorkCondition, writer.uint32(234).fork()).ldelim();
        }
        if (((_z = message.action) === null || _z === void 0 ? void 0 : _z.$case) === "respawn") {
            exports.Respawn.encode(message.action.respawn, writer.uint32(242).fork()).ldelim();
        }
        if (((_0 = message.action) === null || _0 === void 0 ? void 0 : _0.$case) === "spawn") {
            exports.Spawn.encode(message.action.spawn, writer.uint32(250).fork()).ldelim();
        }
        if (((_1 = message.action) === null || _1 === void 0 ? void 0 : _1.$case) === "ghost") {
            exports.Ghost.encode(message.action.ghost, writer.uint32(258).fork()).ldelim();
        }
        if (((_2 = message.action) === null || _2 === void 0 ? void 0 : _2.$case) === "init") {
            exports.Init.encode(message.action.init, writer.uint32(266).fork()).ldelim();
        }
        if (((_3 = message.action) === null || _3 === void 0 ? void 0 : _3.$case) === "setOutfitString") {
            exports.SetOutfitString.encode(message.action.setOutfitString, writer.uint32(274).fork()).ldelim();
        }
        if (((_4 = message.action) === null || _4 === void 0 ? void 0 : _4.$case) === "shootConfetti") {
            exports.ShootConfetti.encode(message.action.shootConfetti, writer.uint32(290).fork()).ldelim();
        }
        if (((_5 = message.action) === null || _5 === void 0 ? void 0 : _5.$case) === "setEventStatus") {
            exports.SetEventStatus.encode(message.action.setEventStatus, writer.uint32(298).fork()).ldelim();
        }
        if (((_6 = message.action) === null || _6 === void 0 ? void 0 : _6.$case) === "setInConversation") {
            exports.SetInConversation.encode(message.action.setInConversation, writer.uint32(306).fork()).ldelim();
        }
        if (((_7 = message.action) === null || _7 === void 0 ? void 0 : _7.$case) === "setCurrentDesk") {
            exports.SetCurrentDesk.encode(message.action.setCurrentDesk, writer.uint32(314).fork()).ldelim();
        }
        if (((_8 = message.action) === null || _8 === void 0 ? void 0 : _8.$case) === "setCurrentArea") {
            exports.SetCurrentArea.encode(message.action.setCurrentArea, writer.uint32(322).fork()).ldelim();
        }
        if (((_9 = message.action) === null || _9 === void 0 ? void 0 : _9.$case) === "setImagePointer") {
            exports.SetImagePointer.encode(message.action.setImagePointer, writer.uint32(330).fork()).ldelim();
        }
        if (((_10 = message.action) === null || _10 === void 0 ? void 0 : _10.$case) === "setGoKartId") {
            exports.SetGoKartId.encode(message.action.setGoKartId, writer.uint32(338).fork()).ldelim();
        }
        if (((_11 = message.action) === null || _11 === void 0 ? void 0 : _11.$case) === "mapSetDimensions") {
            exports.MapSetDimensions.encode(message.action.mapSetDimensions, writer.uint32(346).fork()).ldelim();
        }
        if (((_12 = message.action) === null || _12 === void 0 ? void 0 : _12.$case) === "mapSetCollisions") {
            exports.MapSetCollisions.encode(message.action.mapSetCollisions, writer.uint32(354).fork()).ldelim();
        }
        if (((_13 = message.action) === null || _13 === void 0 ? void 0 : _13.$case) === "mapSetBackgroundImagePath") {
            exports.MapSetBackgroundImagePath.encode(message.action.mapSetBackgroundImagePath, writer.uint32(362).fork()).ldelim();
        }
        if (((_14 = message.action) === null || _14 === void 0 ? void 0 : _14.$case) === "mapSetForegroundImagePath") {
            exports.MapSetForegroundImagePath.encode(message.action.mapSetForegroundImagePath, writer.uint32(370).fork()).ldelim();
        }
        if (((_15 = message.action) === null || _15 === void 0 ? void 0 : _15.$case) === "mapSetSprites") {
            exports.MapSetSprites.encode(message.action.mapSetSprites, writer.uint32(378).fork()).ldelim();
        }
        if (((_16 = message.action) === null || _16 === void 0 ? void 0 : _16.$case) === "mapSetSpawns") {
            exports.MapSetSpawns.encode(message.action.mapSetSpawns, writer.uint32(386).fork()).ldelim();
        }
        if (((_17 = message.action) === null || _17 === void 0 ? void 0 : _17.$case) === "mapSetSpaces") {
            exports.MapSetSpaces.encode(message.action.mapSetSpaces, writer.uint32(394).fork()).ldelim();
        }
        if (((_18 = message.action) === null || _18 === void 0 ? void 0 : _18.$case) === "mapSetPortals") {
            exports.MapSetPortals.encode(message.action.mapSetPortals, writer.uint32(402).fork()).ldelim();
        }
        if (((_19 = message.action) === null || _19 === void 0 ? void 0 : _19.$case) === "mapSetAnnouncer") {
            exports.MapSetAnnouncer.encode(message.action.mapSetAnnouncer, writer.uint32(410).fork()).ldelim();
        }
        if (((_20 = message.action) === null || _20 === void 0 ? void 0 : _20.$case) === "mapSetAssets") {
            exports.MapSetAssets.encode(message.action.mapSetAssets, writer.uint32(434).fork()).ldelim();
        }
        if (((_21 = message.action) === null || _21 === void 0 ? void 0 : _21.$case) === "mapSetObjects") {
            exports.MapSetObjects.encode(message.action.mapSetObjects, writer.uint32(442).fork()).ldelim();
        }
        if (((_22 = message.action) === null || _22 === void 0 ? void 0 : _22.$case) === "mapSetName") {
            exports.MapSetName.encode(message.action.mapSetName, writer.uint32(450).fork()).ldelim();
        }
        if (((_23 = message.action) === null || _23 === void 0 ? void 0 : _23.$case) === "mapSetMuteOnEntry") {
            exports.MapSetMuteOnEntry.encode(message.action.mapSetMuteOnEntry, writer.uint32(466).fork()).ldelim();
        }
        if (((_24 = message.action) === null || _24 === void 0 ? void 0 : _24.$case) === "mapSetUseDrawnBG") {
            exports.MapSetUseDrawnBG.encode(message.action.mapSetUseDrawnBG, writer.uint32(474).fork()).ldelim();
        }
        if (((_25 = message.action) === null || _25 === void 0 ? void 0 : _25.$case) === "mapSetWalls") {
            exports.MapSetWalls.encode(message.action.mapSetWalls, writer.uint32(482).fork()).ldelim();
        }
        if (((_26 = message.action) === null || _26 === void 0 ? void 0 : _26.$case) === "mapSetFloors") {
            exports.MapSetFloors.encode(message.action.mapSetFloors, writer.uint32(490).fork()).ldelim();
        }
        if (((_27 = message.action) === null || _27 === void 0 ? void 0 : _27.$case) === "mapSetAreas") {
            exports.MapSetAreas.encode(message.action.mapSetAreas, writer.uint32(498).fork()).ldelim();
        }
        if (((_28 = message.action) === null || _28 === void 0 ? void 0 : _28.$case) === "mapAddObject") {
            exports.MapAddObject.encode(message.action.mapAddObject, writer.uint32(506).fork()).ldelim();
        }
        if (((_29 = message.action) === null || _29 === void 0 ? void 0 : _29.$case) === "mapDeleteObject") {
            exports.MapDeleteObject.encode(message.action.mapDeleteObject, writer.uint32(514).fork()).ldelim();
        }
        if (((_30 = message.action) === null || _30 === void 0 ? void 0 : _30.$case) === "mapSetSpawn") {
            exports.MapSetSpawn.encode(message.action.mapSetSpawn, writer.uint32(522).fork()).ldelim();
        }
        if (((_31 = message.action) === null || _31 === void 0 ? void 0 : _31.$case) === "setIsAlone") {
            exports.SetIsAlone.encode(message.action.setIsAlone, writer.uint32(530).fork()).ldelim();
        }
        if (((_32 = message.action) === null || _32 === void 0 ? void 0 : _32.$case) === "mapSetMiniMapImagePath") {
            exports.MapSetMiniMapImagePath.encode(message.action.mapSetMiniMapImagePath, writer.uint32(538).fork()).ldelim();
        }
        if (((_33 = message.action) === null || _33 === void 0 ? void 0 : _33.$case) === "mapSetEnabledChats") {
            exports.MapSetEnabledChats.encode(message.action.mapSetEnabledChats, writer.uint32(546).fork()).ldelim();
        }
        if (((_34 = message.action) === null || _34 === void 0 ? void 0 : _34.$case) === "mapSetDescription") {
            exports.MapSetDescription.encode(message.action.mapSetDescription, writer.uint32(554).fork()).ldelim();
        }
        if (((_35 = message.action) === null || _35 === void 0 ? void 0 : _35.$case) === "mapSetDecoration") {
            exports.MapSetDecoration.encode(message.action.mapSetDecoration, writer.uint32(562).fork()).ldelim();
        }
        if (((_36 = message.action) === null || _36 === void 0 ? void 0 : _36.$case) === "mapSetTutorialTasks") {
            exports.MapSetTutorialTasks.encode(message.action.mapSetTutorialTasks, writer.uint32(570).fork()).ldelim();
        }
        if (((_37 = message.action) === null || _37 === void 0 ? void 0 : _37.$case) === "playSound") {
            exports.PlaySound.encode(message.action.playSound, writer.uint32(578).fork()).ldelim();
        }
        if (((_38 = message.action) === null || _38 === void 0 ? void 0 : _38.$case) === "mapSetScript") {
            exports.MapSetScript.encode(message.action.mapSetScript, writer.uint32(586).fork()).ldelim();
        }
        if (((_39 = message.action) === null || _39 === void 0 ? void 0 : _39.$case) === "setIsMobile") {
            exports.SetIsMobile.encode(message.action.setIsMobile, writer.uint32(602).fork()).ldelim();
        }
        if (((_40 = message.action) === null || _40 === void 0 ? void 0 : _40.$case) === "setScreenPointer") {
            exports.SetScreenPointer.encode(message.action.setScreenPointer, writer.uint32(610).fork()).ldelim();
        }
        if (((_41 = message.action) === null || _41 === void 0 ? void 0 : _41.$case) === "setEmoteV2") {
            exports.SetEmoteV2.encode(message.action.setEmoteV2, writer.uint32(618).fork()).ldelim();
        }
        if (((_42 = message.action) === null || _42 === void 0 ? void 0 : _42.$case) === "setFocusModeEndTime") {
            exports.SetFocusModeEndTime.encode(message.action.setFocusModeEndTime, writer.uint32(626).fork()).ldelim();
        }
        if (((_43 = message.action) === null || _43 === void 0 ? void 0 : _43.$case) === "mapDeleteObjectById") {
            exports.MapDeleteObjectById.encode(message.action.mapDeleteObjectById, writer.uint32(634).fork()).ldelim();
        }
        if (((_44 = message.action) === null || _44 === void 0 ? void 0 : _44.$case) === "customAction") {
            exports.CustomAction.encode(message.action.customAction, writer.uint32(642).fork()).ldelim();
        }
        if (((_45 = message.action) === null || _45 === void 0 ? void 0 : _45.$case) === "block") {
            exports.Block.encode(message.action.block, writer.uint32(658).fork()).ldelim();
        }
        if (((_46 = message.action) === null || _46 === void 0 ? void 0 : _46.$case) === "setItemString") {
            exports.SetItemString.encode(message.action.setItemString, writer.uint32(666).fork()).ldelim();
        }
        if (((_47 = message.action) === null || _47 === void 0 ? void 0 : _47.$case) === "triggerItem") {
            exports.TriggerItem.encode(message.action.triggerItem, writer.uint32(674).fork()).ldelim();
        }
        if (((_48 = message.action) === null || _48 === void 0 ? void 0 : _48.$case) === "notify") {
            exports.Notify.encode(message.action.notify, writer.uint32(682).fork()).ldelim();
        }
        if (((_49 = message.action) === null || _49 === void 0 ? void 0 : _49.$case) === "setFollowTarget") {
            exports.SetFollowTarget.encode(message.action.setFollowTarget, writer.uint32(690).fork()).ldelim();
        }
        if (((_50 = message.action) === null || _50 === void 0 ? void 0 : _50.$case) === "requestToLead") {
            exports.RequestToLead.encode(message.action.requestToLead, writer.uint32(698).fork()).ldelim();
        }
        if (((_51 = message.action) === null || _51 === void 0 ? void 0 : _51.$case) === "enterPortal") {
            exports.EnterPortal.encode(message.action.enterPortal, writer.uint32(706).fork()).ldelim();
        }
        if (((_52 = message.action) === null || _52 === void 0 ? void 0 : _52.$case) === "setManualVideoSrc") {
            exports.SetManualVideoSrc.encode(message.action.setManualVideoSrc, writer.uint32(714).fork()).ldelim();
        }
        if (((_53 = message.action) === null || _53 === void 0 ? void 0 : _53.$case) === "setSubtitle") {
            exports.SetSubtitle.encode(message.action.setSubtitle, writer.uint32(722).fork()).ldelim();
        }
        if (((_54 = message.action) === null || _54 === void 0 ? void 0 : _54.$case) === "playerUpdatesSession") {
            exports.PlayerUpdatesSession.encode(message.action.playerUpdatesSession, writer.uint32(730).fork()).ldelim();
        }
        if (((_55 = message.action) === null || _55 === void 0 ? void 0 : _55.$case) === "mapMoveObject") {
            exports.MapMoveObject.encode(message.action.mapMoveObject, writer.uint32(738).fork()).ldelim();
        }
        if (((_56 = message.action) === null || _56 === void 0 ? void 0 : _56.$case) === "chatMessageUpdated") {
            exports.ChatMessageUpdated.encode(message.action.chatMessageUpdated, writer.uint32(746).fork()).ldelim();
        }
        if (((_57 = message.action) === null || _57 === void 0 ? void 0 : _57.$case) === "fxShakeObject") {
            exports.FXShakeObject.encode(message.action.fxShakeObject, writer.uint32(754).fork()).ldelim();
        }
        if (((_58 = message.action) === null || _58 === void 0 ? void 0 : _58.$case) === "fxShakeCamera") {
            exports.FXShakeCamera.encode(message.action.fxShakeCamera, writer.uint32(762).fork()).ldelim();
        }
        if (((_59 = message.action) === null || _59 === void 0 ? void 0 : _59.$case) === "registerCommand") {
            exports.RegisterCommand.encode(message.action.registerCommand, writer.uint32(770).fork()).ldelim();
        }
        if (((_60 = message.action) === null || _60 === void 0 ? void 0 : _60.$case) === "sendCommand") {
            exports.SendCommand.encode(message.action.sendCommand, writer.uint32(778).fork()).ldelim();
        }
        if (((_61 = message.action) === null || _61 === void 0 ? void 0 : _61.$case) === "speakerUpdatesSession") {
            exports.SpeakerUpdatesSession.encode(message.action.speakerUpdatesSession, writer.uint32(786).fork()).ldelim();
        }
        if (((_62 = message.action) === null || _62 === void 0 ? void 0 : _62.$case) === "addInventoryItem") {
            exports.AddInventoryItem.encode(message.action.addInventoryItem, writer.uint32(810).fork()).ldelim();
        }
        if (((_63 = message.action) === null || _63 === void 0 ? void 0 : _63.$case) === "removeInventoryItem") {
            exports.RemoveInventoryItem.encode(message.action.removeInventoryItem, writer.uint32(818).fork()).ldelim();
        }
        if (((_64 = message.action) === null || _64 === void 0 ? void 0 : _64.$case) === "setVehicleId") {
            exports.SetVehicleId.encode(message.action.setVehicleId, writer.uint32(826).fork()).ldelim();
        }
        if (((_65 = message.action) === null || _65 === void 0 ? void 0 : _65.$case) === "setSpeedModifier") {
            exports.SetSpeedModifier.encode(message.action.setSpeedModifier, writer.uint32(834).fork()).ldelim();
        }
        if (((_66 = message.action) === null || _66 === void 0 ? void 0 : _66.$case) === "highFive") {
            exports.HighFive.encode(message.action.highFive, writer.uint32(842).fork()).ldelim();
        }
        if (((_67 = message.action) === null || _67 === void 0 ? void 0 : _67.$case) === "updateSpaceItems") {
            exports.SpaceUpdatesItems.encode(message.action.updateSpaceItems, writer.uint32(858).fork()).ldelim();
        }
        if (((_68 = message.action) === null || _68 === void 0 ? void 0 : _68.$case) === "stopSound") {
            exports.StopSound.encode(message.action.stopSound, writer.uint32(866).fork()).ldelim();
        }
        if (((_69 = message.action) === null || _69 === void 0 ? void 0 : _69.$case) === "hipToBeSquare") {
            exports.HipToBeSquare.encode(message.action.hipToBeSquare, writer.uint32(874).fork()).ldelim();
        }
        if (((_70 = message.action) === null || _70 === void 0 ? void 0 : _70.$case) === "craft") {
            exports.Craft.encode(message.action.craft, writer.uint32(882).fork()).ldelim();
        }
        if (((_71 = message.action) === null || _71 === void 0 ? void 0 : _71.$case) === "triggerInventoryItem") {
            exports.TriggerInventoryItem.encode(message.action.triggerInventoryItem, writer.uint32(890).fork()).ldelim();
        }
        if (((_72 = message.action) === null || _72 === void 0 ? void 0 : _72.$case) === "setAllowScreenPointer") {
            exports.SetAllowScreenPointer.encode(message.action.setAllowScreenPointer, writer.uint32(898).fork()).ldelim();
        }
        if (((_73 = message.action) === null || _73 === void 0 ? void 0 : _73.$case) === "precomputeEnter") {
            exports.PrecomputeEnter.encode(message.action.precomputeEnter, writer.uint32(906).fork()).ldelim();
        }
        if (((_74 = message.action) === null || _74 === void 0 ? void 0 : _74.$case) === "requestMute") {
            exports.RequestMute.encode(message.action.requestMute, writer.uint32(914).fork()).ldelim();
        }
        if (((_75 = message.action) === null || _75 === void 0 ? void 0 : _75.$case) === "setDeskInfo") {
            exports.SetDeskInfo.encode(message.action.setDeskInfo, writer.uint32(922).fork()).ldelim();
        }
        if (((_76 = message.action) === null || _76 === void 0 ? void 0 : _76.$case) === "mapSetNooks") {
            exports.MapSetNooks.encode(message.action.mapSetNooks, writer.uint32(930).fork()).ldelim();
        }
        if (((_77 = message.action) === null || _77 === void 0 ? void 0 : _77.$case) === "requestToJoinNook") {
            exports.RequestToJoinNook.encode(message.action.requestToJoinNook, writer.uint32(938).fork()).ldelim();
        }
        if (((_78 = message.action) === null || _78 === void 0 ? void 0 : _78.$case) === "updateNookPermission") {
            exports.UpdateNookPermission.encode(message.action.updateNookPermission, writer.uint32(946).fork()).ldelim();
        }
        if (((_79 = message.action) === null || _79 === void 0 ? void 0 : _79.$case) === "wave") {
            exports.Wave.encode(message.action.wave, writer.uint32(954).fork()).ldelim();
        }
        if (((_80 = message.action) === null || _80 === void 0 ? void 0 : _80.$case) === "setPronouns") {
            exports.SetPronouns.encode(message.action.setPronouns, writer.uint32(962).fork()).ldelim();
        }
        if (((_81 = message.action) === null || _81 === void 0 ? void 0 : _81.$case) === "setTitle") {
            exports.SetTitle.encode(message.action.setTitle, writer.uint32(970).fork()).ldelim();
        }
        if (((_82 = message.action) === null || _82 === void 0 ? void 0 : _82.$case) === "setTimezone") {
            exports.SetTimezone.encode(message.action.setTimezone, writer.uint32(978).fork()).ldelim();
        }
        if (((_83 = message.action) === null || _83 === void 0 ? void 0 : _83.$case) === "setPhone") {
            exports.SetPhone.encode(message.action.setPhone, writer.uint32(986).fork()).ldelim();
        }
        if (((_84 = message.action) === null || _84 === void 0 ? void 0 : _84.$case) === "setDescription") {
            exports.SetDescription.encode(message.action.setDescription, writer.uint32(994).fork()).ldelim();
        }
        if (((_85 = message.action) === null || _85 === void 0 ? void 0 : _85.$case) === "setProfileImageUrl") {
            exports.SetProfileImageUrl.encode(message.action.setProfileImageUrl, writer.uint32(1002).fork()).ldelim();
        }
        if (((_86 = message.action) === null || _86 === void 0 ? void 0 : _86.$case) === "setPersonalImageUrl") {
            exports.SetPersonalImageUrl.encode(message.action.setPersonalImageUrl, writer.uint32(1010).fork()).ldelim();
        }
        if (((_87 = message.action) === null || _87 === void 0 ? void 0 : _87.$case) === "setAway") {
            exports.SetAway.encode(message.action.setAway, writer.uint32(1018).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientServerAction);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 100:
                    message.txnId = reader.uint32();
                    break;
                case 1:
                    message.action = {
                        $case: "clientHeartbeat",
                        clientHeartbeat: exports.ClientHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 2:
                    message.action = {
                        $case: "clientBackupHeartbeat",
                        clientBackupHeartbeat: exports.ClientBackupHeartbeat.decode(reader, reader.uint32()),
                    };
                    break;
                case 3:
                    message.action = {
                        $case: "updateSubscriptions",
                        updateSubscriptions: exports.UpdateSubscriptions.decode(reader, reader.uint32()),
                    };
                    break;
                case 5:
                    message.action = { $case: "move", move: exports.Move.decode(reader, reader.uint32()) };
                    break;
                case 7:
                    message.action = {
                        $case: "setAffiliation",
                        setAffiliation: exports.SetAffiliation.decode(reader, reader.uint32()),
                    };
                    break;
                case 8:
                    message.action = {
                        $case: "setStatus",
                        setStatus: exports.SetStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 9:
                    message.action = {
                        $case: "spotlight",
                        spotlight: exports.Spotlight.decode(reader, reader.uint32()),
                    };
                    break;
                case 10:
                    message.action = { $case: "ring", ring: exports.Ring.decode(reader, reader.uint32()) };
                    break;
                case 12:
                    message.action = { $case: "ban", ban: exports.Ban.decode(reader, reader.uint32()) };
                    break;
                case 13:
                    message.action = { $case: "kick", kick: exports.Kick.decode(reader, reader.uint32()) };
                    break;
                case 14:
                    message.action = {
                        $case: "setImpassable",
                        setImpassable: exports.SetImpassable.decode(reader, reader.uint32()),
                    };
                    break;
                case 15:
                    message.action = { $case: "chat", chat: exports.Chat.decode(reader, reader.uint32()) };
                    break;
                case 18:
                    message.action = {
                        $case: "interact",
                        interact: exports.Interact.decode(reader, reader.uint32()),
                    };
                    break;
                case 19:
                    message.action = {
                        $case: "enterWhisper",
                        enterWhisper: exports.EnterWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 20:
                    message.action = {
                        $case: "leaveWhisper",
                        leaveWhisper: exports.LeaveWhisper.decode(reader, reader.uint32()),
                    };
                    break;
                case 21:
                    message.action = {
                        $case: "setEmojiStatus",
                        setEmojiStatus: exports.SetEmojiStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 22:
                    message.action = {
                        $case: "activelySpeaking",
                        activelySpeaking: exports.ActivelySpeaking.decode(reader, reader.uint32()),
                    };
                    break;
                case 24:
                    message.action = { $case: "setName", setName: exports.SetName.decode(reader, reader.uint32()) };
                    break;
                case 25:
                    message.action = {
                        $case: "setTextStatus",
                        setTextStatus: exports.SetTextStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 26:
                    message.action = {
                        $case: "teleport",
                        teleport: exports.Teleport.decode(reader, reader.uint32()),
                    };
                    break;
                case 27:
                    message.action = { $case: "exit", exit: exports.Exit.decode(reader, reader.uint32()) };
                    break;
                case 28:
                    message.action = { $case: "enter", enter: exports.Enter.decode(reader, reader.uint32()) };
                    break;
                case 29:
                    message.action = {
                        $case: "setWorkCondition",
                        setWorkCondition: exports.SetWorkCondition.decode(reader, reader.uint32()),
                    };
                    break;
                case 30:
                    message.action = { $case: "respawn", respawn: exports.Respawn.decode(reader, reader.uint32()) };
                    break;
                case 31:
                    message.action = { $case: "spawn", spawn: exports.Spawn.decode(reader, reader.uint32()) };
                    break;
                case 32:
                    message.action = { $case: "ghost", ghost: exports.Ghost.decode(reader, reader.uint32()) };
                    break;
                case 33:
                    message.action = { $case: "init", init: exports.Init.decode(reader, reader.uint32()) };
                    break;
                case 34:
                    message.action = {
                        $case: "setOutfitString",
                        setOutfitString: exports.SetOutfitString.decode(reader, reader.uint32()),
                    };
                    break;
                case 36:
                    message.action = {
                        $case: "shootConfetti",
                        shootConfetti: exports.ShootConfetti.decode(reader, reader.uint32()),
                    };
                    break;
                case 37:
                    message.action = {
                        $case: "setEventStatus",
                        setEventStatus: exports.SetEventStatus.decode(reader, reader.uint32()),
                    };
                    break;
                case 38:
                    message.action = {
                        $case: "setInConversation",
                        setInConversation: exports.SetInConversation.decode(reader, reader.uint32()),
                    };
                    break;
                case 39:
                    message.action = {
                        $case: "setCurrentDesk",
                        setCurrentDesk: exports.SetCurrentDesk.decode(reader, reader.uint32()),
                    };
                    break;
                case 40:
                    message.action = {
                        $case: "setCurrentArea",
                        setCurrentArea: exports.SetCurrentArea.decode(reader, reader.uint32()),
                    };
                    break;
                case 41:
                    message.action = {
                        $case: "setImagePointer",
                        setImagePointer: exports.SetImagePointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 42:
                    message.action = {
                        $case: "setGoKartId",
                        setGoKartId: exports.SetGoKartId.decode(reader, reader.uint32()),
                    };
                    break;
                case 43:
                    message.action = {
                        $case: "mapSetDimensions",
                        mapSetDimensions: exports.MapSetDimensions.decode(reader, reader.uint32()),
                    };
                    break;
                case 44:
                    message.action = {
                        $case: "mapSetCollisions",
                        mapSetCollisions: exports.MapSetCollisions.decode(reader, reader.uint32()),
                    };
                    break;
                case 45:
                    message.action = {
                        $case: "mapSetBackgroundImagePath",
                        mapSetBackgroundImagePath: exports.MapSetBackgroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 46:
                    message.action = {
                        $case: "mapSetForegroundImagePath",
                        mapSetForegroundImagePath: exports.MapSetForegroundImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 47:
                    message.action = {
                        $case: "mapSetSprites",
                        mapSetSprites: exports.MapSetSprites.decode(reader, reader.uint32()),
                    };
                    break;
                case 48:
                    message.action = {
                        $case: "mapSetSpawns",
                        mapSetSpawns: exports.MapSetSpawns.decode(reader, reader.uint32()),
                    };
                    break;
                case 49:
                    message.action = {
                        $case: "mapSetSpaces",
                        mapSetSpaces: exports.MapSetSpaces.decode(reader, reader.uint32()),
                    };
                    break;
                case 50:
                    message.action = {
                        $case: "mapSetPortals",
                        mapSetPortals: exports.MapSetPortals.decode(reader, reader.uint32()),
                    };
                    break;
                case 51:
                    message.action = {
                        $case: "mapSetAnnouncer",
                        mapSetAnnouncer: exports.MapSetAnnouncer.decode(reader, reader.uint32()),
                    };
                    break;
                case 54:
                    message.action = {
                        $case: "mapSetAssets",
                        mapSetAssets: exports.MapSetAssets.decode(reader, reader.uint32()),
                    };
                    break;
                case 55:
                    message.action = {
                        $case: "mapSetObjects",
                        mapSetObjects: exports.MapSetObjects.decode(reader, reader.uint32()),
                    };
                    break;
                case 56:
                    message.action = {
                        $case: "mapSetName",
                        mapSetName: exports.MapSetName.decode(reader, reader.uint32()),
                    };
                    break;
                case 58:
                    message.action = {
                        $case: "mapSetMuteOnEntry",
                        mapSetMuteOnEntry: exports.MapSetMuteOnEntry.decode(reader, reader.uint32()),
                    };
                    break;
                case 59:
                    message.action = {
                        $case: "mapSetUseDrawnBG",
                        mapSetUseDrawnBG: exports.MapSetUseDrawnBG.decode(reader, reader.uint32()),
                    };
                    break;
                case 60:
                    message.action = {
                        $case: "mapSetWalls",
                        mapSetWalls: exports.MapSetWalls.decode(reader, reader.uint32()),
                    };
                    break;
                case 61:
                    message.action = {
                        $case: "mapSetFloors",
                        mapSetFloors: exports.MapSetFloors.decode(reader, reader.uint32()),
                    };
                    break;
                case 62:
                    message.action = {
                        $case: "mapSetAreas",
                        mapSetAreas: exports.MapSetAreas.decode(reader, reader.uint32()),
                    };
                    break;
                case 63:
                    message.action = {
                        $case: "mapAddObject",
                        mapAddObject: exports.MapAddObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 64:
                    message.action = {
                        $case: "mapDeleteObject",
                        mapDeleteObject: exports.MapDeleteObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 65:
                    message.action = {
                        $case: "mapSetSpawn",
                        mapSetSpawn: exports.MapSetSpawn.decode(reader, reader.uint32()),
                    };
                    break;
                case 66:
                    message.action = {
                        $case: "setIsAlone",
                        setIsAlone: exports.SetIsAlone.decode(reader, reader.uint32()),
                    };
                    break;
                case 67:
                    message.action = {
                        $case: "mapSetMiniMapImagePath",
                        mapSetMiniMapImagePath: exports.MapSetMiniMapImagePath.decode(reader, reader.uint32()),
                    };
                    break;
                case 68:
                    message.action = {
                        $case: "mapSetEnabledChats",
                        mapSetEnabledChats: exports.MapSetEnabledChats.decode(reader, reader.uint32()),
                    };
                    break;
                case 69:
                    message.action = {
                        $case: "mapSetDescription",
                        mapSetDescription: exports.MapSetDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 70:
                    message.action = {
                        $case: "mapSetDecoration",
                        mapSetDecoration: exports.MapSetDecoration.decode(reader, reader.uint32()),
                    };
                    break;
                case 71:
                    message.action = {
                        $case: "mapSetTutorialTasks",
                        mapSetTutorialTasks: exports.MapSetTutorialTasks.decode(reader, reader.uint32()),
                    };
                    break;
                case 72:
                    message.action = {
                        $case: "playSound",
                        playSound: exports.PlaySound.decode(reader, reader.uint32()),
                    };
                    break;
                case 73:
                    message.action = {
                        $case: "mapSetScript",
                        mapSetScript: exports.MapSetScript.decode(reader, reader.uint32()),
                    };
                    break;
                case 75:
                    message.action = {
                        $case: "setIsMobile",
                        setIsMobile: exports.SetIsMobile.decode(reader, reader.uint32()),
                    };
                    break;
                case 76:
                    message.action = {
                        $case: "setScreenPointer",
                        setScreenPointer: exports.SetScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 77:
                    message.action = {
                        $case: "setEmoteV2",
                        setEmoteV2: exports.SetEmoteV2.decode(reader, reader.uint32()),
                    };
                    break;
                case 78:
                    message.action = {
                        $case: "setFocusModeEndTime",
                        setFocusModeEndTime: exports.SetFocusModeEndTime.decode(reader, reader.uint32()),
                    };
                    break;
                case 79:
                    message.action = {
                        $case: "mapDeleteObjectById",
                        mapDeleteObjectById: exports.MapDeleteObjectById.decode(reader, reader.uint32()),
                    };
                    break;
                case 80:
                    message.action = {
                        $case: "customAction",
                        customAction: exports.CustomAction.decode(reader, reader.uint32()),
                    };
                    break;
                case 82:
                    message.action = { $case: "block", block: exports.Block.decode(reader, reader.uint32()) };
                    break;
                case 83:
                    message.action = {
                        $case: "setItemString",
                        setItemString: exports.SetItemString.decode(reader, reader.uint32()),
                    };
                    break;
                case 84:
                    message.action = {
                        $case: "triggerItem",
                        triggerItem: exports.TriggerItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 85:
                    message.action = { $case: "notify", notify: exports.Notify.decode(reader, reader.uint32()) };
                    break;
                case 86:
                    message.action = {
                        $case: "setFollowTarget",
                        setFollowTarget: exports.SetFollowTarget.decode(reader, reader.uint32()),
                    };
                    break;
                case 87:
                    message.action = {
                        $case: "requestToLead",
                        requestToLead: exports.RequestToLead.decode(reader, reader.uint32()),
                    };
                    break;
                case 88:
                    message.action = {
                        $case: "enterPortal",
                        enterPortal: exports.EnterPortal.decode(reader, reader.uint32()),
                    };
                    break;
                case 89:
                    message.action = {
                        $case: "setManualVideoSrc",
                        setManualVideoSrc: exports.SetManualVideoSrc.decode(reader, reader.uint32()),
                    };
                    break;
                case 90:
                    message.action = {
                        $case: "setSubtitle",
                        setSubtitle: exports.SetSubtitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 91:
                    message.action = {
                        $case: "playerUpdatesSession",
                        playerUpdatesSession: exports.PlayerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 92:
                    message.action = {
                        $case: "mapMoveObject",
                        mapMoveObject: exports.MapMoveObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 93:
                    message.action = {
                        $case: "chatMessageUpdated",
                        chatMessageUpdated: exports.ChatMessageUpdated.decode(reader, reader.uint32()),
                    };
                    break;
                case 94:
                    message.action = {
                        $case: "fxShakeObject",
                        fxShakeObject: exports.FXShakeObject.decode(reader, reader.uint32()),
                    };
                    break;
                case 95:
                    message.action = {
                        $case: "fxShakeCamera",
                        fxShakeCamera: exports.FXShakeCamera.decode(reader, reader.uint32()),
                    };
                    break;
                case 96:
                    message.action = {
                        $case: "registerCommand",
                        registerCommand: exports.RegisterCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 97:
                    message.action = {
                        $case: "sendCommand",
                        sendCommand: exports.SendCommand.decode(reader, reader.uint32()),
                    };
                    break;
                case 98:
                    message.action = {
                        $case: "speakerUpdatesSession",
                        speakerUpdatesSession: exports.SpeakerUpdatesSession.decode(reader, reader.uint32()),
                    };
                    break;
                case 101:
                    message.action = {
                        $case: "addInventoryItem",
                        addInventoryItem: exports.AddInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 102:
                    message.action = {
                        $case: "removeInventoryItem",
                        removeInventoryItem: exports.RemoveInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 103:
                    message.action = {
                        $case: "setVehicleId",
                        setVehicleId: exports.SetVehicleId.decode(reader, reader.uint32()),
                    };
                    break;
                case 104:
                    message.action = {
                        $case: "setSpeedModifier",
                        setSpeedModifier: exports.SetSpeedModifier.decode(reader, reader.uint32()),
                    };
                    break;
                case 105:
                    message.action = {
                        $case: "highFive",
                        highFive: exports.HighFive.decode(reader, reader.uint32()),
                    };
                    break;
                case 107:
                    message.action = {
                        $case: "updateSpaceItems",
                        updateSpaceItems: exports.SpaceUpdatesItems.decode(reader, reader.uint32()),
                    };
                    break;
                case 108:
                    message.action = {
                        $case: "stopSound",
                        stopSound: exports.StopSound.decode(reader, reader.uint32()),
                    };
                    break;
                case 109:
                    message.action = {
                        $case: "hipToBeSquare",
                        hipToBeSquare: exports.HipToBeSquare.decode(reader, reader.uint32()),
                    };
                    break;
                case 110:
                    message.action = { $case: "craft", craft: exports.Craft.decode(reader, reader.uint32()) };
                    break;
                case 111:
                    message.action = {
                        $case: "triggerInventoryItem",
                        triggerInventoryItem: exports.TriggerInventoryItem.decode(reader, reader.uint32()),
                    };
                    break;
                case 112:
                    message.action = {
                        $case: "setAllowScreenPointer",
                        setAllowScreenPointer: exports.SetAllowScreenPointer.decode(reader, reader.uint32()),
                    };
                    break;
                case 113:
                    message.action = {
                        $case: "precomputeEnter",
                        precomputeEnter: exports.PrecomputeEnter.decode(reader, reader.uint32()),
                    };
                    break;
                case 114:
                    message.action = {
                        $case: "requestMute",
                        requestMute: exports.RequestMute.decode(reader, reader.uint32()),
                    };
                    break;
                case 115:
                    message.action = {
                        $case: "setDeskInfo",
                        setDeskInfo: exports.SetDeskInfo.decode(reader, reader.uint32()),
                    };
                    break;
                case 116:
                    message.action = {
                        $case: "mapSetNooks",
                        mapSetNooks: exports.MapSetNooks.decode(reader, reader.uint32()),
                    };
                    break;
                case 117:
                    message.action = {
                        $case: "requestToJoinNook",
                        requestToJoinNook: exports.RequestToJoinNook.decode(reader, reader.uint32()),
                    };
                    break;
                case 118:
                    message.action = {
                        $case: "updateNookPermission",
                        updateNookPermission: exports.UpdateNookPermission.decode(reader, reader.uint32()),
                    };
                    break;
                case 119:
                    message.action = { $case: "wave", wave: exports.Wave.decode(reader, reader.uint32()) };
                    break;
                case 120:
                    message.action = {
                        $case: "setPronouns",
                        setPronouns: exports.SetPronouns.decode(reader, reader.uint32()),
                    };
                    break;
                case 121:
                    message.action = {
                        $case: "setTitle",
                        setTitle: exports.SetTitle.decode(reader, reader.uint32()),
                    };
                    break;
                case 122:
                    message.action = {
                        $case: "setTimezone",
                        setTimezone: exports.SetTimezone.decode(reader, reader.uint32()),
                    };
                    break;
                case 123:
                    message.action = {
                        $case: "setPhone",
                        setPhone: exports.SetPhone.decode(reader, reader.uint32()),
                    };
                    break;
                case 124:
                    message.action = {
                        $case: "setDescription",
                        setDescription: exports.SetDescription.decode(reader, reader.uint32()),
                    };
                    break;
                case 125:
                    message.action = {
                        $case: "setProfileImageUrl",
                        setProfileImageUrl: exports.SetProfileImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 126:
                    message.action = {
                        $case: "setPersonalImageUrl",
                        setPersonalImageUrl: exports.SetPersonalImageUrl.decode(reader, reader.uint32()),
                    };
                    break;
                case 127:
                    message.action = { $case: "setAway", setAway: exports.SetAway.decode(reader, reader.uint32()) };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseClientHeartbeat = {};
exports.ClientHeartbeat = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientHeartbeat);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseClientBackupHeartbeat = {};
exports.ClientBackupHeartbeat = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseClientBackupHeartbeat);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseUpdateSubscriptions = {};
exports.UpdateSubscriptions = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.subscriptions).forEach(([key, value]) => {
            exports.UpdateSubscriptions_SubscriptionsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        Object.entries(message.mapUpdateIds).forEach(([key, value]) => {
            exports.UpdateSubscriptions_MapUpdateIdsEntry.encode({ key: key, value }, writer.uint32(18).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscriptions);
        message.subscriptions = {};
        message.mapUpdateIds = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.UpdateSubscriptions_SubscriptionsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.subscriptions[entry1.key] = entry1.value;
                    }
                    break;
                case 2:
                    const entry2 = exports.UpdateSubscriptions_MapUpdateIdsEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.mapUpdateIds[entry2.key] = entry2.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseUpdateSubscriptions_SubscriptionsEntry = { key: "", value: false };
exports.UpdateSubscriptions_SubscriptionsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value === true) {
            writer.uint32(16).bool(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscriptions_SubscriptionsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseUpdateSubscriptions_MapUpdateIdsEntry = { key: "", value: 0 };
exports.UpdateSubscriptions_MapUpdateIdsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).uint64(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateSubscriptions_MapUpdateIdsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMove = { dir: 0, stopped: false, inputId: 0 };
exports.Move = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.dir !== 0) {
            writer.uint32(8).int32(message.dir);
        }
        if (message.stopped === true) {
            writer.uint32(16).bool(message.stopped);
        }
        if (message.inputId !== 0) {
            writer.uint32(24).uint32(message.inputId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(34).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMove);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.dir = reader.int32();
                    break;
                case 2:
                    message.stopped = reader.bool();
                    break;
                case 3:
                    message.inputId = reader.uint32();
                    break;
                case 4:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestMute = { target: "", video: false };
exports.RequestMute = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.target !== "") {
            writer.uint32(10).string(message.target);
        }
        if (message.video === true) {
            writer.uint32(16).bool(message.video);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestMute);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.target = reader.string();
                    break;
                case 2:
                    message.video = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetAffiliation = { affiliation: "" };
exports.SetAffiliation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.affiliation !== "") {
            writer.uint32(10).string(message.affiliation);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetAffiliation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.affiliation = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetStatus = { status: false };
exports.SetStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.status === true) {
            writer.uint32(8).bool(message.status);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.status = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetOutfitString = { outfitString: "" };
exports.SetOutfitString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.outfitString !== "") {
            writer.uint32(10).string(message.outfitString);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetOutfitString);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.outfitString = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpotlight = { spotlightedUser: "", isSpotlighted: false };
exports.Spotlight = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spotlightedUser !== "") {
            writer.uint32(10).string(message.spotlightedUser);
        }
        if (message.isSpotlighted === true) {
            writer.uint32(16).bool(message.isSpotlighted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpotlight);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spotlightedUser = reader.string();
                    break;
                case 2:
                    message.isSpotlighted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRing = { user: "" };
exports.Ring = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRing);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetImagePointer = { objectId: "", x: 0, y: 0 };
exports.SetImagePointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.objectId !== "") {
            writer.uint32(10).string(message.objectId);
        }
        if (message.x !== 0) {
            writer.uint32(17).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(25).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetImagePointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.objectId = reader.string();
                    break;
                case 2:
                    message.x = reader.double();
                    break;
                case 3:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetScreenPointer = { screenId: "", x: 0, y: 0 };
exports.SetScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.screenId !== "") {
            writer.uint32(10).string(message.screenId);
        }
        if (message.x !== 0) {
            writer.uint32(17).double(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(25).double(message.y);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetScreenPointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.screenId = reader.string();
                    break;
                case 2:
                    message.x = reader.double();
                    break;
                case 3:
                    message.y = reader.double();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseBan = { user: "" };
exports.Ban = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBan);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseKick = { user: "" };
exports.Kick = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseKick);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseBlock = { blockedUserId: "", blocked: false };
exports.Block = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.blockedUserId !== "") {
            writer.uint32(10).string(message.blockedUserId);
        }
        if (message.blocked === true) {
            writer.uint32(16).bool(message.blocked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseBlock);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.blockedUserId = reader.string();
                    break;
                case 2:
                    message.blocked = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetImpassable = { mapId: "", x: 0, y: 0, impassable: false };
exports.SetImpassable = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.impassable === true) {
            writer.uint32(32).bool(message.impassable);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetImpassable);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.impassable = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseChat = { chatRecipient: "", contents: "", localPlayerIds: "", mapId: "" };
exports.Chat = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.chatRecipient !== "") {
            writer.uint32(10).string(message.chatRecipient);
        }
        if (message.contents !== "") {
            writer.uint32(18).string(message.contents);
        }
        for (const v of message.localPlayerIds) {
            writer.uint32(26).string(v);
        }
        if (message.mapId !== "") {
            writer.uint32(34).string(message.mapId);
        }
        if (message.id !== undefined) {
            writer.uint32(42).string(message.id);
        }
        if (message.nookId !== undefined) {
            writer.uint32(50).string(message.nookId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseChat);
        message.localPlayerIds = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.chatRecipient = reader.string();
                    break;
                case 2:
                    message.contents = reader.string();
                    break;
                case 3:
                    message.localPlayerIds.push(reader.string());
                    break;
                case 4:
                    message.mapId = reader.string();
                    break;
                case 5:
                    message.id = reader.string();
                    break;
                case 6:
                    message.nookId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseNotify = { notification: "" };
exports.Notify = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.notification !== "") {
            writer.uint32(10).string(message.notification);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseNotify);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.notification = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInteract = { objId: "" };
exports.Interact = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.objId !== "") {
            writer.uint32(10).string(message.objId);
        }
        if (message.mapId !== undefined) {
            writer.uint32(26).string(message.mapId);
        }
        if (message.dataJson !== undefined) {
            writer.uint32(18).string(message.dataJson);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInteract);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.objId = reader.string();
                    break;
                case 3:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.dataJson = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseActivelySpeaking = { activelySpeaking: false };
exports.ActivelySpeaking = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.activelySpeaking === true) {
            writer.uint32(8).bool(message.activelySpeaking);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseActivelySpeaking);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.activelySpeaking = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseEnterWhisper = { recipientId: "", dir: 0 };
exports.EnterWhisper = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.recipientId !== "") {
            writer.uint32(10).string(message.recipientId);
        }
        if (message.dir !== 0) {
            writer.uint32(16).int32(message.dir);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEnterWhisper);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.recipientId = reader.string();
                    break;
                case 2:
                    message.dir = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseLeaveWhisper = {};
exports.LeaveWhisper = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseLeaveWhisper);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseGhost = { ghost: 0 };
exports.Ghost = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.ghost !== 0) {
            writer.uint32(8).uint32(message.ghost);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGhost);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.ghost = reader.uint32();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetEmoteV2 = {};
exports.SetEmoteV2 = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.emote !== undefined) {
            writer.uint32(10).string(message.emote);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        if (message.count !== undefined) {
            writer.uint32(24).uint32(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetEmoteV2);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.emote = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.count = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetName = { name: "" };
exports.SetName = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetName);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetTextStatus = { textStatus: "" };
exports.SetTextStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.textStatus !== "") {
            writer.uint32(10).string(message.textStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetTextStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.textStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetPronouns = { pronouns: "" };
exports.SetPronouns = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.pronouns !== "") {
            writer.uint32(10).string(message.pronouns);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetPronouns);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.pronouns = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetTitle = { title: "" };
exports.SetTitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetTitle);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.title = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetTimezone = { timezone: "" };
exports.SetTimezone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.timezone !== "") {
            writer.uint32(10).string(message.timezone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetTimezone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.timezone = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetPhone = { phone: "" };
exports.SetPhone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.phone !== "") {
            writer.uint32(10).string(message.phone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetPhone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.phone = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetDescription = { description: "" };
exports.SetDescription = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetDescription);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.description = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetProfileImageUrl = { profileImageUrl: "" };
exports.SetProfileImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.profileImageUrl !== "") {
            writer.uint32(10).string(message.profileImageUrl);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetProfileImageUrl);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.profileImageUrl = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetPersonalImageUrl = { personalImageUrl: "" };
exports.SetPersonalImageUrl = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.personalImageUrl !== "") {
            writer.uint32(10).string(message.personalImageUrl);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetPersonalImageUrl);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.personalImageUrl = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseExit = {};
exports.Exit = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseExit);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseEnter = {};
exports.Enter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.info !== undefined) {
            exports.PlayerInitInfo.encode(message.info, writer.uint32(10).fork()).ldelim();
        }
        if (message.spawnToken !== undefined) {
            writer.uint32(18).string(message.spawnToken);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEnter);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.info = exports.PlayerInitInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.spawnToken = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePrecomputeEnter = {};
exports.PrecomputeEnter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.enterLocation !== undefined) {
            exports.MapLocation.encode(message.enterLocation, writer.uint32(10).fork()).ldelim();
        }
        if (message.spawnToken !== undefined) {
            writer.uint32(18).string(message.spawnToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePrecomputeEnter);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.enterLocation = exports.MapLocation.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.spawnToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetEmojiStatus = { emojiStatus: "" };
exports.SetEmojiStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.emojiStatus !== "") {
            writer.uint32(10).string(message.emojiStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetEmojiStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.emojiStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTeleport = { mapId: "", x: 0, y: 0 };
exports.Teleport = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.x !== 0) {
            writer.uint32(16).uint32(message.x);
        }
        if (message.y !== 0) {
            writer.uint32(24).uint32(message.y);
        }
        if (message.targetId !== undefined) {
            writer.uint32(34).string(message.targetId);
        }
        if (message.direction !== undefined) {
            writer.uint32(40).int32(message.direction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTeleport);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.x = reader.uint32();
                    break;
                case 3:
                    message.y = reader.uint32();
                    break;
                case 4:
                    message.targetId = reader.string();
                    break;
                case 5:
                    message.direction = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetWorkCondition = { workCondition: false };
exports.SetWorkCondition = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.workCondition === true) {
            writer.uint32(8).bool(message.workCondition);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetWorkCondition);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.workCondition = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpawn = { spawnToken: "" };
exports.Spawn = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.spawnToken !== "") {
            writer.uint32(10).string(message.spawnToken);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpawn);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spawnToken = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRespawn = {};
exports.Respawn = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRespawn);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestToJoinNook = { nookId: "", mapId: "" };
exports.RequestToJoinNook = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.nookId !== "") {
            writer.uint32(10).string(message.nookId);
        }
        if (message.mapId !== "") {
            writer.uint32(18).string(message.mapId);
        }
        if (message.name !== undefined) {
            writer.uint32(26).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestToJoinNook);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.nookId = reader.string();
                    break;
                case 2:
                    message.mapId = reader.string();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseUpdateNookPermission = { playerId: "", nookId: "", granted: false };
exports.UpdateNookPermission = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.playerId !== "") {
            writer.uint32(10).string(message.playerId);
        }
        if (message.nookId !== "") {
            writer.uint32(18).string(message.nookId);
        }
        if (message.granted === true) {
            writer.uint32(24).bool(message.granted);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseUpdateNookPermission);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.playerId = reader.string();
                    break;
                case 2:
                    message.nookId = reader.string();
                    break;
                case 3:
                    message.granted = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseInit = { spaceId: "" };
exports.Init = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        var _a, _b;
        if (message.spaceId !== "") {
            writer.uint32(10).string(message.spaceId);
        }
        if (((_a = message.auth) === null || _a === void 0 ? void 0 : _a.$case) === "token") {
            writer.uint32(18).string(message.auth.token);
        }
        if (((_b = message.auth) === null || _b === void 0 ? void 0 : _b.$case) === "apiKey") {
            writer.uint32(26).string(message.auth.apiKey);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseInit);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.spaceId = reader.string();
                    break;
                case 2:
                    message.auth = { $case: "token", token: reader.string() };
                    break;
                case 3:
                    message.auth = { $case: "apiKey", apiKey: reader.string() };
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapAddObject = { mapId: "" };
exports.MapAddObject = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.object !== undefined) {
            exports.WireObject.encode(message.object, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapAddObject);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.object = exports.WireObject.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseShootConfetti = {};
exports.ShootConfetti = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== undefined) {
            writer.uint32(10).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseShootConfetti);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetEventStatus = { eventStatus: "" };
exports.SetEventStatus = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.eventStatus !== "") {
            writer.uint32(10).string(message.eventStatus);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetEventStatus);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.eventStatus = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetInConversation = { inConversation: false };
exports.SetInConversation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.inConversation === true) {
            writer.uint32(8).bool(message.inConversation);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetInConversation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.inConversation = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetCurrentDesk = { currentDesk: "" };
exports.SetCurrentDesk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.currentDesk !== "") {
            writer.uint32(10).string(message.currentDesk);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetCurrentDesk);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentDesk = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetCurrentArea = { currentArea: "" };
exports.SetCurrentArea = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.currentArea !== "") {
            writer.uint32(10).string(message.currentArea);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetCurrentArea);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.currentArea = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetGoKartId = { goKartId: "" };
exports.SetGoKartId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.goKartId !== "") {
            writer.uint32(10).string(message.goKartId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetGoKartId);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.goKartId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetVehicleId = { vehicleId: "" };
exports.SetVehicleId = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.vehicleId !== "") {
            writer.uint32(10).string(message.vehicleId);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        if (message.action !== undefined) {
            writer.uint32(26).string(message.action);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetVehicleId);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.vehicleId = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                case 3:
                    message.action = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetSpeedModifier = { speedModifier: 0 };
exports.SetSpeedModifier = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.speedModifier !== 0) {
            writer.uint32(13).float(message.speedModifier);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetSpeedModifier);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.speedModifier = reader.float();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetIsAlone = { isAlone: false };
exports.SetIsAlone = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isAlone === true) {
            writer.uint32(8).bool(message.isAlone);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetIsAlone);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isAlone = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetIsMobile = { isMobile: false };
exports.SetIsMobile = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.isMobile === true) {
            writer.uint32(8).bool(message.isMobile);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetIsMobile);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.isMobile = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlaySound = { src: "", volume: 0 };
exports.PlaySound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.volume !== 0) {
            writer.uint32(21).float(message.volume);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlaySound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 2:
                    message.volume = reader.float();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseStopSound = { src: "" };
exports.StopSound = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.src !== "") {
            writer.uint32(10).string(message.src);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseStopSound);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.src = reader.string();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetFocusModeEndTime = { focusModeEndTime: "" };
exports.SetFocusModeEndTime = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.focusModeEndTime !== "") {
            writer.uint32(10).string(message.focusModeEndTime);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetFocusModeEndTime);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.focusModeEndTime = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetItemString = { itemString: "" };
exports.SetItemString = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemString !== "") {
            writer.uint32(10).string(message.itemString);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetItemString);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemString = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTriggerItem = {};
exports.TriggerItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.closestObject !== undefined) {
            writer.uint32(10).string(message.closestObject);
        }
        if (message.closestObjectTemplate !== undefined) {
            writer.uint32(26).string(message.closestObjectTemplate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTriggerItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.closestObject = reader.string();
                    break;
                case 3:
                    message.closestObjectTemplate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseCustomAction = { name: "", payload: "", recipients: "" };
exports.CustomAction = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.payload !== "") {
            writer.uint32(18).string(message.payload);
        }
        for (const v of message.recipients) {
            writer.uint32(26).string(v);
        }
        if (message.sendToAll !== undefined) {
            writer.uint32(32).bool(message.sendToAll);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCustomAction);
        message.recipients = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.payload = reader.string();
                    break;
                case 3:
                    message.recipients.push(reader.string());
                    break;
                case 4:
                    message.sendToAll = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetFollowTarget = { followTarget: "" };
exports.SetFollowTarget = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.followTarget !== "") {
            writer.uint32(10).string(message.followTarget);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetFollowTarget);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.followTarget = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRequestToLead = { target: "", snapshot: "" };
exports.RequestToLead = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.target !== "") {
            writer.uint32(10).string(message.target);
        }
        if (message.snapshot !== "") {
            writer.uint32(18).string(message.snapshot);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRequestToLead);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.target = reader.string();
                    break;
                case 2:
                    message.snapshot = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseEnterPortal = { targetUrl: "" };
exports.EnterPortal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetUrl !== "") {
            writer.uint32(10).string(message.targetUrl);
        }
        if (message.bypassPrompt !== undefined) {
            writer.uint32(16).bool(message.bypassPrompt);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseEnterPortal);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetUrl = reader.string();
                    break;
                case 2:
                    message.bypassPrompt = reader.bool();
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetManualVideoSrc = { manualVideoSrc: "" };
exports.SetManualVideoSrc = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.manualVideoSrc !== "") {
            writer.uint32(10).string(message.manualVideoSrc);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetManualVideoSrc);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.manualVideoSrc = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetSubtitle = { subtitle: "" };
exports.SetSubtitle = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.subtitle !== "") {
            writer.uint32(10).string(message.subtitle);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetSubtitle);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.subtitle = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseMapCommitsChanges = { mapId: "", updateId: 0 };
exports.MapCommitsChanges = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.mapId !== "") {
            writer.uint32(10).string(message.mapId);
        }
        if (message.updateId !== 0) {
            writer.uint32(16).uint64(message.updateId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMapCommitsChanges);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.mapId = reader.string();
                    break;
                case 2:
                    message.updateId = longToNumber(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const basePlayerUpdatesSession = { roomId: "" };
exports.PlayerUpdatesSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.roomChecked !== undefined) {
            writer.uint32(8).bool(message.roomChecked);
        }
        if (message.chatChecked !== undefined) {
            writer.uint32(16).bool(message.chatChecked);
        }
        if (message.qaChecked !== undefined) {
            writer.uint32(24).bool(message.qaChecked);
        }
        if (message.approveQuestionsChecked !== undefined) {
            writer.uint32(32).bool(message.approveQuestionsChecked);
        }
        if (message.roomId !== "") {
            writer.uint32(42).string(message.roomId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, basePlayerUpdatesSession);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.roomChecked = reader.bool();
                    break;
                case 2:
                    message.chatChecked = reader.bool();
                    break;
                case 3:
                    message.qaChecked = reader.bool();
                    break;
                case 4:
                    message.approveQuestionsChecked = reader.bool();
                    break;
                case 5:
                    message.roomId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSpeakerUpdatesSession = { sessionId: "" };
exports.SpeakerUpdatesSession = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sessionId !== "") {
            writer.uint32(10).string(message.sessionId);
        }
        if (message.customizeRoomEnabled !== undefined) {
            writer.uint32(16).bool(message.customizeRoomEnabled);
        }
        if (message.chatEnabled !== undefined) {
            writer.uint32(24).bool(message.chatEnabled);
        }
        if (message.qaEnabled !== undefined) {
            writer.uint32(32).bool(message.qaEnabled);
        }
        if (message.approveQuestionsEnabled !== undefined) {
            writer.uint32(40).bool(message.approveQuestionsEnabled);
        }
        if (message.massMuteEnabled !== undefined) {
            writer.uint32(48).bool(message.massMuteEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSpeakerUpdatesSession);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.sessionId = reader.string();
                    break;
                case 2:
                    message.customizeRoomEnabled = reader.bool();
                    break;
                case 3:
                    message.chatEnabled = reader.bool();
                    break;
                case 4:
                    message.qaEnabled = reader.bool();
                    break;
                case 5:
                    message.approveQuestionsEnabled = reader.bool();
                    break;
                case 6:
                    message.massMuteEnabled = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseChatReply = { senderId: "", senderName: "", contents: "" };
exports.ChatReply = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.senderId !== "") {
            writer.uint32(10).string(message.senderId);
        }
        if (message.senderName !== "") {
            writer.uint32(18).string(message.senderName);
        }
        if (message.contents !== "") {
            writer.uint32(26).string(message.contents);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseChatReply);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.senderId = reader.string();
                    break;
                case 2:
                    message.senderName = reader.string();
                    break;
                case 3:
                    message.contents = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseChatMessageUpdated = { id: "" };
exports.ChatMessageUpdated = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== "") {
            writer.uint32(10).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseChatMessageUpdated);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSendCommand = { command: "" };
exports.SendCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(10).string(message.command);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSendCommand);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRegisterCommand = { command: "" };
exports.RegisterCommand = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.command !== "") {
            writer.uint32(10).string(message.command);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRegisterCommand);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseCraft = {};
exports.Craft = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.inputs).forEach(([key, value]) => {
            exports.Craft_InputsEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCraft);
        message.inputs = {};
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    const entry1 = exports.Craft_InputsEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.inputs[entry1.key] = entry1.value;
                    }
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseCraft_InputsEntry = { key: "", value: 0 };
exports.Craft_InputsEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== 0) {
            writer.uint32(16).int32(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseCraft_InputsEntry);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.key = reader.string();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseHighFive = { targetId: "" };
exports.HighFive = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.targetId !== "") {
            writer.uint32(10).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHighFive);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseAddInventoryItem = { itemId: "", delta: 0, targetId: "" };
exports.AddInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.delta !== 0) {
            writer.uint32(16).uint64(message.delta);
        }
        if (message.targetId !== "") {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseAddInventoryItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.delta = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseRemoveInventoryItem = { itemId: "", delta: 0 };
exports.RemoveInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.delta !== 0) {
            writer.uint32(16).uint64(message.delta);
        }
        if (message.targetId !== undefined) {
            writer.uint32(26).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseRemoveInventoryItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.delta = longToNumber(reader.uint64());
                    break;
                case 3:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseHipToBeSquare = { data: "" };
exports.HipToBeSquare = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.data !== "") {
            writer.uint32(10).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseHipToBeSquare);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.data = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseTriggerInventoryItem = { itemId: "", abilityId: "" };
exports.TriggerInventoryItem = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.itemId !== "") {
            writer.uint32(10).string(message.itemId);
        }
        if (message.abilityId !== "") {
            writer.uint32(18).string(message.abilityId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTriggerInventoryItem);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.itemId = reader.string();
                    break;
                case 2:
                    message.abilityId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetAllowScreenPointer = { allowScreenPointer: false };
exports.SetAllowScreenPointer = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.allowScreenPointer === true) {
            writer.uint32(8).bool(message.allowScreenPointer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetAllowScreenPointer);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.allowScreenPointer = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetDeskInfo = {};
exports.SetDeskInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.deskInfo !== undefined) {
            exports.DeskInfoV2.encode(message.deskInfo, writer.uint32(10).fork()).ldelim();
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetDeskInfo);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.deskInfo = exports.DeskInfoV2.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseWave = { user: "", isReply: false };
exports.Wave = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.user !== "") {
            writer.uint32(10).string(message.user);
        }
        if (message.isReply === true) {
            writer.uint32(16).bool(message.isReply);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseWave);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.user = reader.string();
                    break;
                case 2:
                    message.isReply = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
const baseSetAway = { away: false };
exports.SetAway = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.away === true) {
            writer.uint32(8).bool(message.away);
        }
        if (message.targetId !== undefined) {
            writer.uint32(18).string(message.targetId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseSetAway);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.away = reader.bool();
                    break;
                case 2:
                    message.targetId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
var globalThis = (() => {
    if (typeof globalThis !== "undefined")
        return globalThis;
    if (typeof self !== "undefined")
        return self;
    if (typeof window !== "undefined")
        return window;
    if (typeof global !== "undefined")
        return global;
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
exports.protobufWriterLibrary = minimal_1.default;
//# sourceMappingURL=events.js.map