"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.MAP_MAX_DIMENSION = exports.verifyMapIsComplete = exports.convertStringToPresetTutorialGroupSetId = exports.convertTutorialTasksToWireTutorialTasks = exports.convertWireTutorialTasksToTutorialTasks = exports.PresetTutorialGroupSetIds = exports.convertStringToEnabledChat = exports.wallFloorConvertToDB = exports.wallFloorConvertFromDB = exports.EnabledChat = exports.areaToCoords = exports.interactionOpensModal = exports.TileType = exports.convertCoordsToBBoxes = exports.convertDesksToDBDesks = exports.convertDBDesksToDesks = exports.generateEmptyDeskCoordsMap = exports.convertDBDesksCoordsToCoordsMap = exports.convertAreaCoordsToCoordsMap = exports.convertWireAreasToAreas = exports.convertWireAreasToDBAreas = exports.AreaCategory = exports.convertMapObjectToWireObject = exports.convertWireObjectToMapObject = exports.convertWireObjectToMapObjectDB = exports.findMissingMapObjectFields = exports.Tile = exports.WallFloorDB = exports.FloorBlock = exports.WallBlock = exports.Interaction = void 0;
var lodash_1 = require("lodash");
var buffer_1 = require("buffer");
var Position_1 = require("./Position");
var events_1 = require("./generated_DO_NOT_TOUCH/events");
exports.Interaction = events_1.InteractionEnum_ENUM;
var WallBlock = (function () {
    function WallBlock() {
    }
    return WallBlock;
}());
exports.WallBlock = WallBlock;
var FloorBlock = (function () {
    function FloorBlock() {
    }
    return FloorBlock;
}());
exports.FloorBlock = FloorBlock;
var WallFloorDB = (function () {
    function WallFloorDB() {
    }
    return WallFloorDB;
}());
exports.WallFloorDB = WallFloorDB;
var Tile = (function () {
    function Tile() {
    }
    return Tile;
}());
exports.Tile = Tile;
function findMissingMapObjectFields(object) {
    var e_1, _a;
    var requiredFields = ["x", "y", "normal", "type", "width", "height"];
    var missingFields = [];
    try {
        for (var requiredFields_1 = __values(requiredFields), requiredFields_1_1 = requiredFields_1.next(); !requiredFields_1_1.done; requiredFields_1_1 = requiredFields_1.next()) {
            var field = requiredFields_1_1.value;
            if (object[field] === undefined) {
                missingFields.push(field);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (requiredFields_1_1 && !requiredFields_1_1.done && (_a = requiredFields_1["return"])) _a.call(requiredFields_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return missingFields;
}
exports.findMissingMapObjectFields = findMissingMapObjectFields;
function convertWireObjectToMapObjectDB(wireObject) {
    var mapObject = (0, lodash_1.cloneDeep)(wireObject);
    if (wireObject.propertiesJson) {
        mapObject.properties = JSON.parse(wireObject.propertiesJson);
        delete mapObject.propertiesJson;
    }
    if (wireObject._tags && wireObject._tags.length === 0) {
        delete mapObject._tags;
    }
    if (wireObject.type == null) {
        mapObject.type = 0;
    }
    var missingFields = findMissingMapObjectFields(mapObject);
    if (missingFields.length > 0) {
        throw "Failed to convert to MapObject because the following required fields were missing: ".concat(missingFields);
    }
    return mapObject;
}
exports.convertWireObjectToMapObjectDB = convertWireObjectToMapObjectDB;
function convertWireObjectToMapObject(wireObject, key) {
    var obj = convertWireObjectToMapObjectDB(wireObject);
    obj.key = key;
    return obj;
}
exports.convertWireObjectToMapObject = convertWireObjectToMapObject;
function convertMapObjectToWireObject(mapObject) {
    var wireObject = (0, lodash_1.cloneDeep)(mapObject);
    if (mapObject.properties) {
        wireObject.propertiesJson = JSON.stringify(mapObject.properties);
        delete wireObject.properties;
    }
    if (!mapObject._tags) {
        wireObject._tags = [];
    }
    return wireObject;
}
exports.convertMapObjectToWireObject = convertMapObjectToWireObject;
var AreaCategory;
(function (AreaCategory) {
    AreaCategory["RW_OFFICE_LOBBY"] = "RW_OFFICE_LOBBY";
    AreaCategory["RW_OFFICE_MEETING"] = "RW_OFFICE_MEETING";
    AreaCategory["COWORKING"] = "COWORKING";
})(AreaCategory = exports.AreaCategory || (exports.AreaCategory = {}));
function convertWireAreasToDBAreas(wireAreas) {
    var dbAreas = {};
    return Object.keys(wireAreas).reduce(function (dbAreas, areaName) {
        var _a = wireAreas[areaName], coords = _a.coords, category = _a.category;
        dbAreas[areaName] = { coords: coords };
        if (category) {
            dbAreas[areaName].category = convertStringToAreaCategory(category);
        }
        return dbAreas;
    }, dbAreas);
}
exports.convertWireAreasToDBAreas = convertWireAreasToDBAreas;
function convertWireAreasToAreas(wireAreas, dimensions) {
    if (dimensions === undefined) {
        throw new Error("Cannot convert wire areas to areas because dimensions are undefined");
    }
    var areas = {};
    return Object.keys(wireAreas).reduce(function (areas, areaName) {
        var _a = wireAreas[areaName], coords = _a.coords, category = _a.category;
        var coordsMap = convertAreaCoordsToCoordsMap(coords, dimensions);
        areas[areaName] = { coordsMap: coordsMap };
        if (category) {
            areas[areaName].category = convertStringToAreaCategory(category);
        }
        return areas;
    }, areas);
}
exports.convertWireAreasToAreas = convertWireAreasToAreas;
function convertAreaCoordsToCoordsMap(coords, _a) {
    var e_2, _b, e_3, _c;
    var _d = __read(_a, 2), width = _d[0], height = _d[1];
    var coordsMap = [];
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            if (!coordsMap[y]) {
                coordsMap[y] = [];
            }
            coordsMap[y][x] = false;
        }
    }
    try {
        for (var coords_1 = __values(coords), coords_1_1 = coords_1.next(); !coords_1_1.done; coords_1_1 = coords_1.next()) {
            var bbox = coords_1_1.value;
            var positions = (0, Position_1.getPosFromBoundingBox)(bbox, width, height);
            try {
                for (var positions_1 = (e_3 = void 0, __values(positions)), positions_1_1 = positions_1.next(); !positions_1_1.done; positions_1_1 = positions_1.next()) {
                    var _e = positions_1_1.value, x = _e.x, y = _e.y;
                    coordsMap[y][x] = true;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (positions_1_1 && !positions_1_1.done && (_c = positions_1["return"])) _c.call(positions_1);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (coords_1_1 && !coords_1_1.done && (_b = coords_1["return"])) _b.call(coords_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return coordsMap;
}
exports.convertAreaCoordsToCoordsMap = convertAreaCoordsToCoordsMap;
function convertDBDesksCoordsToCoordsMap(dbDesks, _a) {
    var e_4, _b, e_5, _c, e_6, _d;
    var _e = __read(_a, 2), width = _e[0], height = _e[1];
    var coordsMap = [];
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            if (!coordsMap[y]) {
                coordsMap[y] = [];
            }
            coordsMap[y][x] = "";
        }
    }
    try {
        for (var _f = __values(Object.keys(dbDesks)), _g = _f.next(); !_g.done; _g = _f.next()) {
            var deskId = _g.value;
            var coords = dbDesks[deskId].coords;
            try {
                for (var coords_2 = (e_5 = void 0, __values(coords)), coords_2_1 = coords_2.next(); !coords_2_1.done; coords_2_1 = coords_2.next()) {
                    var bbox = coords_2_1.value;
                    var positions = (0, Position_1.getPosFromBoundingBox)(bbox, width, height);
                    try {
                        for (var positions_2 = (e_6 = void 0, __values(positions)), positions_2_1 = positions_2.next(); !positions_2_1.done; positions_2_1 = positions_2.next()) {
                            var _h = positions_2_1.value, x = _h.x, y = _h.y;
                            coordsMap[y][x] = deskId;
                        }
                    }
                    catch (e_6_1) { e_6 = { error: e_6_1 }; }
                    finally {
                        try {
                            if (positions_2_1 && !positions_2_1.done && (_d = positions_2["return"])) _d.call(positions_2);
                        }
                        finally { if (e_6) throw e_6.error; }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (coords_2_1 && !coords_2_1.done && (_c = coords_2["return"])) _c.call(coords_2);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_g && !_g.done && (_b = _f["return"])) _b.call(_f);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return coordsMap;
}
exports.convertDBDesksCoordsToCoordsMap = convertDBDesksCoordsToCoordsMap;
function generateEmptyDeskCoordsMap(_a) {
    var _b = __read(_a, 2), width = _b[0], height = _b[1];
    var coordsMap = [];
    for (var y = 0; y < height; y++) {
        for (var x = 0; x < width; x++) {
            if (!coordsMap[y]) {
                coordsMap[y] = [];
            }
            coordsMap[y][x] = "";
        }
    }
    return coordsMap;
}
exports.generateEmptyDeskCoordsMap = generateEmptyDeskCoordsMap;
function convertDBDesksToDesks(dbDesks, dimensions) {
    if (dimensions === undefined) {
        throw new Error("Cannot convert db desks to desks because dimensions are undefined");
    }
    var coordsMap = convertDBDesksCoordsToCoordsMap(dbDesks, dimensions);
    var idsMap = Object.keys(dbDesks).reduce(function (idsMap, deskId) {
        var _a;
        var coords = dbDesks[deskId].coords;
        var positions = coords.reduce(function (positions, bbox) { return __spreadArray(__spreadArray([], __read(positions), false), __read((0, Position_1.getPosFromBoundingBox)(bbox)), false); }, []);
        return __assign(__assign({}, idsMap), (_a = {}, _a[deskId] = positions, _a));
    }, {});
    return { coordsMap: coordsMap, idsMap: idsMap };
}
exports.convertDBDesksToDesks = convertDBDesksToDesks;
function convertDesksToDBDesks(desks) {
    var idsMap = desks.idsMap;
    var dbDesks = Object.keys(idsMap).reduce(function (dbDesks, deskId) {
        var _a;
        var bboxes = convertCoordsToBBoxes(idsMap[deskId]);
        return __assign(__assign({}, dbDesks), (_a = {}, _a[deskId] = { coords: bboxes }, _a));
    }, {});
    return dbDesks;
}
exports.convertDesksToDBDesks = convertDesksToDBDesks;
function convertCoordsToBBoxes(coords) {
    var coordsSet = new Set(coords.map(function (coord) { return (0, Position_1.serializePosition)(coord); }));
    var expandRect = function (bbox) {
        var x1 = bbox.x1, x2 = bbox.x2, y1 = bbox.y1, y2 = bbox.y2;
        var expanded = true;
        while (expanded) {
            expanded = false;
            var rightCoords = (0, lodash_1.range)(y1, y2 + 1).map(function (newY) { return ({ x: x2 + 1, y: newY }); });
            if (rightCoords.every(function (coord) { return coordsSet.has((0, Position_1.serializePosition)(coord)); })) {
                x2 += 1;
                rightCoords.forEach(function (coord) {
                    coordsSet["delete"]((0, Position_1.serializePosition)(coord));
                });
                expanded = true;
            }
            var bottomCoords = (0, lodash_1.range)(x1, x2 + 1).map(function (newX) { return ({ x: newX, y: y2 + 1 }); });
            if (bottomCoords.every(function (coord) { return coordsSet.has((0, Position_1.serializePosition)(coord)); })) {
                y2 += 1;
                bottomCoords.forEach(function (coord) {
                    coordsSet["delete"]((0, Position_1.serializePosition)(coord));
                });
                expanded = true;
            }
            var leftCoords = (0, lodash_1.range)(y1, y2 + 1).map(function (newY) { return ({ x: x1 - 1, y: newY }); });
            if (leftCoords.every(function (coord) { return coordsSet.has((0, Position_1.serializePosition)(coord)); })) {
                x1 -= 1;
                leftCoords.forEach(function (coord) {
                    coordsSet["delete"]((0, Position_1.serializePosition)(coord));
                });
                expanded = true;
            }
            var topCoords = (0, lodash_1.range)(x1, x2 + 1).map(function (newX) { return ({ x: newX, y: y1 - 1 }); });
            if (topCoords.every(function (coord) { return coordsSet.has((0, Position_1.serializePosition)(coord)); })) {
                y1 -= 1;
                topCoords.forEach(function (coord) {
                    coordsSet["delete"]((0, Position_1.serializePosition)(coord));
                });
                expanded = true;
            }
        }
        return { x1: x1, x2: x2, y1: y1, y2: y2 };
    };
    var bboxes = [];
    while (coordsSet.size !== 0) {
        var coord = __spreadArray([], __read(Array.from(coordsSet)), false).pop() || "";
        coordsSet["delete"](coord);
        var _a = (0, Position_1.deserializePosition)(coord), x = _a.x, y = _a.y;
        var bbox = expandRect({ x1: x, x2: x, y1: y, y2: y });
        bboxes.push(bbox);
    }
    return bboxes;
}
exports.convertCoordsToBBoxes = convertCoordsToBBoxes;
function convertStringToAreaCategory(areaCategory) {
    if (!(areaCategory in AreaCategory)) {
        throw "Invalid area category";
    }
    return areaCategory;
}
var TileType;
(function (TileType) {
    TileType[TileType["Impassable"] = 1] = "Impassable";
    TileType[TileType["Spawn"] = 2] = "Spawn";
    TileType[TileType["Portal"] = 3] = "Portal";
    TileType[TileType["Announcer"] = 4] = "Announcer";
    TileType[TileType["Space"] = 5] = "Space";
    TileType[TileType["Desk"] = 6] = "Desk";
})(TileType = exports.TileType || (exports.TileType = {}));
var MODAL_INTERACTIONS = [
    events_1.InteractionEnum_ENUM.EMBEDDED_WEBSITE,
    events_1.InteractionEnum_ENUM.POSTER,
    events_1.InteractionEnum_ENUM.VIDEO,
    events_1.InteractionEnum_ENUM.EXTERNAL_CALL,
    events_1.InteractionEnum_ENUM.NOTE,
    events_1.InteractionEnum_ENUM.MODAL_EXTENSION,
    events_1.InteractionEnum_ENUM.COMPONENT_MODAL,
];
function interactionOpensModal(i) {
    return MODAL_INTERACTIONS.includes(i);
}
exports.interactionOpensModal = interactionOpensModal;
function areaToCoords(coordsMap) {
    var coords = [];
    for (var y = 0; y < coordsMap.length; y++) {
        for (var x = 0; x < coordsMap[0].length; x++) {
            if (coordsMap[y][x] === true) {
                coords.push({ x: x, y: y });
            }
        }
    }
    return coords;
}
exports.areaToCoords = areaToCoords;
var EnabledChat;
(function (EnabledChat) {
    EnabledChat["GLOBAL_CHAT"] = "GLOBAL_CHAT";
    EnabledChat["LOCAL_CHAT"] = "LOCAL_CHAT";
    EnabledChat["ROOM_CHAT"] = "ROOM_CHAT";
})(EnabledChat = exports.EnabledChat || (exports.EnabledChat = {}));
var wallFloorConvertFromDB = function (data, dims, isWall) {
    var newFormat = [];
    Object.keys(data).forEach(function (type) {
        var dataBytes = buffer_1.Buffer.from(data[type], "base64");
        for (var i = 0; i < dims[0]; i++) {
            for (var j = 0; j < dims[1]; j++) {
                if (dataBytes[j * dims[0] + i] === 0x01) {
                    var temp = {
                        x: i,
                        y: j
                    };
                    if (isWall) {
                        temp["wallType"] = parseInt(type);
                    }
                    else {
                        temp["floorType"] = parseInt(type);
                    }
                    newFormat.push(temp);
                }
            }
        }
    });
    return newFormat;
};
exports.wallFloorConvertFromDB = wallFloorConvertFromDB;
var wallFloorConvertToDB = function (data, dims) {
    var newFormat = {};
    data.forEach(function (point) {
        var type = point["floorType"] || point["wallType"];
        if (!(type in newFormat)) {
            newFormat[type] = new Array(dims[0] * dims[1]).fill(0x00);
        }
        newFormat[type][point.y * dims[0] + point.x] = 0x01;
    });
    Object.keys(newFormat).forEach(function (type) {
        newFormat[type] = buffer_1.Buffer.from(newFormat[type]).toString("base64");
    });
    return newFormat;
};
exports.wallFloorConvertToDB = wallFloorConvertToDB;
function convertStringToEnabledChat(enabledChat) {
    if (!(enabledChat in EnabledChat)) {
        throw new Error("Invalid enabled chat");
    }
    return enabledChat;
}
exports.convertStringToEnabledChat = convertStringToEnabledChat;
var PresetTutorialGroupSetIds;
(function (PresetTutorialGroupSetIds) {
    PresetTutorialGroupSetIds["ONBOARDING_SANDBOX"] = "ONBOARDING_SANDBOX";
})(PresetTutorialGroupSetIds = exports.PresetTutorialGroupSetIds || (exports.PresetTutorialGroupSetIds = {}));
function convertWireTutorialTasksToTutorialTasks(wireTutorialTasks) {
    var groupSetId = convertStringToPresetTutorialGroupSetId(wireTutorialTasks.groupSetId);
    return __assign(__assign({}, wireTutorialTasks), { groupSetId: groupSetId });
}
exports.convertWireTutorialTasksToTutorialTasks = convertWireTutorialTasksToTutorialTasks;
function convertTutorialTasksToWireTutorialTasks(tutorialTasks) {
    var _a;
    return __assign(__assign({}, tutorialTasks), { areas: (_a = tutorialTasks.areas) !== null && _a !== void 0 ? _a : [] });
}
exports.convertTutorialTasksToWireTutorialTasks = convertTutorialTasksToWireTutorialTasks;
function convertStringToPresetTutorialGroupSetId(presetTutorialGroupSetId) {
    if (!(presetTutorialGroupSetId in PresetTutorialGroupSetIds)) {
        throw new Error("Invalid presetTutorialGroupSetId");
    }
    return presetTutorialGroupSetId;
}
exports.convertStringToPresetTutorialGroupSetId = convertStringToPresetTutorialGroupSetId;
function verifyMapIsComplete(map) {
    var verifyMapIsCompleteHelper = function (map) {
        if (map.id != null &&
            map.dimensions != null &&
            map.collisions != null &&
            map.backgroundImagePath != null &&
            map.spaces != null &&
            map.spawns != null &&
            map.portals != null &&
            map.announcer != null) {
            return __assign(__assign({}, map), { id: map.id, dimensions: map.dimensions, collisions: map.collisions, backgroundImagePath: map.backgroundImagePath, spaces: map.spaces, spawns: map.spawns, portals: map.portals, announcer: map.announcer });
        }
        return null;
    };
    return verifyMapIsCompleteHelper(map) !== null;
}
exports.verifyMapIsComplete = verifyMapIsComplete;
exports.MAP_MAX_DIMENSION = 9999;
//# sourceMappingURL=GameMap.js.map