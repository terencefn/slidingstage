import { manhattanDistance, Position } from "./Position";

import {
  DBOutfit,
  DeskInfoV2,
  Inventory,
  MoveDirectionEnum_ENUM as MoveDirection,
  SpriteDirectionEnum_ENUM as SpriteDirection,
} from "./generated_DO_NOT_TOUCH/events";
import * as zod from "zod";

export { SpriteDirection, MoveDirection };

export const ZodDBOutfit = zod.object({
  skin: zod.string(),
  hair: zod.string(),
  facial_hair: zod.string(),
  top: zod.string(),
  bottom: zod.string(),
  shoes: zod.string(),
  hat: zod.string(),
  glasses: zod.string(),
  other: zod.string(),
  costume: zod.string().optional(),
  mobility: zod.string().optional(),
  jacket: zod.string().optional(),
});

// types shared between MemberInfo and Player
export interface BaseRoomUserDB {
  allowScreenPointer?: boolean;
  currentlyEquippedWearables?: DBOutfit;
  // TODO OCTO-177: this is technically incorrect, clean up (see Linear for details)
  deskInfo?: DeskInfoV2;
  inventory?: Inventory;
  name?: string;
}

// This is the schema for player info persisted to the db. These fields are stored in the
// `rooms/users` collection, and should be set through actions sent to the game server:
// `gameSpace.setPlayerRoomInfo`.
// Right now everything is optional, because we don't have any real guarantees the data in the
// DB is actually not null.
// If you add something here, it will be persisted to the DB. Also make sure add it to the
// `PlayerDBFields` class below.
// (This will eventually be generated from Prisma.)
export interface PlayerDB extends BaseRoomUserDB {
  affiliation?: string;
  allowScreenPointer?: boolean;
  busy?: boolean;
  connected?: boolean;
  currentDesk?: string;
  description?: string;
  // TODO OCTO-177: this is technically incorrect, clean up (see Linear for details)
  deskInfo?: DeskInfoV2;
  emojiStatus?: string;
  focusModeEndTime?: string;
  inventory?: Inventory;
  isNpc?: boolean;
  itemString?: string;
  map?: string;
  name?: string;
  personalImageUrl?: string;
  phone?: string;
  profileImageUrl?: string;
  pronouns?: string;
  textStatus?: string;
  timezone?: string;
  title?: string;
  x?: number;
  y?: number;
}

// This is currently redundant to PlayerDB, but there will come a time when not all fields on
// PlayerDB are optional, and then the partial type will become more significant.
export type PlayerDBPartial = Partial<PlayerDB>;

// This class is used for runtime checking of the fields on a data blob passed to the game-server.
// It needs to be a class that implements the type, so we can instantiate a dummy object and then
// do runtime checks about the fields on the incoming payload, e.g. iterating across the keys
// of the dummy object fields and validating things about the payload.
// It also serves as the base class to `Player` which is used to create a default Player object.
// These are fields that are part of the schema, so default values here will be the default
// values persisted to the DB.
export class PlayerDBFields implements PlayerDB {
  affiliation = "";
  allowScreenPointer = true;
  busy = false;
  connected = false;
  currentDesk = "";
  // have to set this as undefined so the field exists on an instance of PlayerDBFields
  currentlyEquippedWearables?: DBOutfit = undefined;
  description = "";
  // TODO OCTO-177: this is technically incorrect, clean up (see Linear for details)
  deskInfo: DeskInfoV2 = { deskId: "" };
  emojiStatus = "";
  focusModeEndTime = "";
  inventory: Inventory = { items: {}, order: {} };
  isNpc = false;
  itemString = "";
  map = "";
  name = "";
  personalImageUrl = "";
  phone = "";
  profileImageUrl = "";
  pronouns = "";
  textStatus = "";
  timezone = "";
  title = "";
  x = 0;
  y = 0;
}

// Player is what the server and client use in-memory, not necessarily what is stored in the DB.
// Look to the PlayerDB to get the DB schema.
export class Player extends PlayerDBFields {
  // currentlyEquippedWearables doesn't exist on Player, it gets converted to `outfitString`.
  // we have to explicitly declare this prop will be undefined, since we're inheriting from the base
  currentlyEquippedWearables?: undefined;

  direction: SpriteDirection = SpriteDirection.Down;
  ghost = 0;
  spotlighted = 0;
  emote: string | undefined = undefined;
  // TODO: (@josh and @a-lchen) Use boolean rather than number (and transform to bool in the selector)
  workCondition = 1;
  away = false;
  activelySpeaking = 0;
  lastActive = "";
  lastInputId = 0;
  whisperId = "";
  isSignedIn = false;
  outfitString = ""; // todo @a-lchen fix this when we can
  eventStatus = "";
  inConversation = false;
  currentArea = "";
  vehicleId = "";
  speedModifier = 1;
  isAlone = true;
  isMobile = false;
  followTarget = "";
  manualVideoSrc = "";
  manualDefaultVideoImageSrc = "";
  manualScreenSrc = "";
  subtitle = "";

  constructor() {
    super();
    // we check the `in` keyword, so we can't have the field on the object at all
    // Since we're extending from a class that has it set as `undefined`, we need to do a little
    // extra here.
    delete this.currentlyEquippedWearables;
  }
}

// The defaults in the constructor above are used server-side, the defaults below are used client side.
// The difference is often because of how we want to render not-fully initialized players (i.e. off-map)

// Returns an instance of a player with fields set to default values.
// These values are just placeholder until the player's position is reported over the wire.
// (We use arbitrary numbers here instead of `-Infinity` to avoid math/NaN issues within Phaser.)
export const generateDefaultPlayer = (): Player => {
  const player = new Player();
  player.x = -99999;
  player.y = -99999;
  player.emote = "";
  player.workCondition = 0;
  player.away = true;
  player.lastActive = new Date().toISOString();
  player.connected = true;
  return player;
};

/**
 * Emotes that have a special function inside the app (e.g. when two players emote with Wave, they high five each other)
 */
export enum Emote {
  None,
  Wave,
  Heart,
  PartyPopper,
  RaisedHand,
}

/**
 * Emojis that correspond to "special" emotes in the app (see above)
 */
export const EMOTE_EMOJIS = {
  [Emote.Wave]: "ðŸ‘‹",
  [Emote.Heart]: "â¤ï¸",
  [Emote.PartyPopper]: "ðŸŽ‰",
  [Emote.RaisedHand]: "ðŸ¤š",
};

/** Keyboard shortcut to clear the user's current emote */
export const EMOTE_RESET_SHORTCUT = "0";
/** Keys a user can use as a shortcut to emote */
export const EMOTE_SHORTCUTS = [EMOTE_RESET_SHORTCUT, "1", "2", "3", "4", "5", "6"];

/** The default list of emotes loaded for a user. They are "temp" because the user can customize this list in the app */
export const DEFAULT_TEMP_EMOTES = ["ðŸ‘‹", "â¤ï¸", "ðŸŽ‰", "ðŸ‘", "ðŸ˜‚"];

export function getMoveDirFromSpriteDir(direction: SpriteDirection) {
  switch (direction) {
    case SpriteDirection.Dance1:
    case SpriteDirection.Dance2:
    case SpriteDirection.Dance3:
    case SpriteDirection.Dance4:
      return MoveDirection.Dance;

    case SpriteDirection.Down:
    case SpriteDirection.DownAlt:
      return MoveDirection.Down;

    case SpriteDirection.Up:
    case SpriteDirection.UpAlt:
      return MoveDirection.Up;

    case SpriteDirection.Left:
    case SpriteDirection.LeftAlt:
      return MoveDirection.Left;

    case SpriteDirection.Right:
    case SpriteDirection.RightAlt:
      return MoveDirection.Right;

    default:
      return null;
  }
}

export function oppositeMoveDirection(direction: MoveDirection): MoveDirection | null {
  switch (direction) {
    case MoveDirection.Left:
      return MoveDirection.Right;
    case MoveDirection.Right:
      return MoveDirection.Left;
    case MoveDirection.Up:
      return MoveDirection.Down;
    case MoveDirection.Down:
      return MoveDirection.Up;
    default:
      return null;
  }
}

export const positionAfterMove = (
  start: Position,
  dir: MoveDirection | null,
  dist = 1,
): Position => {
  const { x, y } = start;
  switch (dir) {
    case MoveDirection.Left:
      return { x: x - dist, y };
    case MoveDirection.Right:
      return { x: x + dist, y };
    case MoveDirection.Up:
      return { x, y: y - dist };
    case MoveDirection.Down:
      return { x, y: y + dist };
    default:
      return start;
  }
};

// Returns the next SpriteDirection to use after applying the given MoveDirection.
export function nextSpriteDirection(
  current: SpriteDirection,
  direction: MoveDirection,
): SpriteDirection {
  if (direction === MoveDirection.Left && current === SpriteDirection.Left) {
    return SpriteDirection.LeftAlt;
  } else if (direction === MoveDirection.Right && current === SpriteDirection.Right) {
    return SpriteDirection.RightAlt;
  } else if (direction === MoveDirection.Up && current === SpriteDirection.Up) {
    return SpriteDirection.UpAlt;
  } else if (direction === MoveDirection.Down && current === SpriteDirection.Down) {
    return SpriteDirection.DownAlt;
  } else if (direction === MoveDirection.Dance && current === SpriteDirection.Dance1) {
    return SpriteDirection.Dance2;
  } else if (direction === MoveDirection.Dance && current === SpriteDirection.Dance2) {
    return SpriteDirection.Dance3;
  } else if (direction === MoveDirection.Dance && current === SpriteDirection.Dance3) {
    return SpriteDirection.Dance4;
  } else if (direction === MoveDirection.Left) {
    return SpriteDirection.Left;
  } else if (direction === MoveDirection.Right) {
    return SpriteDirection.Right;
  } else if (direction === MoveDirection.Up) {
    return SpriteDirection.Up;
  } else if (direction === MoveDirection.Down) {
    return SpriteDirection.Down;
  } else if (direction === MoveDirection.Dance) {
    return SpriteDirection.Dance1;
  }
  return current;
}

// direction for player to face target when next to eachother
export function directionToFacePlayer(player: Player, target: Player): MoveDirection | null {
  if (manhattanDistance(player, target) !== 1) return null;

  if (player.x - target.x === 1) {
    return MoveDirection.Left;
  } else if (player.x - target.x === -1) {
    return MoveDirection.Right;
  } else if (player.y - target.y === 1) {
    return MoveDirection.Up;
  } else if (player.y - target.y === -1) {
    return MoveDirection.Down;
  }
  return null;
}

// whisperId is either in format #XXXXXX or a uuid4
export function whisperIdToColor(id: string): string {
  if (id.length === 7) return id;

  return "#" + id.slice(0, 6);
}

export const CONSTANT_PERMANENT_EMOTES = [EMOTE_EMOJIS[Emote.RaisedHand]];

export const keyPressedToEmote = (keycode: number, emotesArray: string[]) =>
  emotesArray[keycode - 1];

export const getAllEmotes = (tempEmotes: string[]) => [...tempEmotes, ...CONSTANT_PERMANENT_EMOTES];

export enum VehicleAction {
  Mount = "mount",
  Dismount = "dismount",
}
