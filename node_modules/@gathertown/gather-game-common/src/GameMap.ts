// Note: When adding to or modifying these types, please also adjust the types in modules/gather-http-server/src/v2/db/spaceRoom.ts
import { cloneDeep, range } from "lodash";
import { Buffer } from "buffer";

import {
  BoundingBox,
  deserializePosition,
  getPosFromBoundingBox,
  Position,
  serializePosition,
} from "./Position";
import {
  Announcer,
  AreaPosition,
  Asset,
  InteractionEnum_ENUM as Interaction,
  WireObject,
  WireArea,
  Point,
  Portal,
  Space,
  SpawnPoint,
  TutorialTaskMapArea,
  WireTutorialTasks,
  DBDesk,
} from "./generated_DO_NOT_TOUCH/events";
export { Interaction };

// Ideally we will consolidate this in a single place, but for now we have to manually sync them.
interface GameMapBase {
  id: string;
  /**
   * Dimensions here are set in _grid_ coordinates.
   * To convert to pixel sizes/world space, multiply these dimensions by `objectSizes`.
   */
  dimensions: [number, number];
  backgroundImagePath: string; // url
  foregroundImagePath?: string;
  sprites?: number[];
  spaces: Space[];
  spawn?: Point; // TODO remove
  spawns: SpawnPoint[];
  portals: Portal[];
  announcer: Announcer[];
  assets?: Asset[];
  name?: string; //What is the map actually called
  muteOnEntry?: boolean;
  useDrawnBG?: boolean;
  walls?: WallFloorBlock[];
  floors?: WallFloorBlock[];
  mostRecentUpdateId?: number;
  areas?: Areas;
  miniMapImagePath?: string;
  enabledChats?: EnabledChat[];
  description?: string;
  decoration?: string;
  tutorialTasks?: TutorialTasks;
  updatedAt?: string;
  script?: string;
  desks?: Desks;
}

/**
 * @deprecated see GameMapV2
 */
export interface GameMap extends GameMapBase {
  collisions: string; // base64 encoded array of dimensions[1] x dimensions[0] bytes
  objects?: MapObject[];
}

export interface GameMapDB extends Omit<GameMapBase, "walls" | "floors" | "areas" | "desks"> {
  walls?: WallFloorDB;
  floors?: WallFloorDB;
  areas?: DBAreas;
  desks?: DBDesks;
  collisions: string; // base64 encoded array of dimensions[1] x dimensions[0] bytes
  objects?: MapObjectDB[];
}

export interface GameMapV2 extends GameMapBase {
  collisions: boolean[][]; // collisions[y][x] === true if tile at x,y is impassable
  objects?: { [key: number]: MapObject };
}

export class WallBlock {
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  x: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  y: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  wallType: number;
}

export class FloorBlock {
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  x: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  y: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  floorType: number;
}

export type WallFloorBlock = WallBlock | FloorBlock;

/*
  In code logic, walls and floors are represented as WallBlock or Floorblock
  In Firestore, for the sake of memory, it is represented as a map:
  {
    floorWallType1 (string): bytearray (string),
    floorWallType2 (string): bytearray (string),
    ...
  }
  where the bytearray is 0x01 if a wall/floor exists there, and 0x00 otherwise
  (like collisions)
*/
export class WallFloorDB {
  [type: string]: string;
}

export class Tile {
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  x: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  y: number;
  // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
  // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
  tileType: TileType;
  info?: Space | Portal;
}

type MakeFieldsRequired<T, K extends keyof T> = Required<Pick<T, K>> & T;
type WireMapObjectRequiredFields = "x" | "y" | "normal" | "type" | "width" | "height";
type WireObjectWithRequireds = MakeFieldsRequired<WireObject, WireMapObjectRequiredFields>;

// WireObject is defined in events.proto, but uses only optional types, a stringified json for
// an object properties, and a default of empty array for tags, so we replace those here
export interface MapObjectDB extends Omit<WireObjectWithRequireds, "propertiesJson" | "_tags"> {
  _tags?: string[];
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  properties?: Record<string, any>;
}

export interface MapObject extends MapObjectDB {
  key?: number;
}

// Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function findMissingMapObjectFields(object: any) {
  const requiredFields = ["x", "y", "normal", "type", "width", "height"];
  const missingFields: string[] = [];
  for (const field of requiredFields) {
    if (object[field] === undefined) {
      missingFields.push(field);
    }
  }
  return missingFields;
}

// Note: this function is safe only because we use findMissingMapObjectFields
export function convertWireObjectToMapObjectDB(wireObject: WireObject): MapObjectDB {
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const mapObject: any = cloneDeep(wireObject);
  if (wireObject.propertiesJson) {
    mapObject.properties = JSON.parse(wireObject.propertiesJson);
    delete mapObject.propertiesJson;
  }
  if (wireObject._tags && wireObject._tags.length === 0) {
    delete mapObject._tags;
  }
  if (wireObject.type == null) {
    mapObject.type = 0;
  }
  const missingFields = findMissingMapObjectFields(mapObject);
  if (missingFields.length > 0) {
    throw `Failed to convert to MapObject because the following required fields were missing: ${missingFields}`;
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return mapObject as MapObjectDB;
}
export function convertWireObjectToMapObject(wireObject: WireObject, key: number): MapObject {
  // this cast is unfortunate because if these types diverge more it will silently become unsafe
  // but this is a kinda hot path so I don't want to properly rebuild the object.
  // we can stop doing this once everything treats the objects as a dict and `key` is just the key
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  const obj = convertWireObjectToMapObjectDB(wireObject) as MapObject;
  obj.key = key;
  return obj;
}

export function convertMapObjectToWireObject(mapObject: Partial<MapObjectDB>): WireObject {
  // Error ignored when enabling the no-explicit-any lint rule. PLEASE HELP FIX THESE! YES, YOU. Delete this and fix the error OR explain why the any type is safe / necessary.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const wireObject: any = cloneDeep(mapObject);
  if (mapObject.properties) {
    wireObject.propertiesJson = JSON.stringify(mapObject.properties);
    delete wireObject.properties;
  }
  if (!mapObject._tags) {
    wireObject._tags = [];
  }
  return wireObject;
}

export enum AreaCategory {
  RW_OFFICE_LOBBY = "RW_OFFICE_LOBBY",
  RW_OFFICE_MEETING = "RW_OFFICE_MEETING",
  COWORKING = "COWORKING",
}

export interface BaseArea {
  category?: AreaCategory;
}

// see comment above
export interface DBArea extends BaseArea {
  coords: AreaPosition[];
}

export interface DBAreas {
  [name: string]: DBArea;
}

export interface Area extends BaseArea {
  coordsMap: boolean[][];
}

export interface Areas {
  [name: string]: Area;
}

interface WireAreas {
  [name: string]: WireArea;
}

export interface DBDesks {
  [deskId: string]: DBDesk;
}
export interface Desks {
  // 2D array of space, contains desk ID or empty string if no desk
  coordsMap: string[][];
  // map of deskId to the list of coordinates of the desk
  idsMap: { [deskId: string]: Position[] };
}

export function convertWireAreasToDBAreas(wireAreas: WireAreas): DBAreas {
  const dbAreas: DBAreas = {};
  return Object.keys(wireAreas).reduce((dbAreas, areaName) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords, category } = wireAreas[areaName];
    dbAreas[areaName] = { coords };
    if (category) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      dbAreas[areaName].category = convertStringToAreaCategory(category);
    }
    return dbAreas;
  }, dbAreas);
}

export function convertWireAreasToAreas(
  wireAreas: WireAreas,
  dimensions: number[] | undefined,
): Areas {
  if (dimensions === undefined) {
    throw new Error("Cannot convert wire areas to areas because dimensions are undefined");
  }
  const areas: Areas = {};
  return Object.keys(wireAreas).reduce((areas, areaName) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords, category } = wireAreas[areaName];
    const coordsMap = convertAreaCoordsToCoordsMap(coords, dimensions);
    areas[areaName] = { coordsMap };
    if (category) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      areas[areaName].category = convertStringToAreaCategory(category);
    }
    return areas;
  }, areas);
}

export function convertAreaCoordsToCoordsMap(
  coords: AreaPosition[],
  [width, height]: number[],
): boolean[][] {
  const coordsMap: boolean[][] = [];
  // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
  // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
  for (let y = 0; y < height; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < width; x++) {
      if (!coordsMap[y]) {
        coordsMap[y] = [];
      }
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = false;
    }
  }

  for (const bbox of coords) {
    const positions = getPosFromBoundingBox(bbox, width, height);
    for (const { x, y } of positions) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = true;
    }
  }
  return coordsMap;
}

export function convertDBDesksCoordsToCoordsMap(dbDesks: DBDesks, [width, height]: number[]) {
  const coordsMap: string[][] = [];
  // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
  // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
  for (let y = 0; y < height; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < width; x++) {
      if (!coordsMap[y]) {
        coordsMap[y] = [];
      }
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = "";
    }
  }

  for (const deskId of Object.keys(dbDesks)) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords } = dbDesks[deskId];

    for (const bbox of coords) {
      const positions = getPosFromBoundingBox(bbox, width, height);
      for (const { x, y } of positions) {
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        coordsMap[y][x] = deskId;
      }
    }
  }
  return coordsMap;
}

export function generateEmptyDeskCoordsMap([width, height]: number[]) {
  const coordsMap: string[][] = [];
  // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
  // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
  for (let y = 0; y < height; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < width; x++) {
      if (!coordsMap[y]) {
        coordsMap[y] = [];
      }
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      coordsMap[y][x] = "";
    }
  }
  return coordsMap;
}

export function convertDBDesksToDesks(dbDesks: DBDesks, dimensions: number[] | undefined): Desks {
  if (dimensions === undefined) {
    throw new Error("Cannot convert db desks to desks because dimensions are undefined");
  }
  const coordsMap = convertDBDesksCoordsToCoordsMap(dbDesks, dimensions);
  const idsMap = Object.keys(dbDesks).reduce((idsMap, deskId) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const { coords } = dbDesks[deskId];
    const positions = coords.reduce(
      // @ts-expect-error Error auto-ignored when enabling TS strict. It's possible this is incorrect.
      // TODO: @ENG-4193 Clean these up! If you're already touching this code, please clean this up while you're at it.
      (positions, bbox) => [...positions, ...getPosFromBoundingBox(bbox)],
      [],
    );
    return { ...idsMap, [deskId]: positions };
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  }, {} as { [deskId: string]: Position[] });
  return { coordsMap, idsMap };
}

export function convertDesksToDBDesks(desks: Desks): DBDesks {
  const { idsMap } = desks;

  const dbDesks = Object.keys(idsMap).reduce((dbDesks, deskId) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const bboxes = convertCoordsToBBoxes(idsMap[deskId]);
    return { ...dbDesks, [deskId]: { coords: bboxes } };
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  }, {} as DBDesks);

  return dbDesks;
}

export function convertCoordsToBBoxes(coords: Position[]) {
  const coordsSet = new Set(coords.map((coord) => serializePosition(coord)));

  const expandRect = (bbox: BoundingBox): BoundingBox => {
    let { x1, x2, y1, y2 } = bbox;
    let expanded = true;
    while (expanded) {
      expanded = false;
      // expand right
      const rightCoords = range(y1, y2 + 1).map((newY) => ({ x: x2 + 1, y: newY }));
      if (rightCoords.every((coord) => coordsSet.has(serializePosition(coord)))) {
        x2 += 1;
        rightCoords.forEach((coord) => {
          coordsSet.delete(serializePosition(coord));
        });
        expanded = true;
      }

      // expand bottom
      const bottomCoords = range(x1, x2 + 1).map((newX) => ({ x: newX, y: y2 + 1 }));
      if (bottomCoords.every((coord) => coordsSet.has(serializePosition(coord)))) {
        y2 += 1;
        bottomCoords.forEach((coord) => {
          coordsSet.delete(serializePosition(coord));
        });
        expanded = true;
      }

      // expand left
      const leftCoords = range(y1, y2 + 1).map((newY) => ({ x: x1 - 1, y: newY }));
      if (leftCoords.every((coord) => coordsSet.has(serializePosition(coord)))) {
        x1 -= 1;
        leftCoords.forEach((coord) => {
          coordsSet.delete(serializePosition(coord));
        });
        expanded = true;
      }

      // expand top
      const topCoords = range(x1, x2 + 1).map((newX) => ({ x: newX, y: y1 - 1 }));
      if (topCoords.every((coord) => coordsSet.has(serializePosition(coord)))) {
        y1 -= 1;
        topCoords.forEach((coord) => {
          coordsSet.delete(serializePosition(coord));
        });
        expanded = true;
      }
    }
    return { x1, x2, y1, y2 };
  };

  const bboxes: BoundingBox[] = [];
  while (coordsSet.size !== 0) {
    const coord = [...Array.from(coordsSet)].pop() || "";
    coordsSet.delete(coord);
    const { x, y } = deserializePosition(coord);
    const bbox = expandRect({ x1: x, x2: x, y1: y, y2: y });
    bboxes.push(bbox);
  }
  return bboxes;
}

function convertStringToAreaCategory(areaCategory: string): AreaCategory {
  if (!(areaCategory in AreaCategory)) {
    throw "Invalid area category";
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return areaCategory as AreaCategory;
}

export enum TileType {
  Impassable = 1,
  Spawn,
  Portal,
  Announcer,
  Space,
  Desk,
}

const MODAL_INTERACTIONS = [
  Interaction.EMBEDDED_WEBSITE,
  Interaction.POSTER,
  Interaction.VIDEO,
  Interaction.EXTERNAL_CALL,
  Interaction.NOTE,
  Interaction.MODAL_EXTENSION,
  Interaction.COMPONENT_MODAL,
] as const;

export type ModalInteraction = typeof MODAL_INTERACTIONS[number];

export function interactionOpensModal(i: Interaction) {
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return (MODAL_INTERACTIONS as readonly Interaction[]).includes(i);
}

export function areaToCoords(coordsMap: boolean[][]) {
  const coords: Position[] = [];
  for (let y = 0; y < coordsMap.length; y++) {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let x = 0; x < coordsMap[0].length; x++) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      if (coordsMap[y][x] === true) {
        coords.push({ x, y });
      }
    }
  }
  return coords;
}

export enum EnabledChat {
  GLOBAL_CHAT = "GLOBAL_CHAT",
  LOCAL_CHAT = "LOCAL_CHAT",
  ROOM_CHAT = "ROOM_CHAT",
}

export const wallFloorConvertFromDB: (
  data: WallFloorDB,
  dims: number[],
  isWall: boolean,
) => WallFloorBlock[] = (data, dims, isWall) => {
  const newFormat: WallFloorBlock[] = [];
  Object.keys(data).forEach((type) => {
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    const dataBytes = Buffer.from(data[type], "base64");
    // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
    // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
    for (let i = 0; i < dims[0]; i++) {
      // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
      // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
      for (let j = 0; j < dims[1]; j++) {
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        if (dataBytes[j * dims[0] + i] === 0x01) {
          const temp = {
            x: i,
            y: j,
          };
          if (isWall) {
            // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
            // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
            temp["wallType"] = parseInt(type);
          } else {
            // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
            // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
            temp["floorType"] = parseInt(type);
          }
          // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
          // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
          // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
          newFormat.push(temp as WallFloorBlock);
        }
      }
    }
  });
  return newFormat;
};

export const wallFloorConvertToDB: (data: WallFloorBlock[], dims: number[]) => WallFloorDB = (
  data,
  dims,
) => {
  // data is an array of {x: , y: , type: }
  const newFormat = {};
  data.forEach((point) => {
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    const type = point["floorType"] || point["wallType"];
    if (!(type in newFormat)) {
      // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
      // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
      newFormat[type] = new Array(dims[0] * dims[1]).fill(0x00);
    }
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    newFormat[type][point.y * dims[0] + point.x] = 0x01;
  });
  Object.keys(newFormat).forEach((type) => {
    // @ts-expect-error Error auto-ignored when enabling noImplicitAny. It's possible this is incorrect.
    // TODO: @ENG-4160 Clean these up! If you're already touching this code, please clean this up while you're at it.
    newFormat[type] = Buffer.from(newFormat[type]).toString("base64");
  });
  return newFormat;
};

export function convertStringToEnabledChat(enabledChat: string): EnabledChat {
  if (!(enabledChat in EnabledChat)) {
    throw new Error("Invalid enabled chat");
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return enabledChat as EnabledChat;
}

export enum PresetTutorialGroupSetIds {
  ONBOARDING_SANDBOX = "ONBOARDING_SANDBOX",
}

// WireTutorialTasks is defined in events.proto but groupSetId is loosely typed as a string
// and areas is not optional due to limitations in protocol buffers, so we replace those here
export interface TutorialTasks extends Omit<WireTutorialTasks, "groupSetId" | "areas"> {
  groupSetId: PresetTutorialGroupSetIds;
  areas?: TutorialTaskMapArea[];
}

export function convertWireTutorialTasksToTutorialTasks(wireTutorialTasks: WireTutorialTasks) {
  const groupSetId = convertStringToPresetTutorialGroupSetId(wireTutorialTasks.groupSetId);
  return { ...wireTutorialTasks, groupSetId };
}

export function convertTutorialTasksToWireTutorialTasks(
  tutorialTasks: TutorialTasks,
): WireTutorialTasks {
  return { ...tutorialTasks, areas: tutorialTasks.areas ?? [] };
}

export function convertStringToPresetTutorialGroupSetId(presetTutorialGroupSetId: string) {
  if (!(presetTutorialGroupSetId in PresetTutorialGroupSetIds)) {
    throw new Error("Invalid presetTutorialGroupSetId");
  }
  // Lint warning auto-ignored when enabling the consistent-type-assertions rule. TODO: @ENG-4304 Correct the type assertion next time this code is edited!
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
  return presetTutorialGroupSetId as PresetTutorialGroupSetIds;
}

export function verifyMapIsComplete(map: Partial<GameMapV2>): map is GameMapV2 {
  const verifyMapIsCompleteHelper = (map: Partial<GameMapV2>): GameMapV2 | null => {
    if (
      map.id != null &&
      map.dimensions != null &&
      map.collisions != null &&
      map.backgroundImagePath != null &&
      map.spaces != null &&
      map.spawns != null &&
      map.portals != null &&
      map.announcer != null
    ) {
      return {
        ...map,
        id: map.id,
        dimensions: map.dimensions,
        collisions: map.collisions,
        backgroundImagePath: map.backgroundImagePath,
        spaces: map.spaces,
        spawns: map.spawns,
        portals: map.portals,
        announcer: map.announcer,
      };
    }
    return null;
  };
  return verifyMapIsCompleteHelper(map) !== null;
}

export const MAP_MAX_DIMENSION = 9999;
