import {
  convertWireAreasToAreas,
  convertWireObjectToMapObject,
  convertWireTutorialTasksToTutorialTasks,
  mergeNooks,
  wallFloorConvertFromDB,
} from "@gathertown/gather-game-common/dist/src/public/gameMap";
import { ServerClientEventEvent } from "./GameEventUtils";
import { Buffer } from "buffer";
import { logger } from "./Logger";
import { GameMap, verifyMapIsComplete } from "./GameMap";

export class MapsAccumulator {
  readonly partialMaps: { [mapId: string]: Partial<GameMap> } = {};

  // [completeMaps] contains references to fully defined maps found in [partialMaps]
  // Note that this means if you edit a map in [partialMaps] in place, that change is also
  // reflected in [completeMaps]
  readonly completeMaps: { [mapId: string]: GameMap } = {};
  readonly lastMapUpdateIds: { [mapId: string]: number } = {};

  // addChunk will return a map only if it is completely defined, otherwise it will return undefined
  addChunk(event: ServerClientEventEvent): GameMap | undefined {
    switch (event.$case) {
      case "mapSetBackgroundImagePath":
      case "mapSetForegroundImagePath":
      case "mapSetSprites":
      case "mapSetSpawns":
      case "mapSetPortals":
      case "mapSetAnnouncer":
      case "mapSetAssets":
      case "mapSetSpawn":
      case "mapSetName":
      case "mapSetMuteOnEntry":
      case "mapSetUseDrawnBG":
      case "mapSetMiniMapImagePath":
      case "mapSetEnabledChats":
      case "mapSetDescription":
      case "mapSetDecoration":
      case "mapSetScript": {
        this.simpleCopyFromEventPayloadToMap(event);
        break;
      }
      case "mapSetNooks": {
        const { mapId, nooks, overwrite } = event.mapSetNooks;
        const map = this.getMap(mapId);

        if (!map) {
          throw new Error(`Map ${mapId} not found`);
        }

        const newNooks = mergeNooks(map.nooks || {}, nooks, overwrite);
        map.nooks = newNooks;
        break;
      }
      case "mapSetDimensions": {
        const { mapId, width, height } = event.mapSetDimensions;
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        this.getMap(mapId).dimensions = [width, height];
        break;
      }
      case "mapSetCollisions": {
        const { mapId, x: offsetX, y: offsetY, w, h, mask } = event.mapSetCollisions;
        const maskBytes = Buffer.from(mask, "base64");
        const map = this.getMap(mapId);

        if (!map) {
          throw new Error(`Map ${mapId} not found`);
        }

        if (!map.collisions) {
          map.collisions = {};
        }

        for (let i = 0; i < h; i++) {
          for (let j = 0; j < w; j++) {
            const y = i + offsetY;
            const x = j + offsetX;

            // if masks removes a collision, delete the entry from the map
            if (!maskBytes[i * w + j]) {
              delete map.collisions[y]?.[x];
              continue;
            }

            const temp = map.collisions[y] ?? {};
            temp[x] = true;
            map.collisions[y] = temp;
          }
        }
        break;
      }
      case "mapSetObjects": {
        const { mapId, objects: wireObjects, updatesAreOverwrites } = event.mapSetObjects;
        const map = this.getMap(mapId);
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        if (!map.objects) {
          // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
          // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
          map.objects = {};
        }
        for (const stringKey in wireObjects) {
          const key = parseInt(stringKey);
          try {
            const newObject = updatesAreOverwrites
              ? wireObjects[key]
              : // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
                // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
                { ...map.objects[key], ...wireObjects[key] };
            // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
            // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
            map.objects[key] = convertWireObjectToMapObject(newObject, key);
          } catch (err) {
            logger.warn(
              `object ${key} in map ${mapId} is badly formated and is being ignored. err: ${logger.errString(
                err,
              )} data: ${logger.errString(wireObjects[key])}`,
            );
          }
        }
        break;
      }
      case "mapSetWalls": {
        const { mapId, walls, delete: shouldDelete } = event.mapSetWalls;
        if (shouldDelete) {
          // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
          // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
          delete this.partialMaps[mapId].walls;
          break;
        }
        const map = this.getMap(mapId);
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        if (map.dimensions === undefined) {
          throw new Error("Cannot set map walls when map dimensions are undefined");
        }
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        map.walls = wallFloorConvertFromDB(walls, map.dimensions, true);
        break;
      }
      case "mapSetFloors": {
        const { mapId, floors, delete: shouldDelete } = event.mapSetFloors;
        if (shouldDelete) {
          // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
          // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
          delete this.partialMaps[mapId].floors;
          break;
        }
        const map = this.getMap(mapId);
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        if (map.dimensions === undefined) {
          throw new Error("Cannot set map floors when map dimensions are undefined");
        }
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        map.floors = wallFloorConvertFromDB(floors, map.dimensions, false);
        break;
      }
      case "mapSetAreas": {
        const { mapId, areas, delete: shouldDelete } = event.mapSetAreas;
        if (shouldDelete) {
          // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
          // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
          delete this.partialMaps[mapId].areas;
          break;
        }
        const map = this.getMap(mapId);
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        map.areas = convertWireAreasToAreas(areas, map.dimensions);
        break;
      }
      case "mapDeleteObject": {
        const { mapId, key } = event.mapDeleteObject;
        const map = this.getMap(mapId);
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        delete map.objects?.[key];
        break;
      }
      case "mapSetTutorialTasks": {
        const {
          mapId,
          tutorialTasks: wireTutorialTasks,
          delete: shouldDelete,
        } = event.mapSetTutorialTasks;
        if (shouldDelete) {
          // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
          // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
          delete this.partialMaps[mapId].tutorialTasks;
          break;
        }
        if (wireTutorialTasks === undefined) {
          throw new Error("Cannot set tutorialTasks because it is undefined");
        }
        // @ts-expect-error Error auto-ignored when enabling TS noUncheckedIndexedAccess. If you're already touching this code, please clean this up while you're at it.
        // TODO: @ENG-4257 Clean these up! See the linear task for more context and advice for cleaning up.
        this.getMap(mapId).tutorialTasks =
          convertWireTutorialTasksToTutorialTasks(wireTutorialTasks);
        break;
      }
      case "mapCommitsChanges": {
        const { mapId, updateId } = event.mapCommitsChanges;
        this.lastMapUpdateIds[mapId] = updateId;
        break;
      }
      case "mapMoveObject": {
        const { mapId, objectId, targetX, targetY, targetXOffset, targetYOffset } =
          event.mapMoveObject;
        const map = this.getMap(mapId);
        if (map) {
          const obj = Object.values(map.objects || []).find((x) => x.id === objectId);
          if (obj) {
            obj.x = targetX;
            obj.offsetX = targetXOffset;
            obj.y = targetY;
            obj.offsetY = targetYOffset;
          }
        }
        break;
      }
      default: {
        throw new Error(`Unexpected map event: ${event.$case}`);
      }
    }
    const mapId = this.getMapIdFromEvent(event);
    if (event.$case !== "mapCommitsChanges") {
      //Client now has a new map state, so we are deleting its lastMapUpdateIds entry
      //while waiting for new updateId. This way we avoid mismatches in case the
      //space is destroyed before the map is persisted.
      delete this.lastMapUpdateIds[mapId];
    }
    this.updateCompleteMaps(mapId);
    return this.completeMaps[mapId];
  }

  private getMap(mapId: string) {
    if (!this.partialMaps[mapId]) {
      this.partialMaps[mapId] = this.initializeMap(mapId);
    }
    return this.partialMaps[mapId];
  }

  // Note that this function has the folllowing precondition:
  // [event] may only contain mapId, delete, and map fields defined on the GameMap type
  private simpleCopyFromEventPayloadToMap(event: ServerClientEventEvent) {
    // event always has its case defined like this, TS is just limited
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
    const { mapId, delete: shouldDelete, ...rest } = (event as any)[event.$case];
    const map = this.getMap(mapId);
    Object.keys(rest).forEach((field) => {
      if (shouldDelete) {
        // I guess really we should check that field is one of the possible fields etc, but there's no harm if it isn't
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
        // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
        delete (map as any)[field];
      } else {
        // this time it'd be better to check, but since we control what map events end up here we can make sure it's the case that this is chill
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
        // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
        (map as any)[field] = rest[field];
      }
    });
  }

  private updateCompleteMaps(mapId: string) {
    if (this.completeMaps[mapId]) return;

    const map = this.partialMaps[mapId];
    if (map && verifyMapIsComplete(map)) {
      this.completeMaps[mapId] = map;
    }
  }

  private initializeMap(mapId: string) {
    return { id: mapId };
  }

  private getMapIdFromEvent(event: ServerClientEventEvent): string {
    // event always has its case defined like this, TS is just limited
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    // Lint warning auto-ignored when enabling the consistent-type-assertions rule. no-explicit-any is also auto-ignored b/c these 2 rules often apply on the same line.
    // You should almost never be using type assertions! TODO: @ENG-4304 Remove these comments and the type assertion next time this code is edited.
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions, @typescript-eslint/no-explicit-any
    const mapId = (event as any)[event.$case]["mapId"];
    if (mapId == null) {
      throw new Error(`no mapId on map event ${event.$case}`);
    }
    return mapId;
  }
}
