import axios from "axios";
import { API_BASE_PATH } from "./config";

export const isBrowser = typeof window !== "undefined";

export interface SlidingWindowMetrics {
  min: number;
  max: number;
  avg: number;
  last: number;
}

export class SlidingWindow {
  maxSize: number;
  values: number[] = [];
  _minValue?: number;
  _maxValue?: number;
  _lastValue?: number;

  constructor(maxSize: number) {
    this.maxSize = maxSize;
  }

  push(value: number) {
    this._lastValue = value;
    this.values.push(value);
    if (this.values.length > this.maxSize) {
      this.values.shift();
    }
    if (typeof this._minValue === "undefined" || value < this._minValue) {
      this._minValue = value;
    }
    if (typeof this._maxValue === "undefined" || value > this._maxValue) {
      this._maxValue = value;
    }
  }

  getLast() {
    return this._lastValue;
  }

  getAverage() {
    if (!this.values.length) {
      return undefined;
    }
    const avg = this.values.reduce((acc, v) => v + acc, 0) / this.values.length;
    return parseFloat(avg.toFixed(2));
  }

  getMin() {
    if (!this._minValue) {
      return undefined;
    }
    return parseFloat(this._minValue.toFixed(2));
  }

  getMax() {
    if (!this._maxValue) {
      return undefined;
    }
    return parseFloat(this._maxValue?.toFixed(2));
  }

  getMetrics(): SlidingWindowMetrics {
    return {
      max: this.getMax() || -1,
      avg: this.getAverage() || -1,
      min: this.getMin() || -1,
      last: this.getLast() || -1,
    };
  }
}

export const fetchGameServerAssignment = async (space: string) => {
  try {
    const res = await axios.get(
      // on browser, use the same deployment that we're currently using
      // from the api, always use prod
      isBrowser
        ? `${API_BASE_PATH}/api/v2/spaces/${encodeURIComponent(space)}/game-server-assignment`
        : `https://gather.town/api/v2/spaces/${encodeURIComponent(space)}/game-server-assignment`,
    );
    return res?.data;
  } catch (e) {
    if (axios.isAxiosError(e)) {
      throw new Error(
        `Fetch game server assignment failed with message: ${e.response?.data?.message} and code: ${e.code}`,
      );
    } else {
      throw e;
    }
  }
};

export const sleepAndReject = (n: number, message?: string) => {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(message)), n);
  });
};

export const parseCustomAction = <ActionType>(name: string, payload: string): ActionType => {
  let action: ActionType;
  try {
    action = JSON.parse(payload);
  } catch {
    throw new Error(`Failed to parse payload for ${name} event: ${payload}`);
  }
  return action;
};
