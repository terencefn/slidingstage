/*

The Engine is what manages the connection with the game server.
Its job is to provide Game.ts with the abstraction of
"send actions whenver you want and events will come back when they're ready",
so Game.ts doesn't have to worry about connection, reconnection, or authentication logic.

Be careful changing this file! Please talk to the Engine Team/get them to review

*/

import {
  ClientServerAction,
  Enter,
  ServerClientBatch,
  ServerClientEvent,
  SpaceUserInfo,
} from "@gathertown/gather-game-common/dist/src/public/events";
import { GameWsCloseCode } from "@gathertown/gather-game-common/dist/src/public/responseCodes";
import { ClientServerActionAction } from "@gathertown/gather-game-common/dist/src/public/utils";
import { logger } from "./Logger";
import { TransactionManager } from "./TransactionManager";
import { fetchGameServerAssignment, sleepAndReject, SlidingWindow } from "./Utils";

const HEARTBEAT_INTERVAL = 10000; // check interval
const HEARTBEAT_TIMEOUT = 45000; // max time without sign of life from the gs
const INITIAL_RECONNECT_DELAY = 1000;
const MAX_RECONNECT_DELAY = 15000; // max time to wait before trying to connect again
const RESET_RECONNECT_ATTEMPTS_DELAY = 60000; // have to be connected for 60 seconds to be considered a successfull reconnect
const MAX_WAIT_FOR_CONNECTION = 45000; // maximum time to wait after calling connect before giving up on waiting for ws.onopen

// Max # of "move" events we'll buffer in sendQ before start to drop them. Buffering too many
// of these while we're disconnected from the server can flood the server and in turn flood other
// clients in the space.
const MAX_BUFFERABLE_MOVE_EVENTS = 10;

export type EngineAuth = { token: string } | { apiKey: string };
type DisconnectInfo = {
  code: GameWsCloseCode;
  reason: string;
};

export class Engine {
  ws?: WebSocket;
  serverURL = "";
  getAuth: () => Promise<EngineAuth>;
  spaceId: string;
  clientUid?: string;
  debugOverrideServer?: string;
  /* state tracking */
  private started = false;
  _connected = false;
  private connectionInitTime = 0;
  private gotFirstMessage = false;

  /* for tracking actions and stuff */
  private _sendQ: { action: ClientServerActionAction; txnId?: number }[] = [];
  // A value cache storing the # of move events currently in sendQ. Keep this in sync with sendQ!
  private numMoveEventsBuffered = 0;
  private transactionManager = new TransactionManager();

  /* reconnect tracking */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private connectionFailedTimeout: any = 0; // number or Timeout, depending on browser vs. node
  private lastSignOfLife = 0; // ms

  /* Stats */
  _bufferedAmounts = new SlidingWindow(10);
  private latencies = new SlidingWindow(10);
  _timeSpentDisconnected = new SlidingWindow(10);
  _eventCountsSinceOpen: { [event: string]: number } = {};
  _closeCounts: { [code: number]: number } = {}; // does not reset

  /* to be overridden by user */
  onevent(_e: ServerClientEvent) {}
  onconnect() {}
  ondisconnect(_code?: number, _reason?: string) {}
  // this is fine because we just print the value, it can be whatever
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  onmetric(_metricName: string, _metricValue: any) {}
  subscriptionHook() {}

  // getAuth: A function that returns an auth token/key that the Engine should
  //   use to authenticate itself with the game server.
  constructor(spaceId: string, getAuth: () => Promise<EngineAuth>, overrideServer?: string) {
    this.getAuth = getAuth;
    this.spaceId = spaceId;
    this.debugOverrideServer = overrideServer;
  }

  //

  /*** CONNECTION LOGIC
   *
   * lifecycle is now:
   * - start / stop -- for making the engine do anything at all
   * - CreateConnection  / DestroyConnection -- internal to engine. for managing the specific connection at any given time
   * - cleanUpAndQueueReconnect -- for reconnects
   *
   * reconnect/retry safeguards:
   * - if the connection closes, clean up (destroy) and queue reconnect
   * - start a timeout when you first try to connect, cancel it when you get the first message. destroys and queues reconnect if it goes off (MAX_WAIT_FOR_CONNECTION)
   * - start a heartbeat when you open the connection. if you don't hear anything for a while, destroy and queue reconnect (HEARTBEAT_TIMEOUT)
   * - cleanUpAndQueueReconnect sets a timeout to create a new connection, if one doesn't exist already
   *   - timeout length increases (up to MAX_RECONNECT_DELAY) each time until it's been a while (RESET_RECONNECT_ATTEMPTS_DELAY) since last call to reconnect
   *
   ***/

  async start() {
    if (this.started) {
      logger.warn("already started");
      return;
    }
    this.started = true;
    this.createConnection();
    this.startRecordingIntentToConnect();
  }

  stop() {
    this.destroyConnection({
      code: GameWsCloseCode.NORMAL_CLOSURE,
      reason: "Game client disconnecting normally",
    });
    this.stopRecordingIntentToConnect();
    if (this.dcLogTimeout) {
      clearTimeout(this.dcLogTimeout);
    }
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
    }
    this.started = false;
  }

  private async createConnection() {
    if (this.ws) {
      logger.error("createConnection called, but connection already exists");
      return;
    }
    this.connectionInitTime = Date.now();
    logger.checkpoint(`creating a new connection at t = ${this.connectionInitTime}`);

    // important that this is first -- if anything goes wrong, it's a catchall retry
    this.connectionFailedTimeout = setTimeout(() => {
      logger.error(
        `t: ${
          Date.now() - this.connectionInitTime
        } : didn't get a ws.onopen for ${MAX_WAIT_FOR_CONNECTION}ms after creating connection. destroying and trying again`,
      );
      this.cleanUpAndQueueReconnect();
    }, MAX_WAIT_FOR_CONNECTION);

    try {
      // this request can take an unbounded amount of time, and axios's timeouts are insufficient
      // (see https://stackoverflow.com/a/54573024/7343159)
      // we don't want to have to reason about old, slow to surface errors,
      // so just we just wrap it in our own timeout
      await Promise.race([
        this.getGameServerUrl().then((url) => {
          this.serverURL = url;
          // note: if this takes a long time, could corrupt serverURL.
          // this is only ok because we use it once, immediately, right below here
        }),
        sleepAndReject(MAX_WAIT_FOR_CONNECTION * 0.66, "gs fetch timed out"),
      ]);
    } catch (e) {
      logger.error(`failed to fetch gameserver assignment: ${logger.errString(e)}`);
      this.onmetric("blackscreen-no-assignment", {
        space: this.spaceId,
        attempts: this._reconnectionAttempts,
      });
      this.cleanUpAndQueueReconnect();
      return;
    }
    logger.checkpoint(
      `t: ${Date.now() - this.connectionInitTime} : got game server url: ${this.serverURL}`,
    );
    const auth = await this.getAuth();

    // connect to server
    try {
      this.ws = new WebSocket(this.serverURL, "gather-v2");
    } catch (e) {
      logger.error(
        `Failed to create websocket object with gameserver ${this.serverURL} : ${logger.errString(
          e,
        )}`,
      );
      this.cleanUpAndQueueReconnect();
      return;
    }
    this.ws.binaryType = "arraybuffer";

    // when created, initialize with our auth token
    this.ws.onopen = () => {
      if (this.ws == null) {
        // never actually happens, just for TS to be happy
        logger.error("something is very wrong, ws is null after open");
        return;
      }
      logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : ws connection opened`);
      this.lastSignOfLife = Date.now();

      clearTimeout(this.connectionFailedTimeout);

      this.startByteTracker();

      // kind of annoying, we have to send this before onconnect
      this.sendAction(
        {
          $case: "init",
          init: {
            spaceId: this.spaceId,
            auth:
              "token" in auth
                ? { $case: "token", token: auth.token }
                : { $case: "apiKey", apiKey: auth.apiKey },
          },
        },
        true,
      );

      this.ws.onmessage = (msg) => {
        if (!this.gotFirstMessage) {
          logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : got first message`);
          this.gotFirstMessage = true;
        }
        this._bytesReceivedSinceConnect += msg.data.byteLength;
        this.lastSignOfLife = Date.now(); // if we get any message, it means the server is alive

        try {
          const data = new Uint8Array(msg.data);
          const { events } = ServerClientBatch.decode(data);
          events.forEach((event) => this.processEvent(event));
        } catch (e) {
          logger.error(`unexpected error in ws.onmessage, maybe decode?: ${logger.errString(e)}`);
        }
      };

      this.startHeartbeat();
      this.onconnect();
    };

    // NOTE: onclose can be called without onopen having been called. it happens when you fail to establish a connection
    this.ws.onclose = (event) => {
      this.onmetric(`client_ws_close_code_${event.code}`, { value: event.reason });
      this._closeCounts[event.code] = (this._closeCounts[event.code] ?? 0) + 1;
      logger.checkpoint(
        `t: ${Date.now() - this.connectionInitTime} : onclose. last sign of life was ${
          Date.now() - this.lastSignOfLife
        }ms ago`,
      );
      switch (event.code) {
        case GameWsCloseCode.SPACE_AT_CAPACITY:
          logger.error("Space is currently at capacity, please try again later: " + event.reason);
          this.destroyConnection({ code: event.code, reason: event.reason }); // don't reconnect!
          break;
        case GameWsCloseCode.PROTOCOL_ERROR:
          logger.error("ws closed: protocol error. " + event.reason);
          // reload to hopefully get a new client that works?
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          this.destroyConnection({ code: event.code, reason: event.reason }); // don't reconnect, it's not going to work the second time
          break;
        case GameWsCloseCode.INTERNAL_ERROR:
          logger.error("connection closed due to internal server error: " + event.reason);
          // reload to hopefully get a new client that works?
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          this.destroyConnection({ code: event.code, reason: event.reason }); // don't reconnect, it's not going to work the second time
          break;
        case GameWsCloseCode.CLIENT_KICKED:
          logger.error("connection closed due to client being kicked: " + event.reason);
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          this.cleanUpAndQueueReconnect({ code: event.code, reason: event.reason }); // if it's a mod, it's fine, reconnect
          break;
        case GameWsCloseCode.UNAUTHORIZED:
          logger.error("connection closed because user does not have access: " + event.reason);
          // reload because the FE will show them a nice landing screen instead
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          this.destroyConnection({ code: event.code, reason: event.reason }); // don't bother reconnecting
          break;
        case GameWsCloseCode.CONN_TIMED_OUT:
          logger.error("connection timed out: " + event.reason);
          this.cleanUpAndQueueReconnect({ code: event.code, reason: event.reason });
          break;
        case GameWsCloseCode.NO_STATUS_RECEIVED:
          logger.error("connection closed unexpectedly with no status: " + logger.errString(event));
          this.cleanUpAndQueueReconnect({ code: event.code, reason: event.reason });
          break;
        default:
          logger.error(
            `connection closed with unrecognized non-default code ${event.code}: ${logger.errString(
              event,
            )}`,
          );
          this.cleanUpAndQueueReconnect({ code: event.code, reason: event.reason });
      }
    };

    // NOTE: onerror can be called without onopen having been called. it happens when you fail to establish a connection
    this.ws.onerror = (e) => {
      logger.error(`ws.onerror in Engine: ${logger.errString(e)}`);
      this.onmetric(`ws error`, { error: e });
    };
  }

  private destroyConnection(disconnectInfo?: DisconnectInfo) {
    logger.warn(`t: ${Date.now() - this.connectionInitTime} : destroying connection`);

    if (this.ws) {
      this.ws.onopen = () => {};
      this.ws.onclose = () => {};
      this.ws.onmessage = () => {};
      this.ws.onerror = () => {};
      try {
        const disconnectInfoCode = disconnectInfo?.code ?? 0;
        if (disconnectInfoCode >= 4000 || disconnectInfoCode === GameWsCloseCode.NORMAL_CLOSURE) {
          this.ws.close(disconnectInfo?.code, disconnectInfo?.reason);
        } else {
          this.ws.close();
        }
      } catch (err) {
        logger.error("error closing connection: " + logger.errString(err));
      }
      this.ws = undefined; // DO NOT SET ws TO UNDEFINED ANYWHERE ELSE!
      // it's way easier to reason about this if there aren't loose ws.onclose functions floating around for old connections doing unexpected things
    }

    clearTimeout(this.connectionFailedTimeout);
    this.logDisconnectionStart();
    this._connected = false;
    this.stopHeartbeat();
    this.stopByteTracker();
    this.transactionManager.reset();
    this._eventCountsSinceOpen = {};
    this.gotFirstMessage = false;

    this.ondisconnect(disconnectInfo?.code, disconnectInfo?.reason);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private reconnectTimeout: any = 0; // number or Timeout, depending on browser vs. node
  private _reconnectionAttempts = 0;
  private lastReconnectQueued = 0;

  // this function just waits a bit and then starts the connection cycle again
  private cleanUpAndQueueReconnect(disconnectInfo?: DisconnectInfo) {
    this.destroyConnection(disconnectInfo); // if we're going to do a reconnect, the current connection better not exist

    // if it's been a while since we had to reconnect and we've been connected recently, reset the attempt count (and thus the backoff)
    if (
      Date.now() > this.lastReconnectQueued + RESET_RECONNECT_ATTEMPTS_DELAY &&
      Date.now() < this.lastSignOfLife + RESET_RECONNECT_ATTEMPTS_DELAY
    ) {
      this._reconnectionAttempts = 0;
    }
    this.lastReconnectQueued = Date.now();

    // don't set a new one if we've already got one
    if (this.reconnectTimeout) {
      return;
    }

    if (this.lastSignOfLife === 0) {
      this.onmetric("stuck-on-connecting", { attempt: this._reconnectionAttempts });
    }
    if (this._reconnectionAttempts === 2) {
      // auto-publish the recent debug history, so we can look at it
      this.onmetric("ggc-debug-history", { history: logger.exportHistory().slice(-10000) });
    }

    // Apply exponential backoff with INITIAL_RECONNECT_DELAY on the
    // number of attempts so far as inputs. Do not allow the number to exceed
    // MAX_RECONNECT_DELAY
    let reconnectDelay = Math.min(
      INITIAL_RECONNECT_DELAY * 2 ** this._reconnectionAttempts,
      MAX_RECONNECT_DELAY,
    );
    // Apply some jitter of +/- 25% from the reconnectDelay
    const jitter = 0.25;
    reconnectDelay = reconnectDelay * (1 - jitter + Math.random() * 2 * jitter);
    // But never delay less than INITIAL_RECONNECT_DELAY
    reconnectDelay = Math.max(INITIAL_RECONNECT_DELAY, reconnectDelay);

    logger.checkpoint(
      `queuing reconnect after ${this._reconnectionAttempts} recent attempts, ${reconnectDelay}ms`,
    );
    this._reconnectionAttempts++;

    this.reconnectTimeout = setTimeout(() => {
      this.reconnectTimeout = null;
      logger.checkpoint("reconnect timer fired, destroying and starting over");
      this.destroyConnection();
      this.createConnection();
    }, reconnectDelay);
  }

  //

  /*** action/event handling ***/

  // enter and exit are special cases of game logic that the Engine has to worry about,
  // since the Engine is supposed to provide the abstraction of a continuous connection,
  // but you need to re-enter each time to connect.
  private wantsToEnter = false;
  private tempSpaceUserInfo?: SpaceUserInfo;
  private tempSpawnToken?: string;
  private tempTargetId?: string;
  // we want to call enter exactly once, first thing once the gs is ready.
  // we don't want to call it with the original params after the first time though,
  //   in case the user has changed their outfit or something since joining
  // so: send an enter event if _connected (gs ready), otherwise just save the info and queue it.
  // also: wipe the info after the first time you use it, so you don't use it again next time
  queueOrExecuteEnter(info?: SpaceUserInfo, spawnToken?: string, targetId?: string) {
    this.wantsToEnter = true;

    // save params in case it doesn't work out this time
    if (info) {
      this.tempSpaceUserInfo = info;
    }
    if (spawnToken) {
      this.tempSpawnToken = spawnToken;
    }
    if (targetId) {
      this.tempTargetId = targetId;
    }

    if (this._connected) {
      const enterParams: Enter = {};
      if (this.tempSpaceUserInfo) {
        enterParams.info = this.tempSpaceUserInfo;
      }
      if (this.tempSpawnToken) {
        enterParams.spawnToken = this.tempSpawnToken;
      }
      if (this.tempTargetId) {
        enterParams.targetId = this.tempTargetId;
      }
      this.sendAction({
        $case: "enter",
        enter: enterParams,
      });
      this.tempSpaceUserInfo = undefined;
      this.tempSpawnToken = undefined;
    }
  }
  exit() {
    this.wantsToEnter = false;
    this.sendAction({
      $case: "exit",
      exit: {},
    });
  }

  private processEvent(serverClientEvent: ServerClientEvent) {
    const event = serverClientEvent.event;
    if (!event) {
      logger.error("Nullish server client event; this shouldn't happen! " + serverClientEvent);
      return;
    }
    this._eventCountsSinceOpen[event.$case] = (this._eventCountsSinceOpen[event.$case] ?? 0) + 1;
    try {
      switch (event.$case) {
        case "serverHeartbeat":
          this.sendAction({
            $case: "clientHeartbeat",
            clientHeartbeat: {},
          });
          break;
        case "ready":
          this.clientUid = event.ready.id;
          this._connected = true;
          this.subscriptionHook();
          if (this.wantsToEnter) {
            // need to enter first because most future actions wil depend
            // on the the player being initialized/pending initialization
            this.queueOrExecuteEnter();
          }

          if (this._sendQ.length >= 20) {
            this.onmetric("large-sendQ", {
              sendQLength: this._sendQ.length,
            });
          }
          this._sendQ.forEach(({ action, txnId }) => {
            this.sendAction(action, false, false, txnId);
          });
          this._sendQ = [];
          this.numMoveEventsBuffered = 0;
          break;
        case "info":
          logger.log("[info from gs] " + event.info.message);
          break;
        case "warn":
          logger.warn("[warn from gs] " + event.warn.message);
          break;
        case "error":
          logger.error(`[error from gs] ${event.error.code}: ` + event.error.message);
          // TODO later: do different things with different error codes, when they actually have meanings assigned
          break;
        case "transactionStatus": {
          this.transactionManager.handleTransactionStatusEvent(event.transactionStatus);
          break;
        }
      }

      this.onevent(serverClientEvent);
    } catch (e) {
      logger.error(`Failed to process event ${event.$case} with error: ${logger.errString(e)}`);
      this.onmetric("failed-to-process-event", {
        // @ts-expect-error Error auto-ignored when enabling useUnknownInCatchVariables. It's possible this is incorrect.
        // TODO: @ENG-4157 Clean these up! If you're already touching this code, please clean this up while you're at it.
        errorMessage: e?.message,
        eventName: event.$case,
      });
    }
  }

  /**
   * @returns A promise if createTxnId is true, otherwise nothing.
   */
  sendAction(
    action: ClientServerActionAction,
    bypass: boolean,
    createTxnId: true,
    txnId?: number,
  ): Promise<unknown>;
  sendAction(
    action: ClientServerActionAction,
    bypass?: boolean,
    createTxnId?: false,
    txnId?: number,
  ): void;
  sendAction(
    action: ClientServerActionAction,
    bypass?: boolean,
    createTxnId?: boolean,
    txnId?: number,
  ): Promise<unknown> | void;
  // @ts-expect-error Error auto-ignored when migrating tsconfigs to extend tsconfig.base.json. TODO: @ENG-4320 Clean this up the next time this code is touched!
  sendAction(
    action: ClientServerActionAction,
    bypass = false,
    createTxnId = false,
    txnId?: number,
  ) {
    let transaction;
    logger.debug("New action", action.$case);
    if (createTxnId) {
      transaction = this.transactionManager.addTransaction();
      logger.debug("Creating new transaction", transaction.txnId);
      txnId = transaction.txnId;
    }
    if (!this._connected && !bypass) {
      // If we're disconnected, drop all active speaker events. Queueing them will flood the
      // server on reconnect, and they're not harmful to drop.
      // Similarly, drop move events after a certain threshold. We should queue these when possible
      // to preserve client prediction, but at some point it's not worth flooding the server that much.
      // There are more harmless events, but these 2 are so common they're probably the only ones that
      // make a difference, so might as well keep the special cases to a minimum.
      if (
        (action.$case === "move" && this.numMoveEventsBuffered >= MAX_BUFFERABLE_MOVE_EVENTS) ||
        action.$case === "activelySpeaking"
      ) {
        logger.debug(`[Engine] dropping ${action.$case} action because we're not connected`);
      } else {
        this._sendQ.push({ action, txnId });
        if (action.$case === "move") {
          this.numMoveEventsBuffered++;
        }
      }
      return transaction?.txnPromise;
    }
    try {
      const serializedAction = ClientServerAction.encode({
        txnId,
        action,
      }).finish();
      this._bufferedAmounts.push(this.ws?.bufferedAmount ?? 0);
      if (!this.ws) {
        logger.error(`WebSocket not initialized during ${action.$case}, this should never happen!`);
        this.onmetric("send-action-no-ws", { value: 1, action: action.$case });
      }
      this.ws?.send(serializedAction);
      this._bytesSentSinceConnect += serializedAction.byteLength;
      return transaction?.txnPromise;
    } catch (e) {
      if (txnId) {
        // @ts-expect-error Error auto-ignored when enabling useUnknownInCatchVariables. It's possible this is incorrect.
        // TODO: @ENG-4157 Clean these up! If you're already touching this code, please clean this up while you're at it.
        this.transactionManager.rejectTransaction(txnId, e.message);
      }
      logger.error("websocket send error: " + logger.errString(e));
    }
  }

  //

  /*** MONITORING ***/

  private recordHeartbeatTime(time: number) {
    this.onmetric("heartbeat-latency", { value: time });
    this.latencies.push(time);
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _heartbeatInterval: any = 0; // number or Timeout, depending on browser vs. node

  startHeartbeat() {
    if (this._heartbeatInterval) {
      return;
    }

    this._heartbeatInterval = setInterval(() => {
      // measure latency, and actually send the heartbeat
      const start = Date.now();
      this.sendAction({ $case: "clientBackupHeartbeat", clientBackupHeartbeat: {} }, false, true)
        ?.then(() => {
          this.recordHeartbeatTime(Date.now() - start);
        })
        .catch(() => {
          this.recordHeartbeatTime(Date.now() - start);
          this.onmetric("heartbeat-txn-timed-out", { value: 1 });
        });

      // check if it's been too long
      if (this.lastSignOfLife < Date.now() - HEARTBEAT_TIMEOUT && this.ws != null) {
        logger.error(
          `t: ${Date.now() - this.connectionInitTime} : no heartbeat since ${
            this.lastSignOfLife
          }, closing connection`,
        );
        this.onmetric("ws-close-timeout", {
          lastHeartbeat: this.lastSignOfLife,
          readyState: this.ws.readyState,
        });
        this.cleanUpAndQueueReconnect({
          code: GameWsCloseCode.CONN_TIMED_OUT,
          reason: `Game Server timed out for ${this.clientUid}. No heartbeat since ${this.lastSignOfLife}`,
        });
        logger.checkpoint("successfully closed ws connection with TIMEOUT code");
      }
    }, HEARTBEAT_INTERVAL);
  }

  stopHeartbeat() {
    clearInterval(this._heartbeatInterval);
    this._heartbeatInterval = null;
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private _byteTrackerInterval: any = 0; // number or Timeout, depending on browser vs. node
  private _bytesSentSinceConnect = 0;
  private _bytesReceivedSinceConnect = 0;
  private _lastBytesSent = 0;
  private _lastBytesReceived = 0;

  startByteTracker() {
    // track data sent and received for debug
    if (!this._byteTrackerInterval) {
      this._byteTrackerInterval = setInterval(() => {
        // these should never happen -- the gs hasn't sent anything at all for 15 seconds??
        if (this._bytesSentSinceConnect === this._lastBytesSent) {
          logger.warn(
            `warning: bytes sent hasn't changed in the last 15 seconds, currently ${this._lastBytesSent}`,
          );
          this.onmetric("no-bytes-sent-recently", { value: 1 });
        }
        if (this._bytesReceivedSinceConnect === this._lastBytesReceived) {
          logger.warn(
            `warning: bytes received hasn't changed in the last 15 seconds, currently ${this._lastBytesReceived}`,
          );
          this.onmetric("no-bytes-recv-recently", { value: 1 });
        }
        this._lastBytesSent = this._bytesSentSinceConnect;
        this._lastBytesReceived = this._bytesReceivedSinceConnect;
      }, 15000);
    }
  }

  stopByteTracker() {
    clearInterval(this._byteTrackerInterval);
    this._byteTrackerInterval = null;
    this._bytesSentSinceConnect = 0;
    this._bytesReceivedSinceConnect = 0;
  }

  // adding this so we can measure what fraction of people are getting disconnected in newrelic.
  // basically just a thing that fires every min so we have a way to count currently connected users from the browser metrics
  private CONNECT_INTENT_POST_INTERVAL = 60 * 1000; // ms // make sure this lines up with how we do the measurement in NR
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private connectIntentInterval: any = 0; // number or Timeout, depending on browser vs. node
  private startRecordingIntentToConnect() {
    this.onmetric("intend-to-be-connected", { connected: this._connected, first: true });
    this.connectIntentInterval = setInterval(
      () => this.onmetric("intend-to-be-connected", { connected: this._connected }),
      this.CONNECT_INTENT_POST_INTERVAL,
    );
  }
  private stopRecordingIntentToConnect() {
    clearInterval(this.connectIntentInterval);
  }

  // this bit measures how bad disconnections are
  // - a disconnection is defined as the time between when you first get disconnected to when you've successfully re-synced (end of updateSubscriptions)
  // - each disconnection results in exactly one "dc-length" metric (if they don't refresh)
  // - each disconnection results in exactly one "dc-length" with preTimeout: true OR one "dc-at-least-${this.LOG_THRESH_MS}-ms"
  //   (if they don't refresh in the first LOG_THRESH_MS ms)
  // The latter is so we can worry less about people refreshing and know
  // what fraction of people have a "bad" experience during a deploy vs an acceptable one
  LOG_THRESH_MS = 10000;
  private hasEverFullyConnected = false;
  private disconnectedStartTime = 0;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private dcLogTimeout: any = 0; // number or Timeout, depending on browser vs. node
  // ^use this timeout to make sure we measure the long tail of people who never reconnect, or refresh too quickly

  logDisconnectionStart() {
    if (!this.hasEverFullyConnected || this.disconnectedStartTime) {
      // the disconnection started earlier, so don't reset the tracking now
      // have to include hasEverFullyConnected to avoid counting the case when they've never successfully connected (muddies this metric)
      return;
    }
    this.disconnectedStartTime = Date.now();
    this.dcLogTimeout = setTimeout(() => {
      this.dcLogTimeout = 0;
      this.onmetric(`dc-at-least-${this.LOG_THRESH_MS}-ms`, {});
    }, this.LOG_THRESH_MS);
  }

  // called when we've successfully received the initial batch of data from first subscribing
  logInitialSyncComplete() {
    logger.checkpoint(
      `t: ${Date.now() - this.connectionInitTime} : successfully subscribed and re-synced`,
    );
    this.hasEverFullyConnected = true;

    if (this.disconnectedStartTime) {
      this.onmetric("dc-length", {
        ms: Date.now() - this.disconnectedStartTime,
        [`preTimeout${this.LOG_THRESH_MS}`]: !!this.dcLogTimeout,
      });

      // also separately, update this for the stats
      this._timeSpentDisconnected.push(Date.now() - this.disconnectedStartTime);

      // reset dc start since we're no longer disconnected
      this.disconnectedStartTime = 0;
      this.dcLogTimeout = 0;
    }
  }

  //

  /*** UTILS  ***/

  async getGameServerUrl() {
    if (this.debugOverrideServer) {
      return this.debugOverrideServer;
    }

    return fetchGameServerAssignment(this.spaceId);
  }

  getMetrics() {
    return {
      connected: this._connected,
      latency: this.latencies.getMetrics(),
      reconnects: {
        recentAttempts: this._reconnectionAttempts,
        timeSpentDisconnectedMs: this._timeSpentDisconnected.getMetrics(),
      },
      bufferedAmount: this._bufferedAmounts.getMetrics(),
      bytesSentSinceConnect: this._bytesSentSinceConnect,
      bytesReceivedSinceConnect: this._bytesReceivedSinceConnect,
      eventCountsSinceOpen: this._eventCountsSinceOpen,
      closeCodeCount: this._closeCounts,
    };
  }
}
