"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionManager = void 0;
const TXN_TIMEOUT_LENGTH_MS = 1000 * 60 * 10;
const Logger_1 = require("./Logger");
class TransactionManager {
    constructor() {
        this.pendingTxns = {};
        this.txnTimeouts = {};
    }
    addTransaction(customTimeout) {
        const timeoutLength = customTimeout !== null && customTimeout !== void 0 ? customTimeout : TXN_TIMEOUT_LENGTH_MS;
        const txnId = this.getRandomTxnId();
        const txnPromise = new Promise((res, rej) => {
            if (txnId === undefined)
                return;
            this.pendingTxns[txnId] = { res, rej };
            this.txnTimeouts[txnId] = setTimeout(() => {
                this.rejectTransaction(txnId, "Transaction timed out");
            }, timeoutLength);
        });
        return { txnId, txnPromise };
    }
    rejectTransaction(txnId, message) {
        var _a;
        (_a = this.pendingTxns[txnId]) === null || _a === void 0 ? void 0 : _a.rej(new Error(message !== null && message !== void 0 ? message : "Transaction was rejected"));
        const timeout = this.txnTimeouts[txnId];
        if (timeout) {
            clearTimeout(timeout);
        }
        delete this.pendingTxns[txnId];
        delete this.txnTimeouts[txnId];
    }
    handleTransactionStatusEvent(transactionStatus) {
        var _a, _b;
        const { txnId, succeeded, reason } = transactionStatus;
        if (this.pendingTxns[txnId] === undefined) {
            Logger_1.logger.error("Received a txnId for a non-pending transaction.");
            return;
        }
        if (succeeded) {
            (_a = this.pendingTxns[txnId]) === null || _a === void 0 ? void 0 : _a.res(true);
        }
        else {
            (_b = this.pendingTxns[txnId]) === null || _b === void 0 ? void 0 : _b.rej(new Error(`Transaction failed due to error. ${reason !== null && reason !== void 0 ? reason : ""}`));
        }
        const timeout = this.txnTimeouts[txnId];
        if (timeout) {
            clearTimeout(timeout);
        }
        delete this.pendingTxns[txnId];
        delete this.txnTimeouts[txnId];
    }
    reset() {
        Object.values(this.txnTimeouts).forEach((timeout) => clearTimeout(timeout));
        Object.values(this.pendingTxns).forEach(({ rej }) => rej(new Error("Transaction failed due to forced reset, likely because the connection failed")));
        this.pendingTxns = {};
        this.txnTimeouts = {};
    }
    getRandomTxnId() {
        return Math.floor(Math.random() * 4294967295);
    }
}
exports.TransactionManager = TransactionManager;
//# sourceMappingURL=TransactionManager.js.map