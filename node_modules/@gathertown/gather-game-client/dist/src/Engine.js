"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Engine = void 0;
const uuid_1 = require("uuid");
const axios_1 = __importDefault(require("axios"));
const events_1 = require("@gathertown/gather-game-common/dist/src/public/events");
const responseCodes_1 = require("@gathertown/gather-game-common/dist/src/public/responseCodes");
const Logger_1 = require("./Logger");
const TransactionManager_1 = require("./TransactionManager");
const Utils_1 = require("./Utils");
const Error_1 = require("./Error");
const HEARTBEAT_INTERVAL = 10000;
const HEARTBEAT_TIMEOUT = 45000;
const INITIAL_RECONNECT_DELAY = 1000;
const MAX_RECONNECT_DELAY = 15000;
const RESET_RECONNECT_ATTEMPTS_DELAY = 120000;
const MAX_WAIT_FOR_CONNECTION = 45000;
const SUSPEND_CHECK_DELAY = 3000;
const CONSIDERED_SUSPEND_DELAY = 10000;
const SUBDOMAINS = ["a", "b", "c", "d", "e"];
const SENDING_LARGE_MESSAGE_WARN = "sending large message:";
const MAX_BUFFERABLE_MOVE_EVENTS = 10;
class Engine {
    constructor(spaceId, getAuth, overrideServer, overrideHttpServer) {
        this.serverURL = "";
        this.originalServerURL = "";
        this.started = false;
        this.startTime = 0;
        this._connected = false;
        this.connectionInitTime = 0;
        this.gotFirstMessage = false;
        this.sizeOfNextLargeMessage = 0;
        this._sendQ = [];
        this.numMoveEventsBuffered = 0;
        this.transactionManager = new TransactionManager_1.TransactionManager();
        this.connectionFailedTimeout = 0;
        this.uploadLogTimeout = 0;
        this.uploadLogTimeoutLong = 0;
        this.lastSignOfLife = 0;
        this.cancelGsFetch = () => { };
        this.lastSuccessfulFetch = 0;
        this._bufferedAmounts = new Utils_1.SlidingWindow(10);
        this.latencies = new Utils_1.SlidingWindow(10);
        this._timeSpentDisconnected = new Utils_1.SlidingWindow(10);
        this._eventCountsSinceOpen = {};
        this._closeCounts = {};
        this.reconnectTimeout = 0;
        this._reconnectionAttempts = 0;
        this.lastReconnectQueued = 0;
        this.wantsToEnter = false;
        this._lastActionSentAt = 0;
        this._heartbeatInterval = 0;
        this._byteTrackerInterval = 0;
        this._bytesSentSinceConnect = 0;
        this._bytesReceivedSinceConnect = 0;
        this._lastBytesSent = 0;
        this._lastBytesReceived = 0;
        this.CONNECT_INTENT_POST_INTERVAL = 60 * 1000;
        this.connectIntentInterval = 0;
        this.LOG_THRESH_MS = 10000;
        this.hasEverFullyConnected = false;
        this.disconnectedStartTime = 0;
        this.dcLogTimeout = 0;
        this.lastSuspendCheck = 0;
        this.suspendCheckInterval = 0;
        this.lastSuspendDate = 0;
        this.isThrottled = false;
        this.getAuth = getAuth;
        this.spaceId = spaceId;
        this.debugOverrideServer = overrideServer;
        this.debugOverrideHttpServer = overrideHttpServer;
        if (Utils_1.isBrowser) {
            window.addEventListener("beforeunload", () => this.stop());
        }
    }
    onevent(_e) { }
    onconnect() { }
    ondisconnect(_code, _reason) { }
    onmetric(_metricName, _metricValue) { }
    subscriptionHook() { }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.started) {
                Logger_1.logger.warn("already started");
                return;
            }
            this.started = true;
            this.startTime = Date.now();
            this.createConnection();
            this.startRecordingIntentToConnect();
            this.startSuspendCheck();
        });
    }
    stop(disconnectInfo) {
        this.destroyConnection(disconnectInfo !== null && disconnectInfo !== void 0 ? disconnectInfo : {
            code: responseCodes_1.GameWsCloseCode.NORMAL_CLOSURE,
            reason: "Game client disconnecting normally",
        });
        this.stopRecordingIntentToConnect();
        this.stopSuspendCheck();
        if (this.reconnectTimeout) {
            clearTimeout(this.reconnectTimeout);
        }
        this.resetDisconnectionTracking();
        this.started = false;
    }
    shouldUseSubdomains() {
        if (!this.originalServerURL || !this.spaceId)
            return false;
        return this.spaceId.match(/^[a-z0-4]/) && this.originalServerURL.includes("game-");
    }
    createConnection() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ws) {
                Logger_1.logger.error("createConnection called, but connection already exists");
                return;
            }
            this.connectionInitTime = Date.now();
            Logger_1.logger.checkpoint(`creating a new connection at t = ${this.connectionInitTime}`);
            this.queueDebugUpload();
            this.connectionFailedTimeout = setTimeout(() => {
                Logger_1.logger.error(`t: ${Date.now() - this.connectionInitTime} : didn't get a ws.onopen for ${MAX_WAIT_FOR_CONNECTION}ms after creating connection. destroying and trying again`);
                this.onmetric("create-connection-timeout", {
                    space: this.spaceId,
                    attempts: this._reconnectionAttempts,
                });
                this.cleanUpAndQueueReconnect();
            }, MAX_WAIT_FOR_CONNECTION);
            let fetchTooSlowTimeout;
            try {
                const CancelToken = axios_1.default.CancelToken;
                const source = CancelToken.source();
                fetchTooSlowTimeout = setTimeout(() => {
                    this.cancelGsFetch();
                }, MAX_WAIT_FOR_CONNECTION * 0.66);
                this.cancelGsFetch = () => {
                    source.cancel("gs fetch timed out");
                    clearTimeout(fetchTooSlowTimeout);
                };
                this.originalServerURL = yield this.getGameServerUrl(source.token);
                if (this.shouldUseSubdomains()) {
                    const subdomain = SUBDOMAINS[(Math.random() * SUBDOMAINS.length) | 0];
                    this.serverURL = this.originalServerURL.replace("wss://", "wss://" + subdomain + ".");
                }
                else {
                    this.serverURL = this.originalServerURL;
                }
            }
            catch (e) {
                const message = e.message;
                let failedStatus;
                if (e instanceof Error_1.ClientError) {
                    failedStatus = e.code;
                }
                Logger_1.logger.error(`failed to fetch gameserver assignment: ${message}`);
                const online = Utils_1.isBrowser ? (_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true : true;
                if (!online) {
                    Logger_1.logger.checkpoint("User is offline, retrying connection...");
                }
                this.onmetric("gs-assignment-failed", {
                    space: this.spaceId,
                    attempts: this._reconnectionAttempts,
                    online,
                    failedStatus,
                    errorMessage: message,
                    timeSinceLastSuspend: Date.now() - this.lastSuspendDate,
                });
                this.cleanUpAndQueueReconnect();
                return;
            }
            finally {
                clearTimeout(fetchTooSlowTimeout);
            }
            if (!this.started)
                return;
            Logger_1.logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : got game server url: ${this.serverURL}`);
            this.lastSuccessfulFetch = Date.now();
            const auth = yield this.getAuth();
            Logger_1.logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : got auth`);
            try {
                this.ws = new WebSocket(this.serverURL, "gather-v2");
            }
            catch (e) {
                Logger_1.logger.error(`Failed to create websocket object with gameserver ${this.serverURL} : ${Logger_1.logger.errString(e)}`);
                this.cleanUpAndQueueReconnect();
                return;
            }
            this.ws.binaryType = "arraybuffer";
            this.ws.onopen = () => {
                Logger_1.logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : ws connection opened`);
                this.lastSignOfLife = Date.now();
                clearTimeout(this.connectionFailedTimeout);
                this.startByteTracker();
                this.sendAction({
                    $case: "init",
                    init: {
                        spaceId: this.spaceId,
                        auth: "token" in auth
                            ? { $case: "token", token: auth.token }
                            : { $case: "apiKey", apiKey: auth.apiKey },
                    },
                }, true);
                this.startHeartbeat();
                this.onconnect();
            };
            this.ws.onmessage = (msg) => {
                if (!this.gotFirstMessage) {
                    const connectionInitTime = Date.now() - this.connectionInitTime;
                    Logger_1.logger.checkpoint(`t: ${connectionInitTime} : got first message`);
                    this.onmetric("connection_init_time", {
                        space: this.spaceId,
                        attempts: this._reconnectionAttempts,
                        value: connectionInitTime,
                        serverUrl: this.serverURL,
                    });
                    this.gotFirstMessage = true;
                }
                this._bytesReceivedSinceConnect += msg.data.byteLength;
                this.lastSignOfLife = Date.now();
                this.sizeOfNextLargeMessage = 0;
                try {
                    const data = new Uint8Array(msg.data);
                    const { events } = events_1.ServerClientBatch.decode(data);
                    events.forEach((event) => this.processEvent(event));
                    const sinceLastActionSentToServer = Date.now() - this._lastActionSentAt;
                    if (this.isThrottled && sinceLastActionSentToServer > HEARTBEAT_INTERVAL) {
                        this.sendAction({ $case: "clientBackupHeartbeat", clientBackupHeartbeat: {} });
                    }
                }
                catch (e) {
                    Logger_1.logger.error(`unexpected error in ws.onmessage, maybe decode?: ${Logger_1.logger.errString(e)}`);
                }
            };
            this.ws.onclose = (event) => {
                var _a;
                this.checkAndHandleSuspend();
                this.onmetric(`client_ws_close_code_${event.code}`, Object.assign(Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { value: event.reason, wasClean: event.wasClean }), (this.sizeOfNextLargeMessage && {
                    wasWaitingForMessageOfSize: this.sizeOfNextLargeMessage,
                })));
                this._closeCounts[event.code] = ((_a = this._closeCounts[event.code]) !== null && _a !== void 0 ? _a : 0) + 1;
                Logger_1.logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : onclose. last sign of life was ${this.lastSignOfLife ? Date.now() - this.lastSignOfLife + "ms ago" : "never"}. wasClean: ${event.wasClean}`);
                const disconnectInfo = { code: event.code, reason: event.reason };
                switch (event.code) {
                    case responseCodes_1.GameWsCloseCode.SPACE_CLOSED:
                        Logger_1.logger.error("Space is closed: " + event.reason);
                        if (Utils_1.isBrowser) {
                            window.location.reload();
                        }
                        this.stop(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.SPACE_AT_CAPACITY:
                        Logger_1.logger.error("Space is currently at capacity, please try again later: " + event.reason);
                        this.stop(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.PROTOCOL_ERROR:
                        Logger_1.logger.error("ws closed: protocol error. " + event.reason);
                        if (Utils_1.isBrowser) {
                            window.location.reload();
                        }
                        this.stop(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.INTERNAL_ERROR:
                        Logger_1.logger.error("connection closed due to internal server error: " + event.reason);
                        if (Utils_1.isBrowser) {
                            window.location.reload();
                        }
                        this.stop(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.CLIENT_KICKED:
                        Logger_1.logger.error("connection closed due to client being kicked: " + event.reason);
                        if (Utils_1.isBrowser) {
                            window.location.reload();
                        }
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.UNAUTHORIZED:
                        Logger_1.logger.error("connection closed because user does not have access: " + event.reason);
                        if (Utils_1.isBrowser) {
                            window.location.reload();
                        }
                        this.stop(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.CONN_TIMED_OUT:
                        Logger_1.logger.error("connection timed out: " + event.reason);
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.NO_STATUS_RECEIVED:
                        Logger_1.logger.error("connection closed unexpectedly with no status: " + Logger_1.logger.errString(disconnectInfo));
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.GOING_AWAY:
                        Logger_1.logger.warn("connection closed with code 1001 GOING_AWAY - " + event.reason);
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                        break;
                    case responseCodes_1.GameWsCloseCode.NO_CLOSE_FRAME:
                        Logger_1.logger.error(`connection closed unexpectedly (${event.code}: ${event.reason})`);
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                        break;
                    default:
                        Logger_1.logger.error(`connection closed with unrecognized non-default code ${event.code}: ${event.reason}`);
                        this.cleanUpAndQueueReconnect(disconnectInfo);
                }
            };
            this.ws.onerror = (e) => {
                Logger_1.logger.error(`ws.onerror in Engine: ${Logger_1.logger.errString(e)}`);
                this.onmetric(`ws error`, Object.assign({ error: e, serverUrl: this.serverURL }, (this.sizeOfNextLargeMessage && {
                    wasWaitingForMessageOfSize: this.sizeOfNextLargeMessage,
                })));
            };
        });
    }
    destroyConnection(disconnectInfo) {
        var _a;
        this.checkAndHandleSuspend();
        Logger_1.logger.warn(`t: ${Date.now() - this.connectionInitTime} : destroying connection`);
        this.cancelGsFetch();
        if (this.ws) {
            this.ws.onopen = () => { };
            this.ws.onclose = () => { };
            this.ws.onmessage = () => { };
            this.ws.onerror = () => { };
            try {
                const disconnectInfoCode = (_a = disconnectInfo === null || disconnectInfo === void 0 ? void 0 : disconnectInfo.code) !== null && _a !== void 0 ? _a : 0;
                if (disconnectInfoCode >= 4000 || disconnectInfoCode === responseCodes_1.GameWsCloseCode.NORMAL_CLOSURE) {
                    this.ws.close(disconnectInfo === null || disconnectInfo === void 0 ? void 0 : disconnectInfo.code, disconnectInfo === null || disconnectInfo === void 0 ? void 0 : disconnectInfo.reason);
                }
                else {
                    this.ws.close();
                }
            }
            catch (err) {
                Logger_1.logger.error("error closing connection: " + Logger_1.logger.errString(err));
            }
            this.ws = undefined;
        }
        clearTimeout(this.connectionFailedTimeout);
        this.logDisconnectionStart();
        this._connected = false;
        this.stopHeartbeat();
        this.stopByteTracker();
        this.transactionManager.reset();
        this._eventCountsSinceOpen = {};
        this.gotFirstMessage = false;
        this.sizeOfNextLargeMessage = 0;
        this.ondisconnect(disconnectInfo === null || disconnectInfo === void 0 ? void 0 : disconnectInfo.code, disconnectInfo === null || disconnectInfo === void 0 ? void 0 : disconnectInfo.reason);
    }
    cleanUpAndQueueReconnect(disconnectInfo) {
        var _a, _b;
        this.destroyConnection(disconnectInfo);
        if (Date.now() > this.lastReconnectQueued + RESET_RECONNECT_ATTEMPTS_DELAY) {
            this._reconnectionAttempts = 0;
        }
        this.lastReconnectQueued = Date.now();
        if (this.reconnectTimeout)
            return;
        this.onmetric("reconnect-attempt", Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { attempts: this._reconnectionAttempts, serverUrl: this.serverURL, hasEverFullyConnected: this.hasEverFullyConnected, timeSinceLastSuccessfulFetch: Date.now() - this.lastSuccessfulFetch, timeSinceLastSignOfLife: Date.now() - this.lastSignOfLife, timeSinceLastSuspend: Date.now() - this.lastSuspendDate }));
        let reconnectDelay = Math.min(INITIAL_RECONNECT_DELAY * Math.pow(2, this._reconnectionAttempts), MAX_RECONNECT_DELAY);
        const jitter = 0.25;
        reconnectDelay = reconnectDelay * (1 - jitter + Math.random() * 2 * jitter);
        reconnectDelay = Math.max(INITIAL_RECONNECT_DELAY, reconnectDelay);
        Logger_1.logger.checkpoint(`queuing reconnect after ${this._reconnectionAttempts} recent attempts, ${reconnectDelay}ms`);
        const online = Utils_1.isBrowser ? (_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true : true;
        if (online) {
            this._reconnectionAttempts++;
        }
        this.reconnectTimeout = setTimeout(() => {
            this.reconnectTimeout = null;
            Logger_1.logger.checkpoint("reconnect timer fired, destroying and starting over");
            this.destroyConnection();
            this.createConnection();
        }, reconnectDelay);
    }
    queueOrExecuteEnter(info, spawnToken, targetId) {
        this.wantsToEnter = true;
        if (info) {
            this.tempInitInfo = info;
        }
        if (spawnToken) {
            this.tempSpawnToken = spawnToken;
        }
        if (targetId) {
            this.tempTargetId = targetId;
        }
        if (this._connected) {
            const enterParams = {};
            if (this.tempInitInfo) {
                enterParams.info = this.tempInitInfo;
            }
            if (this.tempSpawnToken) {
                enterParams.spawnToken = this.tempSpawnToken;
            }
            if (this.tempTargetId) {
                enterParams.targetId = this.tempTargetId;
            }
            this.sendAction({
                $case: "enter",
                enter: enterParams,
            });
            this.tempInitInfo = undefined;
            this.tempSpawnToken = undefined;
            this.tempTargetId = undefined;
        }
    }
    exit() {
        this.wantsToEnter = false;
        this.sendAction({
            $case: "exit",
            exit: {},
        });
    }
    processEvent(serverClientEvent) {
        var _a;
        const event = serverClientEvent.event;
        if (!event) {
            Logger_1.logger.error("Nullish server client event; this shouldn't happen! " + serverClientEvent);
            return;
        }
        this._eventCountsSinceOpen[event.$case] = ((_a = this._eventCountsSinceOpen[event.$case]) !== null && _a !== void 0 ? _a : 0) + 1;
        try {
            switch (event.$case) {
                case "serverHeartbeat":
                    this.sendAction({
                        $case: "clientHeartbeat",
                        clientHeartbeat: {},
                    });
                    break;
                case "ready":
                    this.clientUid = event.ready.id;
                    this._connected = true;
                    this.subscriptionHook();
                    if (this.wantsToEnter) {
                        this.queueOrExecuteEnter();
                    }
                    if (this._sendQ.length >= 20) {
                        this.onmetric("large-sendQ", {
                            sendQLength: this._sendQ.length,
                        });
                    }
                    this._sendQ.forEach(({ action, txnId }) => {
                        this.sendAction(action, false, false, txnId);
                    });
                    this._sendQ = [];
                    this.numMoveEventsBuffered = 0;
                    break;
                case "info":
                    Logger_1.logger.log("[info from gs] " + event.info.message);
                    break;
                case "warn":
                    Logger_1.logger.warn("[warn from gs] " + event.warn.message);
                    if (event.warn.message.startsWith(SENDING_LARGE_MESSAGE_WARN)) {
                        this.sizeOfNextLargeMessage = parseInt(event.warn.message.substring(SENDING_LARGE_MESSAGE_WARN.length));
                    }
                    break;
                case "error":
                    Logger_1.logger.error(`[error from gs] ${event.error.code}: ` + event.error.message);
                    break;
                case "transactionStatus": {
                    this.transactionManager.handleTransactionStatusEvent(event.transactionStatus);
                    break;
                }
            }
            this.onevent(serverClientEvent);
        }
        catch (e) {
            Logger_1.logger.error(`Failed to process event ${event.$case} with error: ${Logger_1.logger.errString(e)}`);
            this.onmetric("failed-to-process-event", {
                errorMessage: e instanceof Error ? e.message : "Failed to process event",
                eventName: event.$case,
                serverUrl: this.serverURL,
            });
        }
    }
    sendAction(action, bypass = false, createTxnId = false, txnId) {
        var _a, _b, _c;
        let transaction;
        Logger_1.logger.debug("New action", action.$case);
        if (createTxnId) {
            transaction = this.transactionManager.addTransaction();
            Logger_1.logger.debug("Creating new transaction", transaction.txnId);
            txnId = transaction.txnId;
        }
        if (!this._connected && !bypass) {
            if ((action.$case === "move" && this.numMoveEventsBuffered >= MAX_BUFFERABLE_MOVE_EVENTS) ||
                action.$case === "activelySpeaking" ||
                action.$case === "interact" ||
                action.$case === "triggerItem") {
                Logger_1.logger.debug(`[Engine] dropping ${action.$case} action because we're not connected`);
            }
            else {
                this._sendQ.push({ action, txnId });
                if (action.$case === "move") {
                    this.numMoveEventsBuffered++;
                }
            }
            return transaction === null || transaction === void 0 ? void 0 : transaction.txnPromise;
        }
        try {
            const serializedAction = events_1.ClientServerAction.encode({
                txnId,
                action,
            }).finish();
            this._bufferedAmounts.push((_b = (_a = this.ws) === null || _a === void 0 ? void 0 : _a.bufferedAmount) !== null && _b !== void 0 ? _b : 0);
            if (!this.ws) {
                Logger_1.logger.error(`WebSocket not initialized during ${action.$case}, this should never happen!`);
            }
            (_c = this.ws) === null || _c === void 0 ? void 0 : _c.send(serializedAction);
            this._lastActionSentAt = Date.now();
            this._bytesSentSinceConnect += serializedAction.byteLength;
            return transaction === null || transaction === void 0 ? void 0 : transaction.txnPromise;
        }
        catch (e) {
            if (txnId) {
                this.transactionManager.rejectTransaction(txnId, e instanceof Error ? e.message : "failed to send action");
            }
            Logger_1.logger.error("websocket send error: " + Logger_1.logger.errString(e));
        }
    }
    recordHeartbeatTime(time) {
        if (Math.random() < 0.1) {
            this.onmetric("heartbeat-latency", { value: time, serverUrl: this.serverURL });
        }
        this.latencies.push(time);
    }
    startHeartbeat() {
        if (this._heartbeatInterval)
            return;
        this._heartbeatInterval = setInterval(() => {
            var _a;
            this.checkAndHandleSuspend();
            const start = Date.now();
            (_a = this.sendAction({ $case: "clientBackupHeartbeat", clientBackupHeartbeat: {} }, false, true)) === null || _a === void 0 ? void 0 : _a.then(() => {
                this.recordHeartbeatTime(Date.now() - start);
            }).catch(() => {
                this.recordHeartbeatTime(Date.now() - start);
                this.onmetric("heartbeat-txn-timed-out", { value: 1, serverUrl: this.serverURL });
            });
            if (this.lastSignOfLife < Date.now() - HEARTBEAT_TIMEOUT && this.ws != null) {
                Logger_1.logger.error(`t: ${Date.now() - this.connectionInitTime} : no heartbeat since ${this.lastSignOfLife}, closing connection`);
                this.onmetric("ws-close-timeout", Object.assign({ lastHeartbeat: this.lastSignOfLife, readyState: this.ws.readyState, timeSinceLastSuspend: Date.now() - this.lastSuspendDate, serverUrl: this.serverURL }, (this.sizeOfNextLargeMessage && {
                    wasWaitingForMessageOfSize: this.sizeOfNextLargeMessage,
                })));
                this.cleanUpAndQueueReconnect({
                    code: responseCodes_1.GameWsCloseCode.CONN_TIMED_OUT,
                    reason: `Game Server timed out for ${this.clientUid}. No heartbeat since ${this.lastSignOfLife}`,
                });
                Logger_1.logger.checkpoint("successfully closed ws connection with TIMEOUT code");
            }
        }, HEARTBEAT_INTERVAL);
    }
    stopHeartbeat() {
        clearInterval(this._heartbeatInterval);
        this._heartbeatInterval = null;
    }
    startByteTracker() {
        if (!this._byteTrackerInterval) {
            this._byteTrackerInterval = setInterval(() => {
                if (this._bytesSentSinceConnect === this._lastBytesSent) {
                    Logger_1.logger.warn(`warning: bytes sent hasn't changed in the last 15 seconds, currently ${this._lastBytesSent}`);
                    this.onmetric("no-bytes-sent-recently", { value: 1, serverUrl: this.serverURL });
                }
                if (this._bytesReceivedSinceConnect === this._lastBytesReceived) {
                    Logger_1.logger.warn(`warning: bytes received hasn't changed in the last 15 seconds, currently ${this._lastBytesReceived}`);
                    this.onmetric("no-bytes-recv-recently", { value: 1, serverUrl: this.serverURL });
                }
                this._lastBytesSent = this._bytesSentSinceConnect;
                this._lastBytesReceived = this._bytesReceivedSinceConnect;
            }, 15000);
        }
    }
    stopByteTracker() {
        clearInterval(this._byteTrackerInterval);
        this._byteTrackerInterval = null;
        this._bytesSentSinceConnect = 0;
        this._bytesReceivedSinceConnect = 0;
    }
    startRecordingIntentToConnect() {
        const both = () => (Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { serverUrl: this.serverURL, connected: this._connected, timeSinceLastSuspend: Date.now() - this.lastSuspendDate }));
        this.onmetric("intend-to-be-connected", Object.assign(Object.assign({}, both()), { first: true }));
        this.connectIntentInterval = setInterval(() => this.onmetric("intend-to-be-connected", Object.assign({}, both())), this.CONNECT_INTENT_POST_INTERVAL);
    }
    stopRecordingIntentToConnect() {
        clearInterval(this.connectIntentInterval);
    }
    logDisconnectionStart() {
        if (!this.hasEverFullyConnected || this.disconnectedStartTime) {
            return;
        }
        this.disconnectedStartTime = Date.now();
        this.dcLogTimeout = setTimeout(() => {
            this.dcLogTimeout = 0;
            this.onmetric(`dc-at-least-${this.LOG_THRESH_MS}-ms`, Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { timeSinceLastSuspend: Date.now() - this.lastSuspendDate, timeSinceLastSignOfLife: Date.now() - this.lastSignOfLife, timeSinceLastSuccessfulFetch: Date.now() - this.lastSuccessfulFetch, history: Logger_1.logger.exportHistory().slice(-700) }));
        }, this.LOG_THRESH_MS);
    }
    logInitialSyncComplete() {
        Logger_1.logger.checkpoint(`t: ${Date.now() - this.connectionInitTime} : successfully subscribed and re-synced`);
        if (!this.hasEverFullyConnected) {
            this.onmetric("time-to-first-full-sync", Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { ms: Date.now() - this.startTime }));
        }
        this.hasEverFullyConnected = true;
        if (this.disconnectedStartTime) {
            this.onmetric("dc-length", {
                ms: Date.now() - this.disconnectedStartTime,
                [`preTimeout${this.LOG_THRESH_MS}`]: !!this.dcLogTimeout,
                timeSinceLastSuspend: Date.now() - this.lastSuspendDate,
            });
            this._timeSpentDisconnected.push(Date.now() - this.disconnectedStartTime);
        }
        this.resetDisconnectionTracking();
    }
    resetDisconnectionTracking() {
        this.disconnectedStartTime = 0;
        if (this.dcLogTimeout) {
            clearTimeout(this.dcLogTimeout);
            this.dcLogTimeout = 0;
        }
        if (this.uploadLogTimeout) {
            clearTimeout(this.uploadLogTimeout);
            this.uploadLogTimeout = 0;
        }
        if (this.uploadLogTimeoutLong) {
            clearTimeout(this.uploadLogTimeoutLong);
            this.uploadLogTimeoutLong = 0;
        }
    }
    queueDebugUpload() {
        const uploadDebug = (metricName) => __awaiter(this, void 0, void 0, function* () {
            const testId = (0, uuid_1.v4)();
            this.onmetric(metricName, Object.assign(Object.assign({}, this.getBaseMetricsInfo()), { history: Logger_1.logger.exportHistory().slice(-5000), hasEverFullyConnected: this.hasEverFullyConnected, openAndGettingData: this.gotFirstMessage, testId, timeSinceLastSuccessfulFetch: Date.now() - this.lastSuccessfulFetch }));
            Logger_1.logger.checkpoint(`starting test: ${testId}`);
            const testResult = yield (0, Utils_1.testConnection)(this.serverURL, testId);
            Logger_1.logger.checkpoint(`test ${testId} result just came back: ` +
                Object.entries(testResult).map((l) => l.join(":")));
            this.onmetric("engine-network-test", Object.assign(Object.assign({}, testResult), { testId }));
        });
        if (!this.uploadLogTimeout) {
            this.uploadLogTimeout = setTimeout(() => {
                uploadDebug("31s-to-connect");
            }, 31000);
        }
        if (!this.uploadLogTimeoutLong) {
            this.uploadLogTimeoutLong = setTimeout(() => {
                uploadDebug("120s-to-connect");
            }, 120000);
        }
    }
    checkAndHandleSuspend() {
        const timeSinceLastCheck = Date.now() - this.lastSuspendCheck;
        this.lastSuspendCheck = Date.now();
        if (timeSinceLastCheck < CONSIDERED_SUSPEND_DELAY) {
            this.isThrottled = false;
            return;
        }
        Logger_1.logger.warn(`resume from suspend detected, ${timeSinceLastCheck}ms elapsed`);
        this.lastSuspendDate = Date.now();
        this.isThrottled = true;
        this.resetDisconnectionTracking();
    }
    startSuspendCheck() {
        this.lastSuspendCheck = Date.now();
        this.suspendCheckInterval = setInterval(() => this.checkAndHandleSuspend(), SUSPEND_CHECK_DELAY);
    }
    stopSuspendCheck() {
        clearInterval(this.suspendCheckInterval);
    }
    getBaseMetricsInfo() {
        return {
            usingKube: this.serverURL ? this.serverURL.includes("engine-") : null,
            usingSubdomains: this.serverURL !== this.originalServerURL,
        };
    }
    getGameServerUrl(cancelToken) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debugOverrideServer)
                return this.debugOverrideServer;
            return (0, Utils_1.fetchGameServerAssignment)(cancelToken, this.spaceId, this.debugOverrideHttpServer);
        });
    }
    getMetrics() {
        return {
            connected: this._connected,
            latency: this.latencies.getMetrics(),
            reconnects: {
                recentAttempts: this._reconnectionAttempts,
                timeSpentDisconnectedMs: this._timeSpentDisconnected.getMetrics(),
            },
            bufferedAmount: this._bufferedAmounts.getMetrics(),
            bytesSentSinceConnect: this._bytesSentSinceConnect,
            bytesReceivedSinceConnect: this._bytesReceivedSinceConnect,
            eventCountsSinceOpen: this._eventCountsSinceOpen,
            closeCodeCount: this._closeCounts,
        };
    }
}
exports.Engine = Engine;
//# sourceMappingURL=Engine.js.map