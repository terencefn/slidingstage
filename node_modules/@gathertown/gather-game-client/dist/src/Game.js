"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Game = void 0;
const uuid_1 = require("uuid");
const Logger_1 = require("./Logger");
const gameMap_1 = require("@gathertown/gather-game-common/dist/src/public/gameMap");
const gameState_1 = require("@gathertown/gather-game-common/dist/src/public/gameState");
const player_1 = require("@gathertown/gather-game-common/dist/src/public/player");
const ramda_1 = require("ramda");
const Engine_1 = require("./Engine");
const Utils_1 = require("./Utils");
const GameEventContexts_1 = require("./GameEventContexts");
const MapsAccumulator_1 = require("./MapsAccumulator");
const DefaultSubscriptions_1 = require("./DefaultSubscriptions");
const version_1 = require("./version");
const PlayerChangesMaps_1 = require("./synthetic/events/PlayerChangesMaps");
const responseCodes_1 = require("@gathertown/gather-game-common/dist/src/public/responseCodes");
__exportStar(require("@gathertown/gather-game-common/dist/src/public/events"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/gameMap"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/gameState"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/player"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/position"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/responseCodes"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/remoteWork"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/utils"), exports);
const CHECK_PLAYER_EXISTS_DELAY = 5 * 60 * 1000;
class Game {
    constructor(spaceId, getAuth, onInput, dispatchGameUpdate, dispatchMapUpdate, options) {
        var _a;
        this.connected = false;
        this.subscriptionFinishedCallback = () => {
            Logger_1.logger.log("default finished subscription callback");
        };
        this._initializedAtMs = 0;
        this._connectedAtMs = 0;
        this.hasSentMapSinceConnect = false;
        this.timeToFirstOnMapsMs = {};
        this._onMapCounts = {};
        this._connectCalledAt = 0;
        this._timeToConnect = -1;
        this.subscriptions = {};
        this.disconnectHandlers = {};
        this.legacySubscriptionsConnection = {};
        this.eventSubscriptions = {};
        this.encIdMapping = {};
        this.playerUidsSeenOnConnect = new Set();
        this.checkForExitsTimeout = setTimeout(() => { });
        this.lastDeployTime = 0;
        this.players = {};
        this.mapsAccumulator = new MapsAccumulator_1.MapsAccumulator();
        this.completeMaps = this.mapsAccumulator.completeMaps;
        this.partialMaps = this.mapsAccumulator.partialMaps;
        this.lastMapUpdateIds = this.mapsAccumulator.lastMapUpdateIds;
        this.inputId = 1;
        this.mapDataChecks = 0;
        this.spaceItems = {};
        this.putMetric = (_name, _value) => {
            if (Utils_1.isBrowser) {
                Logger_1.logger.error("tried to put metric but no metric function provided");
            }
        };
        this.checkForExits = () => {
            Object.keys(this.players)
                .filter((uid) => !this.playerUidsSeenOnConnect.has(uid))
                .forEach((uid, index, array) => {
                var _a;
                const encId = index - array.length;
                this.encIdMapping[encId] = uid;
                (_a = this.engine) === null || _a === void 0 ? void 0 : _a.onevent({
                    event: {
                        $case: "playerExits",
                        playerExits: {
                            encId: encId,
                        },
                    },
                });
            });
        };
        this.isPlayerInPrivateSpace = (player, mapId, privateSpaceId) => {
            var _a, _b;
            if (!this.completeMaps[mapId]) {
                throw new Error("mapId invalid or not yet fully defined. Have you waited for init yet?");
            }
            const nook = (_b = (_a = this.completeMaps[mapId]) === null || _a === void 0 ? void 0 : _a.nooks) === null || _b === void 0 ? void 0 : _b[privateSpaceId];
            if (!nook)
                return false;
            return !!nook.nookCoords.coords.some((c) => c.x === player.x && c.y === player.y);
        };
        if (options === null || options === void 0 ? void 0 : options.logLevels) {
            Logger_1.logger.enabled = Object.assign(Logger_1.logger.enabled, options.logLevels);
        }
        this.getAuth = getAuth;
        this.onInput = onInput;
        this.eventSubscriptions = (_a = options === null || options === void 0 ? void 0 : options.subscribeTo) !== null && _a !== void 0 ? _a : DefaultSubscriptions_1.defaultSubscriptions;
        this.dispatchGameUpdate = dispatchGameUpdate;
        this.dispatchMapUpdate = dispatchMapUpdate;
        if (spaceId) {
            this.init(spaceId, options === null || options === void 0 ? void 0 : options.overrideServer, options === null || options === void 0 ? void 0 : options.overrideHttpServer);
        }
    }
    debug(debugState = true) {
        Logger_1.logger.setDebugState(debugState);
    }
    init(spaceId, _overrideServer, _overrideHttpServer) {
        this.spaceId = spaceId.substring(0, 16) + "\\" + spaceId.substring(17);
        let overrideServer;
        let overrideHttpServer;
        if (Utils_1.isBrowser && window.location.hostname === "localhost") {
            overrideServer = "ws://" + window.location.host + "/__dev-websocket";
        }
        if (_overrideServer) {
            overrideServer = _overrideServer;
        }
        if (_overrideHttpServer) {
            overrideHttpServer = _overrideHttpServer;
        }
        this.engine = new Engine_1.Engine(this.spaceId, this.getAuth, overrideServer, overrideHttpServer);
        this._initializedAtMs = Date.now();
        this.engine.onmetric = (metricName, additionalData) => {
            this.putMetric(metricName, additionalData);
        };
        this.engine.subscriptionHook = () => this.subscribeToAll();
        this.engine.onevent = (serverClientEvent) => {
            var _a, _b, _c;
            const { event } = serverClientEvent;
            if (!event) {
                Logger_1.logger.warn("dropping unrecognized serverClientEvent");
                return;
            }
            Logger_1.logger.debug(serverClientEvent);
            const syntheticEvents = [];
            let context = {
                spaceId: (_a = this.spaceId) !== null && _a !== void 0 ? _a : "",
            };
            const playerDeltas = {};
            switch (event.$case) {
                case "playerJoins": {
                    const { encId } = event.playerJoins;
                    const uid = this.encIdMapping[encId];
                    if (!uid) {
                        throw new Error(`Cannot find playerUid corresponding to encId ${encId}`);
                    }
                    this.playerUidsSeenOnConnect.add(uid);
                    if (!this.players[uid]) {
                        const player = (0, player_1.generateDefaultPlayer)();
                        this.players[uid] = player;
                        playerDeltas[uid] = Object.assign({}, player);
                    }
                    break;
                }
                case "playerExits": {
                    const { encId } = event.playerExits;
                    const uid = this.encIdMapping[encId];
                    if (!uid) {
                        throw new Error(`Cannot find playerUid corresponding to encId ${encId}`);
                    }
                    playerDeltas[uid] = gameState_1.GAME_STATE_PLAYER_DISCONNECT_SYMBOL;
                    context.player = this.players[uid];
                    context.playerId = uid;
                    delete this.players[uid];
                    break;
                }
                case "playerLeavesWhisper": {
                    const { encId } = event.playerLeavesWhisper;
                    const uid = this.encIdMapping[encId];
                    if (!uid) {
                        throw new Error(`Cannot find playerUid corresponding to encId ${encId}`);
                    }
                    playerDeltas[uid] = { whisperId: "" };
                    const player = this.players[uid];
                    if (!player) {
                        Logger_1.logger.error("Dropping a playerLeavesWhisper event received before a playerJoins!");
                        break;
                    }
                    player.whisperId = "";
                    break;
                }
                case "spaceSetsIdMapping": {
                    const { uid, encId } = event.spaceSetsIdMapping;
                    this.encIdMapping[encId] = uid;
                    break;
                }
                case "playerChats": {
                    const { senderId } = event.playerChats;
                    context.player = this.players[senderId];
                    break;
                }
                case "playerNotifies": {
                    const { encId } = event.playerNotifies;
                    const uid = this.encIdMapping[encId];
                    if (!uid) {
                        throw new Error(`Cannot find playerUid corresponding to encId ${encId}`);
                    }
                    context.player = this.players[uid];
                    break;
                }
                case "playerUpdatesInventory": {
                    const { encId, items, order } = event.playerUpdatesInventory;
                    const uid = this.getPlayerUidFromEncId(encId);
                    if (!uid) {
                        Logger_1.logger.error(`missing encId ${encId} for event: ${event.$case}`);
                        break;
                    }
                    const player = this.getPlayer(uid);
                    if (!player) {
                        Logger_1.logger.error(`Dropping a ${event.$case} event received before a playerJoins!`);
                        break;
                    }
                    (0, ramda_1.forEachObjIndexed)((item, itemId) => {
                        if (item.count > 0) {
                            player.inventory.items = Object.assign(Object.assign({}, player.inventory.items), { [itemId]: item });
                        }
                        else {
                            player.inventory.items = (0, ramda_1.omit)([itemId.toString()], player.inventory.items);
                        }
                    }, items);
                    (0, ramda_1.forEachObjIndexed)((itemId, coord) => {
                        if (itemId === "") {
                            player.inventory.order = (0, ramda_1.omit)([coord.toString()], player.inventory.order);
                        }
                        else {
                            player.inventory.order = Object.assign(Object.assign({}, player.inventory.order), { [coord]: itemId });
                        }
                    }, order);
                    break;
                }
                case "spaceUpdatesItems": {
                    const { items } = event.spaceUpdatesItems;
                    this.spaceItems = Object.assign(Object.assign({}, this.spaceItems), items);
                    break;
                }
                case "playerSetsImagePointer":
                case "playerInteracts":
                case "customEvent":
                case "ready":
                case "serverHeartbeat":
                case "info":
                case "warn":
                case "error":
                case "transactionStatus":
                case "playerTriggersInventoryItem":
                    break;
                default: {
                    const eventAny = event;
                    const eventVal = eventAny[eventAny.$case];
                    const encId = eventVal === null || eventVal === void 0 ? void 0 : eventVal.encId;
                    if (event.$case.startsWith("map")) {
                        const completedMap = this.mapsAccumulator.addChunk(event);
                        if (!completedMap) {
                            break;
                        }
                        (_b = this.dispatchMapUpdate) === null || _b === void 0 ? void 0 : _b.call(this, completedMap.id, completedMap);
                        if (!this.hasSentMapSinceConnect) {
                            this.hasSentMapSinceConnect = true;
                            Logger_1.logger.checkpoint(`gt: ${Date.now() - this._connectedAtMs} : doing first onmap since connect`);
                        }
                        if (!this.timeToFirstOnMapsMs[completedMap.id]) {
                            this.timeToFirstOnMapsMs[completedMap.id] = Date.now() - this._connectedAtMs;
                            this.putMetric("time-to-first-map-data-ms", {
                                mapId: completedMap.id,
                                timeToMapDataMs: this.timeToFirstOnMapsMs[completedMap.id],
                            });
                            this.mapDataCheckInterval && clearInterval(this.mapDataCheckInterval);
                        }
                        if (!this._onMapCounts[completedMap.id]) {
                            this._onMapCounts[completedMap.id] = 0;
                        }
                        this._onMapCounts[completedMap.id] += 1;
                    }
                    else if (event.$case.startsWith("player") && encId != null) {
                        if (event.$case === "playerMoves") {
                            (0, PlayerChangesMaps_1.generatePlayerChangesMapsEvent)(event, this, syntheticEvents);
                        }
                        const uids = [];
                        const fetchedUid = this.encIdMapping[encId];
                        if (fetchedUid != null) {
                            uids.push(fetchedUid);
                        }
                        else {
                            Logger_1.logger.error(`missing encId ${encId} for event: ${eventAny.$case}`);
                        }
                        if (eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget) {
                            const uidTarget = this.encIdMapping[eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget];
                            if (uidTarget != null) {
                                uids.push(uidTarget);
                            }
                            else {
                                Logger_1.logger.error(`missing encTargetId: ${eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget} in event: ${eventAny.$case}`);
                            }
                        }
                        for (const entry in eventVal) {
                            for (const uid of uids) {
                                if (entry === "encId" || entry === "encIdTarget" || eventVal[entry] === undefined) {
                                    continue;
                                }
                                const player = this.players[uid];
                                if (!player) {
                                    Logger_1.logger.error(`Dropping a ${event.$case} event received before a playerJoins!`);
                                    continue;
                                }
                                if (!playerDeltas[uid]) {
                                    playerDeltas[uid] = {};
                                }
                                const playerRecord = player;
                                const playerDeltaRecord = playerDeltas[uid];
                                if (entry === "mapId") {
                                    playerDeltaRecord["map"] = eventVal[entry];
                                    player.map = eventVal[entry];
                                }
                                else {
                                    playerRecord[entry] = eventVal[entry];
                                    playerDeltaRecord[entry] = eventVal[entry];
                                }
                            }
                        }
                    }
                }
            }
            (_c = this.dispatchGameUpdate) === null || _c === void 0 ? void 0 : _c.call(this, playerDeltas);
            context = (0, GameEventContexts_1.fillOrCreateContext)(event, this, context);
            this.publishEvent(event.$case, event, context);
            syntheticEvents.forEach((syntheticEvent) => {
                this.publishEvent(syntheticEvent.$case, syntheticEvent, context);
            });
        };
        this.engine.onconnect = () => {
            this._connectedAtMs = Date.now();
            this._timeToConnect = this._connectedAtMs - this._connectCalledAt;
            this.hasSentMapSinceConnect = false;
            this._startMapDataCheckInterval();
            Object.values(this.legacySubscriptionsConnection).forEach((f) => {
                f(true);
            });
        };
        this.engine.ondisconnect = (code, reason) => {
            this.playerUidsSeenOnConnect.clear();
            clearTimeout(this.checkForExitsTimeout);
            if (code === responseCodes_1.GameWsCloseCode.GOING_AWAY) {
                this.lastDeployTime = Date.now();
            }
            Object.values(this.legacySubscriptionsConnection).forEach((f) => {
                f(false);
            });
            for (const id in this.disconnectHandlers) {
                const handler = this.disconnectHandlers[id];
                handler ? handler(code, reason) : Logger_1.logger.warn(`Undefined handler with id ${id}`);
            }
        };
    }
    connect() {
        if (!this.spaceId || !this.engine) {
            throw new Error("game client has not been initialized");
        }
        if (this.connected)
            return;
        this.connected = true;
        this._connectCalledAt = Date.now();
        Logger_1.logger.log("connecting to " + this.spaceId);
        this.updateSubscriptionsPromise = new Promise((res, _rej) => {
            this.subscriptionFinishedCallback = res;
        });
        return this.engine.start();
    }
    waitForInit() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.updateSubscriptionsPromise) {
                throw new Error("Waiting for init before connect() called. Call connect() before awaiting init.");
            }
            return this.updateSubscriptionsPromise;
        });
    }
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            let disconnectResolver;
            const disconnectPromise = new Promise((res) => {
                disconnectResolver = res;
            });
            this.subscribeToDisconnection(() => disconnectResolver());
            if (this.engine) {
                Logger_1.logger.log("Disconnecting");
                Logger_1.logger.checkpoint("stopping engine in Game disconnect");
                this.engine.stop();
                this.connected = false;
            }
            if (this.mapDataCheckInterval) {
                clearInterval(this.mapDataCheckInterval);
            }
            yield disconnectPromise;
        });
    }
    getPlayer(uid) {
        return this.players[uid];
    }
    getPlayerUidFromEncId(encId) {
        return this.encIdMapping[encId];
    }
    publishEvent(eventId, data, context) {
        const subMap = this.subscriptions[eventId];
        for (const id in subMap) {
            const subscription = subMap[id];
            try {
                if (subscription.filter && !(subscription === null || subscription === void 0 ? void 0 : subscription.filter(data, context))) {
                    continue;
                }
                subscription.handler(data, context);
            }
            catch (e) {
                Logger_1.logger.error(`error occurred in handler for ${eventId}: ${Logger_1.logger.errString(e)}`);
            }
        }
    }
    subscribeToEvent(eventId, handler, filter) {
        const subscriptionId = (0, uuid_1.v4)();
        const existingSubs = this.subscriptions[eventId];
        const eventSubs = existingSubs !== null && existingSubs !== void 0 ? existingSubs : {};
        eventSubs[subscriptionId] = {
            handler: handler,
            filter: filter,
        };
        this.subscriptions[eventId] = eventSubs;
        return () => {
            const subscriptionsForEvent = this.subscriptions[eventId];
            if (subscriptionsForEvent) {
                delete subscriptionsForEvent[subscriptionId];
            }
        };
    }
    subscribeToConnection(callback) {
        const handle = (0, uuid_1.v4)();
        this.legacySubscriptionsConnection[handle] = callback;
        return () => {
            delete this.legacySubscriptionsConnection[handle];
        };
    }
    subscribeToDisconnection(callback) {
        const handle = (0, uuid_1.v4)();
        this.disconnectHandlers[handle] = callback;
        return () => {
            delete this.disconnectHandlers[handle];
        };
    }
    sendAction(action, useTxn = false) {
        var _a;
        return (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction(action, false, useTxn);
    }
    sendAction2(actionId, actionData, useTxn = false) {
        var _a;
        return (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: actionId,
            [actionId]: actionData,
        }, false, useTxn);
    }
    enter(info, spawnToken, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.queueOrExecuteEnter(info, spawnToken, targetId);
    }
    exit() {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.exit();
    }
    respawn(useTxn) {
        return this.sendAction({
            $case: "respawn",
            respawn: {},
        }, useTxn);
    }
    spawn(spawnToken) {
        this.sendAction({
            $case: "spawn",
            spawn: {
                spawnToken,
            },
        });
    }
    move(dir, stopped = false, targetId) {
        var _a;
        const inputId = this.inputId++;
        (_a = this.onInput) === null || _a === void 0 ? void 0 : _a.call(this, dir, stopped, inputId);
        this.sendAction({
            $case: "move",
            move: {
                dir,
                stopped,
                inputId,
                targetId,
            },
        });
    }
    playSound(src, volume, targetId) {
        this.sendAction({
            $case: "playSound",
            playSound: {
                src,
                volume,
                targetId,
            },
        });
    }
    stopSound(src, targetId) {
        this.sendAction({
            $case: "stopSound",
            stopSound: {
                src,
                targetId,
            },
        });
    }
    ghost(ghost, targetId) {
        this.sendAction({
            $case: "ghost",
            ghost: {
                ghost,
                targetId,
            },
        });
    }
    enterWhisper(recipientId, dir) {
        this.sendAction({
            $case: "enterWhisper",
            enterWhisper: {
                recipientId,
                dir,
            },
        });
    }
    leaveWhisper() {
        this.sendAction({
            $case: "leaveWhisper",
            leaveWhisper: {},
        });
    }
    teleport(mapId, x, y, targetId, direction = player_1.SpriteDirection.Down) {
        this.sendAction({
            $case: "teleport",
            teleport: {
                mapId,
                x,
                y,
                direction,
                targetId,
            },
        });
    }
    ring(user) {
        this.sendAction({
            $case: "ring",
            ring: {
                user,
            },
        });
    }
    block(blockedUserId, blocked) {
        this.sendAction({
            $case: "block",
            block: {
                blockedUserId,
                blocked,
            },
        });
    }
    pointer(objectId, x, y) {
        this.sendAction({
            $case: "setImagePointer",
            setImagePointer: {
                objectId,
                x,
                y,
            },
        });
    }
    wave(user, isReply = false) {
        this.sendAction({
            $case: "wave",
            wave: {
                user,
                isReply,
            },
        });
    }
    screenPointer(screenId, x, y) {
        this.sendAction({
            $case: "setScreenPointer",
            setScreenPointer: {
                screenId,
                x,
                y,
            },
        });
    }
    setActivelySpeaking(activelySpeaking) {
        this.sendAction({
            $case: "activelySpeaking",
            activelySpeaking: {
                activelySpeaking,
            },
        });
    }
    requestMute(target, video) {
        this.sendAction({
            $case: "requestMute",
            requestMute: {
                target,
                video,
            },
        });
    }
    setEmote(emote, targetId, count) {
        this.sendAction({
            $case: "setEmoteV2",
            setEmoteV2: {
                emote,
                count,
                targetId,
            },
        });
    }
    setWorkCondition(workCondition, targetId) {
        this.sendAction({
            $case: "setWorkCondition",
            setWorkCondition: {
                workCondition,
                targetId,
            },
        });
    }
    setAway(away, targetId) {
        this.sendAction({
            $case: "setAway",
            setAway: {
                away,
                targetId,
            },
        });
    }
    setName(name, targetId) {
        this.sendAction({
            $case: "setName",
            setName: {
                name,
                targetId,
            },
        });
    }
    setIsMobile(isMobile) {
        this.sendAction({
            $case: "setIsMobile",
            setIsMobile: {
                isMobile,
            },
        });
    }
    setTextStatus(textStatus, targetId) {
        this.sendAction({
            $case: "setTextStatus",
            setTextStatus: {
                textStatus,
                targetId,
            },
        });
    }
    setEmojiStatus(emojiStatus, targetId) {
        this.sendAction({
            $case: "setEmojiStatus",
            setEmojiStatus: {
                emojiStatus,
                targetId,
            },
        });
    }
    setPronouns(pronouns, targetId) {
        this.sendAction({
            $case: "setPronouns",
            setPronouns: {
                pronouns,
                targetId,
            },
        });
    }
    setTimezone(timezone, targetId) {
        this.sendAction({
            $case: "setTimezone",
            setTimezone: {
                timezone,
                targetId,
            },
        });
    }
    setTitle(title, targetId) {
        this.sendAction({
            $case: "setTitle",
            setTitle: {
                title,
                targetId,
            },
        });
    }
    setPhone(phone, targetId) {
        this.sendAction({
            $case: "setPhone",
            setPhone: {
                phone,
                targetId,
            },
        });
    }
    setDescription(description, targetId) {
        this.sendAction({
            $case: "setDescription",
            setDescription: {
                description,
                targetId,
            },
        });
    }
    setProfileImageUrl(profileImageUrl, targetId) {
        this.sendAction({
            $case: "setProfileImageUrl",
            setProfileImageUrl: {
                profileImageUrl,
                targetId,
            },
        });
    }
    setPersonalImageUrl(personalImageUrl, targetId) {
        this.sendAction({
            $case: "setPersonalImageUrl",
            setPersonalImageUrl: {
                personalImageUrl,
                targetId,
            },
        });
    }
    setAffiliation(affiliation, targetId) {
        this.sendAction({
            $case: "setAffiliation",
            setAffiliation: {
                affiliation,
                targetId,
            },
        });
    }
    setStatus(status, targetId) {
        this.sendAction({
            $case: "setStatus",
            setStatus: {
                status,
                targetId,
            },
        });
    }
    setEventStatus(eventStatus, targetId) {
        this.sendAction({
            $case: "setEventStatus",
            setEventStatus: {
                eventStatus,
                targetId,
            },
        });
    }
    setInConversation(inConversation, targetId) {
        this.sendAction({
            $case: "setInConversation",
            setInConversation: {
                inConversation,
                targetId,
            },
        });
    }
    setCurrentDesk(currentDesk, targetId) {
        this.sendAction({
            $case: "setCurrentDesk",
            setCurrentDesk: {
                currentDesk,
                targetId,
            },
        });
    }
    setCurrentArea(currentArea, targetId) {
        this.sendAction({
            $case: "setCurrentArea",
            setCurrentArea: {
                currentArea,
                targetId,
            },
        });
    }
    setOutfitString(outfitString, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setOutfitString",
            setOutfitString: {
                outfitString,
                targetId,
            },
        });
    }
    clearItem(targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setItemString",
            setItemString: {
                itemString: "",
                targetId,
            },
        });
    }
    setItem(itemId, itemImage, targetId) {
        var _a;
        const itemString = itemId
            ? JSON.stringify({
                id: itemId,
                image: itemImage,
            })
            : "";
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setItemString",
            setItemString: {
                itemString,
                targetId,
            },
        });
    }
    triggerItem(closestObject, closestObjectTemplate) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "triggerItem",
            triggerItem: {
                closestObject,
                closestObjectTemplate,
            },
        });
    }
    setSpotlight(user, spotlighted) {
        this.sendAction({
            $case: "spotlight",
            spotlight: {
                spotlightedUser: user,
                isSpotlighted: spotlighted,
            },
        });
    }
    banPlayer(user) {
        this.sendAction({
            $case: "ban",
            ban: {
                user,
            },
        });
    }
    kickPlayer(user) {
        this.sendAction({
            $case: "kick",
            kick: {
                user,
            },
        });
    }
    interact(objId, mapId, data) {
        this.sendAction({
            $case: "interact",
            interact: {
                objId,
                mapId,
                dataJson: JSON.stringify(data),
            },
        });
    }
    chat(chatRecipient, localPlayers, mapId, data) {
        this.sendAction({
            $case: "chat",
            chat: Object.assign({ chatRecipient, localPlayerIds: localPlayers, mapId }, data),
        });
    }
    chatMessageUpdated(message) {
        this.sendAction({
            $case: "chatMessageUpdated",
            chatMessageUpdated: message,
        });
    }
    registerCommand(command) {
        return this.sendAction({
            $case: "registerCommand",
            registerCommand: {
                command,
            },
        }, true);
    }
    sendCommand(command, targetId) {
        this.sendAction({
            $case: "sendCommand",
            sendCommand: {
                command,
                targetId,
            },
        });
    }
    notify(notification) {
        this.sendAction({
            $case: "notify",
            notify: {
                notification,
            },
        });
    }
    shootConfetti(targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "shootConfetti",
            shootConfetti: {
                targetId,
            },
        });
    }
    setVehicleId(vehicleId, action, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setVehicleId",
            setVehicleId: {
                vehicleId,
                targetId,
                action,
            },
        });
    }
    setSpeedModifier(speedModifier, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setSpeedModifier",
            setSpeedModifier: {
                speedModifier,
                targetId,
            },
        });
    }
    setIsAlone(isAlone, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setIsAlone",
            setIsAlone: {
                isAlone,
                targetId,
            },
        });
    }
    setFocusModeEndTime(focusModeEndTime, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setFocusModeEndTime",
            setFocusModeEndTime: {
                focusModeEndTime,
                targetId,
            },
        });
    }
    setFollowTarget(followTarget, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setFollowTarget",
            setFollowTarget: {
                followTarget,
                targetId,
            },
        });
    }
    enterPortal(targetUrl, targetId, bypassPrompt) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "enterPortal",
            enterPortal: {
                targetUrl,
                targetId,
                bypassPrompt,
            },
        });
    }
    setMapDimensions(mapId, width, height) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDimensions",
            mapSetDimensions: {
                mapId,
                width,
                height,
            },
        });
    }
    setMapCollisions(mapId, x, y, w, h, mask) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetCollisions",
            mapSetCollisions: {
                mapId,
                x,
                y,
                w,
                h,
                mask,
            },
        });
    }
    setMapBackgroundImagePath(mapId, backgroundImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetBackgroundImagePath",
            mapSetBackgroundImagePath: {
                mapId,
                backgroundImagePath,
            },
        });
    }
    setMapForegroundImagePath(mapId, foregroundImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetForegroundImagePath",
            mapSetForegroundImagePath: {
                mapId,
                foregroundImagePath,
            },
        });
    }
    setMapSprites(mapId, sprites) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetSprites",
            mapSetSprites: {
                mapId,
                sprites,
            },
        });
    }
    setMapSpawns(mapId, spawns) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetSpawns",
            mapSetSpawns: {
                mapId,
                spawns,
            },
        });
    }
    setMapNooks(mapId, nooks, overwrite = false, useTxn = false) {
        return this.sendAction({
            $case: "mapSetNooks",
            mapSetNooks: {
                mapId,
                nooks,
                overwrite,
            },
        }, useTxn);
    }
    setMapPortals(mapId, portals) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetPortals",
            mapSetPortals: {
                mapId,
                portals,
            },
        });
    }
    requestToJoinNook(nookId, mapId, name) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "requestToJoinNook",
            requestToJoinNook: {
                nookId,
                mapId,
                name,
            },
        });
    }
    updateNookPermission(playerId, nookId, granted) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "updateNookPermission",
            updateNookPermission: {
                playerId,
                nookId,
                granted,
            },
        });
    }
    setMapAnnouncer(mapId, announcer) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetAnnouncer",
            mapSetAnnouncer: {
                mapId,
                announcer,
            },
        });
    }
    setMapObjects(mapId, objects, updatesAreOverwrites) {
        var _a;
        const wireObjects = {};
        Object.keys(objects).reduce((wireObjects, keyString) => {
            const key = parseInt(keyString);
            wireObjects[key] = (0, gameMap_1.convertMapObjectToWireObject)(objects[key]);
            return wireObjects;
        }, wireObjects);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetObjects",
            mapSetObjects: {
                mapId,
                objects: wireObjects,
                updatesAreOverwrites,
            },
        });
    }
    moveMapObject(mapId, objectId, targetWorldPos, durationMs, easing = "Linear") {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapMoveObject",
            mapMoveObject: {
                mapId,
                objectId,
                targetX: targetWorldPos.x,
                targetY: targetWorldPos.y,
                targetXOffset: targetWorldPos.xOffset || 0,
                targetYOffset: targetWorldPos.yOffset || 0,
                duration: durationMs,
                easing,
            },
        });
    }
    fxShakeObject(mapId, targetObjId, intensity = 0.1, durationMs = 1000, mode) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "fxShakeObject",
            fxShakeObject: {
                mapId: mapId,
                targetId: targetObjId,
                intensity,
                durationMs,
                mode,
            },
        });
    }
    fxShakeCamera(mapId, playerId, intensity = 0.1, durationMs = 1000) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "fxShakeCamera",
            fxShakeCamera: {
                intensity,
                durationMs,
                mapId,
                targetUserId: playerId,
            },
        });
    }
    setMapName(mapId, name) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetName",
            mapSetName: {
                mapId,
                name,
            },
        });
    }
    setMapMuteOnEntry(mapId, muteOnEntry) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetMuteOnEntry",
            mapSetMuteOnEntry: {
                mapId,
                muteOnEntry,
            },
        });
    }
    setMapUseDrawnBG(mapId, useDrawnBG) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetUseDrawnBG",
            mapSetUseDrawnBG: {
                mapId,
                useDrawnBG,
            },
        });
    }
    setMapWalls(mapId, walls) {
        var _a;
        const map = this.partialMaps[mapId];
        if (!map.dimensions)
            return;
        const wireWalls = (0, gameMap_1.wallFloorConvertToDB)(walls, map.dimensions);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetWalls",
            mapSetWalls: {
                mapId,
                walls: wireWalls,
            },
        });
    }
    setMapFloors(mapId, floors) {
        var _a;
        const map = this.partialMaps[mapId];
        if (!map.dimensions)
            return;
        const wireFloors = (0, gameMap_1.wallFloorConvertToDB)(floors, map.dimensions);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetFloors",
            mapSetFloors: {
                mapId,
                floors: wireFloors,
            },
        });
    }
    setMapAreas(mapId, areas) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetAreas",
            mapSetAreas: {
                mapId,
                areas,
            },
        });
    }
    setMapMiniMapImagePath(mapId, miniMapImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetMiniMapImagePath",
            mapSetMiniMapImagePath: {
                mapId,
                miniMapImagePath,
            },
        });
    }
    setMapEnabledChats(mapId, enabledChats) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetEnabledChats",
            mapSetEnabledChats: {
                mapId,
                enabledChats,
            },
        });
    }
    setMapDescription(mapId, description) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDescription",
            mapSetDescription: {
                mapId,
                description,
            },
        });
    }
    setMapDecoration(mapId, decoration) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDecoration",
            mapSetDecoration: {
                mapId,
                decoration,
            },
        });
    }
    setMapTutorialTasks(mapId, tutorialTasks) {
        var _a;
        const wireTutorialTasks = (0, gameMap_1.convertTutorialTasksToWireTutorialTasks)(tutorialTasks);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetTutorialTasks",
            mapSetTutorialTasks: {
                mapId,
                tutorialTasks: wireTutorialTasks,
            },
        });
    }
    setImpassable(mapId, x, y, impassable = true) {
        this.sendAction({
            $case: "setImpassable",
            setImpassable: {
                mapId,
                x,
                y,
                impassable,
            },
        });
    }
    getImpassable(mapId, x, y) {
        var _a, _b;
        const currMap = (_a = this.completeMaps) === null || _a === void 0 ? void 0 : _a[mapId];
        if (!currMap) {
            throw new Error("mapId not found: " + mapId);
        }
        const currentImpassable = currMap.collisions;
        if (!((_b = currentImpassable[y]) === null || _b === void 0 ? void 0 : _b[x]))
            return false;
        return true;
    }
    getObject(objId, mapId) {
        var _a, _b, _c;
        const mapIds = mapId ? [mapId] : Object.keys(this.completeMaps);
        for (const mapId of mapIds) {
            const objects = (_b = (_a = this.completeMaps) === null || _a === void 0 ? void 0 : _a[mapId]) === null || _b === void 0 ? void 0 : _b.objects;
            if (!objects) {
                continue;
            }
            for (const key in objects) {
                if (((_c = objects[key]) === null || _c === void 0 ? void 0 : _c.id) === objId)
                    return { mapId: mapId, obj: objects[key] };
            }
        }
        return null;
    }
    setObject(mapId, objId, _obj, useTxnId = false) {
        var _a, _b, _c, _d;
        const obj = Object.assign({}, _obj);
        const currMap = (_a = this.partialMaps) === null || _a === void 0 ? void 0 : _a[mapId];
        if (!currMap) {
            throw new Error("mapId not found: " + mapId);
        }
        if (obj.id && obj.id !== objId) {
            obj.id = objId;
        }
        let key = -1;
        for (const k in (_b = currMap.objects) !== null && _b !== void 0 ? _b : {}) {
            if (((_d = (_c = currMap.objects) === null || _c === void 0 ? void 0 : _c[k]) === null || _d === void 0 ? void 0 : _d.id) === objId) {
                key = parseInt(k);
                break;
            }
        }
        if (key >= 0) {
            return this.sendAction({
                $case: "mapSetObjects",
                mapSetObjects: {
                    mapId,
                    objects: {
                        [key]: (0, gameMap_1.convertMapObjectToWireObject)(obj),
                    },
                },
            }, useTxnId);
        }
        else {
            delete obj.key;
            return this.sendAction({
                $case: "mapAddObject",
                mapAddObject: {
                    mapId,
                    object: (0, gameMap_1.convertMapObjectToWireObject)(obj),
                },
            }, useTxnId);
        }
    }
    deleteObjectByKey(mapId, key, createTxnId = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendAction({
                $case: "mapDeleteObject",
                mapDeleteObject: {
                    mapId,
                    key,
                },
            }, createTxnId);
        });
    }
    deleteObject(mapId, objId, createTxnId = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendAction({
                $case: "mapDeleteObjectById",
                mapDeleteObjectById: {
                    mapId,
                    id: objId,
                },
            }, createTxnId);
        });
    }
    requestToLead(target, snapshot = "") {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendAction({
                $case: "requestToLead",
                requestToLead: {
                    target,
                    snapshot,
                },
            });
        });
    }
    setManualVideoSrc(manualVideoSrc, targetId) {
        return this.sendAction({
            $case: "setManualVideoSrc",
            setManualVideoSrc: {
                manualVideoSrc,
                targetId,
            },
        });
    }
    setSubtitle(subtitle, targetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendAction({
                $case: "setSubtitle",
                setSubtitle: {
                    subtitle,
                    targetId,
                },
            });
        });
    }
    highFive(targetId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.sendAction({
                $case: "highFive",
                highFive: {
                    targetId,
                },
            });
        });
    }
    updateSpaceItems(items) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "updateSpaceItems",
            updateSpaceItems: {
                items,
            },
        });
    }
    addInventoryItem(itemId, delta, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "addInventoryItem",
            addInventoryItem: {
                itemId,
                delta,
                targetId,
            },
        });
    }
    removeInventoryItem(itemId, delta, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "removeInventoryItem",
            removeInventoryItem: {
                itemId,
                delta,
                targetId,
            },
        });
    }
    craft(inputs) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "craft",
            craft: {
                inputs,
            },
        });
    }
    triggerInventoryItem(itemId, abilityId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "triggerInventoryItem",
            triggerInventoryItem: {
                itemId,
                abilityId,
            },
        });
    }
    setAllowScreenPointer(allowScreenPointer) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setAllowScreenPointer",
            setAllowScreenPointer: {
                allowScreenPointer,
            },
        });
    }
    setDeskInfo(deskInfo, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setDeskInfo",
            setDeskInfo: {
                deskInfo,
                targetId,
            },
        });
    }
    getStats() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.engine)
            return {};
        if (this.engine.clientUid === undefined) {
            Logger_1.logger.error("Client uid is undefined in getStats");
        }
        else if (this.players[this.engine.clientUid] === undefined) {
            Logger_1.logger.error("Current player is undefined in getStats");
        }
        const metrics = {
            serverURL: this.engine.serverURL,
            engine: this.engine.getMetrics(),
            wsReadyState: (_a = this.engine.ws) === null || _a === void 0 ? void 0 : _a.readyState,
            timeToConnect: this._timeToConnect,
            timeToFirstOnMapMs: this.timeToFirstOnMapsMs,
            onMapCountsAllTime: this._onMapCounts,
            gameClientAgeMs: Date.now() - this._initializedAtMs,
            numPlayers: Object.keys(this.players).length,
            currentPosition: {
                map: (_c = this.players[(_b = this.engine.clientUid) !== null && _b !== void 0 ? _b : ""]) === null || _c === void 0 ? void 0 : _c.map,
                x: (_e = this.players[(_d = this.engine.clientUid) !== null && _d !== void 0 ? _d : ""]) === null || _e === void 0 ? void 0 : _e.x,
                y: (_g = this.players[(_f = this.engine.clientUid) !== null && _f !== void 0 ? _f : ""]) === null || _g === void 0 ? void 0 : _g.y,
            },
            gameClientVersion: version_1.GAME_CLIENT_VERSION,
        };
        this.putMetric("get-stats", metrics);
        return metrics;
    }
    subscribeToAll() {
        const onSuccess = () => {
            var _a;
            if (Date.now() - this.lastDeployTime < CHECK_PLAYER_EXISTS_DELAY) {
                this.checkForExitsTimeout = setTimeout(() => this.checkForExits(), CHECK_PLAYER_EXISTS_DELAY);
            }
            else {
                this.checkForExits();
            }
            this.subscriptionFinishedCallback();
            (_a = this.engine) === null || _a === void 0 ? void 0 : _a.logInitialSyncComplete();
        };
        this.sendAction({
            $case: "updateSubscriptions",
            updateSubscriptions: {
                subscriptions: this.eventSubscriptions,
                mapUpdateIds: this.lastMapUpdateIds,
            },
        }, true)
            .then(() => {
            onSuccess();
        })
            .catch((err) => {
            if (err.message.includes("Invalid subscriptions")) {
                onSuccess();
                return;
            }
        });
    }
    _startMapDataCheckInterval() {
        this.timeToFirstOnMapsMs = {};
        this.mapDataChecks = 0;
        this.mapDataCheckInterval && clearInterval(this.mapDataCheckInterval);
        this.mapDataCheckInterval = setInterval(() => {
            this.mapDataChecks += 1;
            this.putMetric(`still-no-map-data-ms`, {
                gameClientAgeMs: Date.now() - this._initializedAtMs,
                mapDataChecksCount: this.mapDataChecks,
                timeToFirstMapDataMs: this.timeToFirstOnMapsMs,
            });
        }, 2500);
    }
    getDebugHistory() {
        return Logger_1.logger.exportHistory();
    }
    getPlayersInMap(mapId) {
        if (!this.completeMaps[mapId]) {
            throw new Error("Can't get players in map: no map for " + mapId);
        }
        const sameMapPlayers = Object.values(this.players).filter((player) => player.map === mapId);
        return sameMapPlayers;
    }
    getKnownPartialMaps() {
        return Object.keys(this.partialMaps);
    }
    getKnownCompletedMaps() {
        return Object.keys(this.completeMaps);
    }
    filterObjectsInSpace(filter) {
        const foundObjects = [];
        this.getKnownCompletedMaps().forEach((mapId) => {
            foundObjects.push(...this.filterObjectsInMap(mapId, filter));
        });
        return foundObjects;
    }
    filterObjectsInMap(mapId, filter) {
        const map = this.partialMaps[mapId];
        if (!map) {
            throw new Error("Can't filter objects in map: no map for " + mapId);
        }
        if (!map.objects)
            return [];
        return Object.values(map.objects).filter(filter);
    }
    filterUidsInSpace(filter) {
        return Object.keys(this.players).filter((key) => {
            const player = this.players[key];
            if (player)
                return filter(player);
            return false;
        });
    }
    filterPlayersInSpace(filter) {
        return Object.values(this.players).filter(filter);
    }
    hipToBeSquare(hipToBeSquare) {
        this.sendAction({
            $case: "hipToBeSquare",
            hipToBeSquare,
        });
    }
    patchGatherEventsSpaceSession(speakerUpdatesSession) {
        this.sendAction({
            $case: "speakerUpdatesSession",
            speakerUpdatesSession,
        });
    }
    getMyPlayer() {
        var _a;
        if (!((_a = this.engine) === null || _a === void 0 ? void 0 : _a.clientUid)) {
            throw new Error("Client has not received ready event from server and is still connecting");
        }
        const currentPlayer = this.players[this.engine.clientUid];
        if (!currentPlayer) {
            throw new Error("Current player not found. Did you call game.enter?");
        }
        return currentPlayer;
    }
}
exports.Game = Game;
//# sourceMappingURL=Game.js.map