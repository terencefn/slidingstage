"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
exports.__esModule = true;
exports.Game = void 0;
var uuid_1 = require("uuid");
var Logger_1 = require("./Logger");
var gameMap_1 = require("@gathertown/gather-game-common/dist/src/public/gameMap");
var gameState_1 = require("@gathertown/gather-game-common/dist/src/public/gameState");
var player_1 = require("@gathertown/gather-game-common/dist/src/public/player");
var ramda_1 = require("ramda");
var Engine_1 = require("./Engine");
var Utils_1 = require("./Utils");
var GameEventContexts_1 = require("./GameEventContexts");
var MapsAccumulator_1 = require("./MapsAccumulator");
var DefaultSubscriptions_1 = require("./DefaultSubscriptions");
var version_1 = require("./version");
var PlayerChangesMaps_1 = require("./synthetic/events/PlayerChangesMaps");
__exportStar(require("@gathertown/gather-game-common/dist/src/public/events"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/factories"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/gameMap"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/gameState"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/player"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/position"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/responseCodes"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/remoteWork"), exports);
__exportStar(require("@gathertown/gather-game-common/dist/src/public/utils"), exports);
var Game = (function () {
    function Game(spaceId, getAuth, onInput, dispatchGameUpdate, dispatchMapUpdate, options) {
        var _this = this;
        var _a;
        this.connected = false;
        this.subscriptionFinishedCallback = function () {
            Logger_1.logger.log("default finished subscription callback");
        };
        this._initializedAtMs = 0;
        this._connectedAtMs = 0;
        this.hasSentMapSinceConnect = false;
        this.timeToFirstOnMapsMs = {};
        this._onMapCounts = {};
        this._connectCalledAt = 0;
        this._timeToConnect = -1;
        this.subscriptions = {};
        this.disconnectHandlers = {};
        this.legacySubscriptionsConnection = {};
        this.eventSubscriptions = {};
        this.encIdMapping = {};
        this.players = {};
        this.mapsAccumulator = new MapsAccumulator_1.MapsAccumulator();
        this.completeMaps = this.mapsAccumulator.completeMaps;
        this.partialMaps = this.mapsAccumulator.partialMaps;
        this.lastMapUpdateIds = this.mapsAccumulator.lastMapUpdateIds;
        this.inputId = 1;
        this.mapDataChecks = 0;
        this.spaceItems = {};
        this.putMetric = function (_name, _value) {
            if (Utils_1.isBrowser) {
                Logger_1.logger.error("tried to put metric but no metric function provided");
            }
        };
        this.isPlayerInPrivateSpace = function (player, mapId, privateSpaceId) {
            var _a;
            if (!_this.completeMaps[mapId]) {
                throw new Error("mapId invalid or not yet fully defined. Have you waited for init yet?");
            }
            var spaces = (_a = _this.completeMaps[mapId]) === null || _a === void 0 ? void 0 : _a.spaces;
            if (!spaces) {
                return false;
            }
            return !!spaces.some(function (space) { return space.spaceId === privateSpaceId && space.x === player.x && space.y === player.y; });
        };
        if (options === null || options === void 0 ? void 0 : options.logLevels) {
            Logger_1.logger.enabled = Object.assign(Logger_1.logger.enabled, options.logLevels);
        }
        this.getAuth = getAuth;
        this.onInput = onInput;
        this.eventSubscriptions = (_a = options === null || options === void 0 ? void 0 : options.subscribeTo) !== null && _a !== void 0 ? _a : DefaultSubscriptions_1.defaultSubscriptions;
        this.dispatchGameUpdate = dispatchGameUpdate;
        this.dispatchMapUpdate = dispatchMapUpdate;
        this.engine = undefined;
        if (spaceId) {
            this.init(spaceId, options === null || options === void 0 ? void 0 : options.overrideServer);
        }
    }
    Game.prototype.debug = function (debugState) {
        if (debugState === void 0) { debugState = true; }
        Logger_1.logger.setDebugState(debugState);
    };
    Game.prototype.init = function (spaceId, _overrideServer) {
        this.spaceId = spaceId.substring(0, 16) + "\\" + spaceId.substring(17);
        var overrideServer;
        if (Utils_1.isBrowser && window.location.hostname === "localhost") {
            overrideServer = "ws://" + window.location.host + "/__dev-websocket";
        }
        if (_overrideServer) {
            overrideServer = _overrideServer;
        }
        this.engine = new Engine_1.Engine(this.spaceId, this.getAuth, overrideServer);
        this._initializedAtMs = Date.now();
        this._setupEngineCallbacks();
    };
    Game.prototype._setupEngineCallbacks = function () {
        var _this = this;
        this.engine.onmetric = function (metricName, additionalData) {
            _this.putMetric(metricName, additionalData);
        };
        this.engine.subscriptionHook = function () { return _this.subscribeToAll(); };
        this.engine.onevent = function (serverClientEvent) {
            var e_1, _a;
            var _b, _c, _d;
            var event = serverClientEvent.event;
            if (!event) {
                Logger_1.logger.warn("dropping unrecognized serverClientEvent");
                return;
            }
            Logger_1.logger.debug(serverClientEvent);
            var syntheticEvents = [];
            var context = {
                spaceId: (_b = _this.spaceId) !== null && _b !== void 0 ? _b : ""
            };
            var playerDeltas = {};
            switch (event.$case) {
                case "playerJoins": {
                    var encId = event.playerJoins.encId;
                    var uid = _this.encIdMapping[encId];
                    if (!_this.players[uid]) {
                        var player = (0, player_1.generateDefaultPlayer)();
                        _this.players[uid] = player;
                        playerDeltas[uid] = __assign({}, player);
                    }
                    break;
                }
                case "playerExits": {
                    var encId = event.playerExits.encId;
                    var uid = _this.encIdMapping[encId];
                    playerDeltas[uid] = gameState_1.GAME_STATE_PLAYER_DISCONNECT_SYMBOL;
                    context.player = _this.players[uid];
                    delete _this.players[uid];
                    break;
                }
                case "playerLeavesWhisper": {
                    var encId = event.playerLeavesWhisper.encId;
                    var uid = _this.encIdMapping[encId];
                    playerDeltas[uid] = { whisperId: "" };
                    var player = _this.players[uid];
                    if (!player) {
                        Logger_1.logger.error("Dropping a playerLeavesWhisper event received before a playerJoins!");
                        break;
                    }
                    player.whisperId = "";
                    break;
                }
                case "spaceSetsIdMapping": {
                    var _e = event.spaceSetsIdMapping, uid = _e.uid, encId = _e.encId;
                    _this.encIdMapping[encId] = uid;
                    break;
                }
                case "playerChats": {
                    var senderId = event.playerChats.senderId;
                    context.player = _this.players[senderId];
                    break;
                }
                case "playerNotifies": {
                    var encId = event.playerNotifies.encId;
                    var uid = _this.encIdMapping[encId];
                    context.player = _this.players[uid];
                    break;
                }
                case "playerUpdatesInventory": {
                    var _f = event.playerUpdatesInventory, encId = _f.encId, items = _f.items, order = _f.order;
                    var uid = _this.getPlayerUidFromEncId(encId);
                    if (!uid) {
                        Logger_1.logger.error("missing encId ".concat(encId, " for event: ").concat(event.$case));
                        break;
                    }
                    var player_2 = _this.getPlayer(uid);
                    if (!player_2) {
                        Logger_1.logger.error("Dropping a ".concat(event.$case, " event received before a playerJoins!"));
                        break;
                    }
                    (0, ramda_1.forEachObjIndexed)(function (item, itemId) {
                        var _a;
                        if (item.count > 0) {
                            player_2.inventory.items = __assign(__assign({}, player_2.inventory.items), (_a = {}, _a[itemId] = item, _a));
                        }
                        else {
                            player_2.inventory.items = (0, ramda_1.omit)([itemId.toString()], player_2.inventory.items);
                        }
                    }, items);
                    (0, ramda_1.forEachObjIndexed)(function (itemId, index) {
                        var _a;
                        if (itemId === "") {
                            player_2.inventory.order = (0, ramda_1.omit)([index.toString()], player_2.inventory.order);
                        }
                        else {
                            player_2.inventory.order = __assign(__assign({}, player_2.inventory.order), (_a = {}, _a[index] = itemId, _a));
                        }
                    }, order);
                    break;
                }
                case "spaceUpdatesItems": {
                    var items = event.spaceUpdatesItems.items;
                    _this.spaceItems = __assign(__assign({}, _this.spaceItems), items);
                    break;
                }
                case "playerSetsImagePointer":
                case "playerInteracts":
                case "customEvent":
                case "ready":
                case "serverHeartbeat":
                case "info":
                case "warn":
                case "error":
                case "transactionStatus":
                    break;
                default: {
                    var eventAny = event;
                    var eventVal = eventAny[eventAny.$case];
                    var encId = eventVal === null || eventVal === void 0 ? void 0 : eventVal.encId;
                    if (event.$case.startsWith("map")) {
                        var completedMap = _this.mapsAccumulator.addChunk(event);
                        if (!completedMap) {
                            break;
                        }
                        (_c = _this.dispatchMapUpdate) === null || _c === void 0 ? void 0 : _c.call(_this, completedMap.id, completedMap);
                        if (!_this.hasSentMapSinceConnect) {
                            _this.hasSentMapSinceConnect = true;
                            Logger_1.logger.checkpoint("gt: ".concat(Date.now() - _this._connectedAtMs, " : doing first onmap since connect"));
                        }
                        if (!_this.timeToFirstOnMapsMs[completedMap.id]) {
                            _this.timeToFirstOnMapsMs[completedMap.id] = Date.now() - _this._connectedAtMs;
                            _this.putMetric("time-to-first-map-data-ms", {
                                mapId: completedMap.id,
                                timeToMapDataMs: _this.timeToFirstOnMapsMs[completedMap.id]
                            });
                            _this.mapDataCheckInterval && clearInterval(_this.mapDataCheckInterval);
                        }
                        if (!_this._onMapCounts[completedMap.id]) {
                            _this._onMapCounts[completedMap.id] = 0;
                        }
                        _this._onMapCounts[completedMap.id] += 1;
                    }
                    else if (event.$case.startsWith("player") && encId != null) {
                        if (event.$case === "playerMoves") {
                            (0, PlayerChangesMaps_1.generatePlayerChangesMapsEvent)(event, _this, syntheticEvents);
                        }
                        var uids = [];
                        var fetchedUid = _this.encIdMapping[encId];
                        if (fetchedUid != null) {
                            uids.push(fetchedUid);
                        }
                        else {
                            Logger_1.logger.error("missing encId ".concat(encId, " for event: ").concat(eventAny.$case));
                        }
                        if (eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget) {
                            var uidTarget = _this.encIdMapping[eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget];
                            if (uidTarget != null) {
                                uids.push(uidTarget);
                            }
                            else {
                                Logger_1.logger.error("missing encTargetId: ".concat(eventVal === null || eventVal === void 0 ? void 0 : eventVal.encIdTarget, " in event: ").concat(eventAny.$case));
                            }
                        }
                        for (var entry in eventVal) {
                            try {
                                for (var uids_1 = (e_1 = void 0, __values(uids)), uids_1_1 = uids_1.next(); !uids_1_1.done; uids_1_1 = uids_1.next()) {
                                    var uid = uids_1_1.value;
                                    if (entry === "encId" || entry === "encIdTarget" || eventVal[entry] === undefined) {
                                        continue;
                                    }
                                    var player = _this.players[uid];
                                    if (!player) {
                                        Logger_1.logger.error("Dropping a ".concat(event.$case, " event received before a playerJoins!"));
                                        continue;
                                    }
                                    if (!playerDeltas[uid]) {
                                        playerDeltas[uid] = {};
                                    }
                                    var playerRecord = player;
                                    var playerDeltaRecord = playerDeltas[uid];
                                    if (entry === "mapId") {
                                        playerDeltaRecord["map"] = eventVal[entry];
                                        player.map = eventVal[entry];
                                    }
                                    else {
                                        playerRecord[entry] = eventVal[entry];
                                        playerDeltaRecord[entry] = eventVal[entry];
                                    }
                                }
                            }
                            catch (e_1_1) { e_1 = { error: e_1_1 }; }
                            finally {
                                try {
                                    if (uids_1_1 && !uids_1_1.done && (_a = uids_1["return"])) _a.call(uids_1);
                                }
                                finally { if (e_1) throw e_1.error; }
                            }
                        }
                    }
                }
            }
            (_d = _this.dispatchGameUpdate) === null || _d === void 0 ? void 0 : _d.call(_this, playerDeltas);
            context = (0, GameEventContexts_1.fillOrCreateContext)(event, _this, context);
            _this.publishEvent(event.$case, event, context);
            syntheticEvents.forEach(function (syntheticEvent) {
                _this.publishEvent(syntheticEvent.$case, syntheticEvent, context);
            });
        };
        this.engine.onconnect = function () {
            _this._connectedAtMs = Date.now();
            _this._timeToConnect = _this._connectedAtMs - _this._connectCalledAt;
            _this.hasSentMapSinceConnect = false;
            _this._startMapDataCheckInterval();
            Object.values(_this.legacySubscriptionsConnection).forEach(function (f) {
                f(true);
            });
        };
        this.engine.ondisconnect = function (code, reason) {
            Object.values(_this.legacySubscriptionsConnection).forEach(function (f) {
                f(false);
            });
            for (var id in _this.disconnectHandlers) {
                var handler = _this.disconnectHandlers[id];
                handler(code, reason);
            }
        };
    };
    Game.prototype.connect = function () {
        var _this = this;
        if (!this.spaceId) {
            throw new Error("didn't initialize Game properly, no spaceId known");
        }
        if (this.connected) {
            return;
        }
        this.connected = true;
        this._connectCalledAt = Date.now();
        Logger_1.logger.log("connecting to " + this.spaceId);
        this.updateSubscriptionsPromise = new Promise(function (res, _rej) {
            _this.subscriptionFinishedCallback = res;
        });
        return this.engine.start();
    };
    Game.prototype.waitForInit = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!this.updateSubscriptionsPromise) {
                    throw new Error("Waiting for init before connect() called. Call connect() before awaiting init.");
                }
                return [2, this.updateSubscriptionsPromise];
            });
        });
    };
    Game.prototype.disconnect = function () {
        Logger_1.logger.log("Disconnecting");
        if (this.engine) {
            Logger_1.logger.checkpoint("stopping engine in Game disconnect");
            this.engine.stop();
            this.connected = false;
        }
        else {
            Logger_1.logger.warn("Destroying an engine that wasn't created in the first place. Was this space real?");
        }
    };
    Game.prototype.getPlayer = function (uid) {
        return this.players[uid];
    };
    Game.prototype.getPlayerUidFromEncId = function (encId) {
        return this.encIdMapping[encId];
    };
    Game.prototype.publishEvent = function (eventId, data, context) {
        var subMap = this.subscriptions[eventId];
        var errors;
        for (var id in subMap) {
            var subscription = subMap[id];
            try {
                if (subscription.filter && !(subscription === null || subscription === void 0 ? void 0 : subscription.filter(data, context))) {
                    continue;
                }
                subscription.handler(data, context);
            }
            catch (e) {
                if (!errors) {
                    errors = [];
                }
                errors.push(e);
            }
        }
        if (errors && errors.length > 0) {
            Logger_1.logger.error("".concat(errors.length, " errors occurred in subscription handlers for event ").concat(eventId, "! See verbose log for more."));
            Logger_1.logger.debug.apply(Logger_1.logger, __spreadArray([], __read(errors.map(function (e) { return e.stack; })), false));
            throw errors;
        }
    };
    Game.prototype.subscribeToEvent = function (eventId, handler, filter) {
        var _this = this;
        var subscriptionId = (0, uuid_1.v4)();
        var existingSubs = this.subscriptions[eventId];
        var eventSubs = existingSubs !== null && existingSubs !== void 0 ? existingSubs : {};
        eventSubs[subscriptionId] = {
            handler: handler,
            filter: filter
        };
        this.subscriptions[eventId] = eventSubs;
        return function () {
            var _a;
            (_a = _this.subscriptions[eventId]) === null || _a === void 0 ? true : delete _a[subscriptionId];
        };
    };
    Game.prototype.subscribeToConnection = function (callback) {
        var _this = this;
        var handle = (0, uuid_1.v4)();
        this.legacySubscriptionsConnection[handle] = callback;
        return function () {
            delete _this.legacySubscriptionsConnection[handle];
        };
    };
    Game.prototype.subscribeToDisconnection = function (callback) {
        var _this = this;
        var handle = (0, uuid_1.v4)();
        this.disconnectHandlers[handle] = callback;
        return function () {
            delete _this.disconnectHandlers[handle];
        };
    };
    Game.prototype.enter = function (info, spawnToken, targetId) {
        this.engine.queueOrExecuteEnter(info, spawnToken, targetId);
    };
    Game.prototype.exit = function () {
        this.engine.exit();
    };
    Game.prototype.respawn = function (useTxn) {
        var _a;
        return (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "respawn",
            respawn: {}
        }, false, useTxn);
    };
    Game.prototype.spawn = function (spawnToken) {
        this.engine.sendAction({
            $case: "spawn",
            spawn: {
                spawnToken: spawnToken
            }
        });
    };
    Game.prototype.move = function (dir, stopped, targetId) {
        var _a;
        if (stopped === void 0) { stopped = false; }
        var inputId = this.inputId++;
        (_a = this.onInput) === null || _a === void 0 ? void 0 : _a.call(this, dir, stopped, inputId);
        this.engine.sendAction({
            $case: "move",
            move: {
                dir: dir,
                stopped: stopped,
                inputId: inputId,
                targetId: targetId
            }
        });
    };
    Game.prototype.playSound = function (src, volume, targetId) {
        this.engine.sendAction({
            $case: "playSound",
            playSound: {
                src: src,
                volume: volume,
                targetId: targetId
            }
        });
    };
    Game.prototype.ghost = function (ghost, targetId) {
        this.engine.sendAction({
            $case: "ghost",
            ghost: {
                ghost: ghost,
                targetId: targetId
            }
        });
    };
    Game.prototype.enterWhisper = function (recipientId, dir) {
        this.engine.sendAction({
            $case: "enterWhisper",
            enterWhisper: {
                recipientId: recipientId,
                dir: dir
            }
        });
    };
    Game.prototype.leaveWhisper = function () {
        this.engine.sendAction({
            $case: "leaveWhisper",
            leaveWhisper: {}
        });
    };
    Game.prototype.teleport = function (mapId, x, y, targetId, direction) {
        if (direction === void 0) { direction = player_1.SpriteDirection.Down; }
        this.engine.sendAction({
            $case: "teleport",
            teleport: {
                mapId: mapId,
                x: x,
                y: y,
                direction: direction,
                targetId: targetId
            }
        });
    };
    Game.prototype.ring = function (user) {
        this.engine.sendAction({
            $case: "ring",
            ring: {
                user: user
            }
        });
    };
    Game.prototype.block = function (blockedUserId, blocked) {
        this.engine.sendAction({
            $case: "block",
            block: {
                blockedUserId: blockedUserId,
                blocked: blocked
            }
        });
    };
    Game.prototype.pointer = function (objectId, x, y) {
        this.engine.sendAction({
            $case: "setImagePointer",
            setImagePointer: {
                objectId: objectId,
                x: x,
                y: y
            }
        });
    };
    Game.prototype.screenPointer = function (screenId, x, y) {
        this.engine.sendAction({
            $case: "setScreenPointer",
            setScreenPointer: {
                screenId: screenId,
                x: x,
                y: y
            }
        });
    };
    Game.prototype.setActivelySpeaking = function (activelySpeaking) {
        this.engine.sendAction({
            $case: "activelySpeaking",
            activelySpeaking: {
                activelySpeaking: activelySpeaking
            }
        });
    };
    Game.prototype.setEmote = function (emote, targetId) {
        this.engine.sendAction({
            $case: "setEmoteV2",
            setEmoteV2: {
                emote: emote,
                targetId: targetId
            }
        });
    };
    Game.prototype.setNonVerbalCue = function (nonVerbalCue, targetId) {
        this.engine.sendAction({
            $case: "setNonVerbalCue",
            setNonVerbalCue: {
                nonVerbalCue: nonVerbalCue,
                targetId: targetId
            }
        });
    };
    Game.prototype.setWorkCondition = function (workCondition, targetId) {
        this.engine.sendAction({
            $case: "setWorkCondition",
            setWorkCondition: {
                workCondition: workCondition,
                targetId: targetId
            }
        });
    };
    Game.prototype.setName = function (name, targetId) {
        this.engine.sendAction({
            $case: "setName",
            setName: {
                name: name,
                targetId: targetId
            }
        });
    };
    Game.prototype.setIsMobile = function (isMobile) {
        this.engine.sendAction({
            $case: "setIsMobile",
            setIsMobile: {
                isMobile: isMobile
            }
        });
    };
    Game.prototype.setTextStatus = function (textStatus, targetId) {
        this.engine.sendAction({
            $case: "setTextStatus",
            setTextStatus: {
                textStatus: textStatus,
                targetId: targetId
            }
        });
    };
    Game.prototype.setEmojiStatus = function (emojiStatus, targetId) {
        this.engine.sendAction({
            $case: "setEmojiStatus",
            setEmojiStatus: {
                emojiStatus: emojiStatus,
                targetId: targetId
            }
        });
    };
    Game.prototype.setAffiliation = function (affiliation, targetId) {
        this.engine.sendAction({
            $case: "setAffiliation",
            setAffiliation: {
                affiliation: affiliation,
                targetId: targetId
            }
        });
    };
    Game.prototype.setStatus = function (status, targetId) {
        this.engine.sendAction({
            $case: "setStatus",
            setStatus: {
                status: status,
                targetId: targetId
            }
        });
    };
    Game.prototype.setEventStatus = function (eventStatus, targetId) {
        this.engine.sendAction({
            $case: "setEventStatus",
            setEventStatus: {
                eventStatus: eventStatus,
                targetId: targetId
            }
        });
    };
    Game.prototype.setInConversation = function (inConversation, targetId) {
        this.engine.sendAction({
            $case: "setInConversation",
            setInConversation: {
                inConversation: inConversation,
                targetId: targetId
            }
        });
    };
    Game.prototype.setCurrentDesk = function (currentDesk, targetId) {
        this.engine.sendAction({
            $case: "setCurrentDesk",
            setCurrentDesk: {
                currentDesk: currentDesk,
                targetId: targetId
            }
        });
    };
    Game.prototype.setCurrentArea = function (currentArea, targetId) {
        this.engine.sendAction({
            $case: "setCurrentArea",
            setCurrentArea: {
                currentArea: currentArea,
                targetId: targetId
            }
        });
    };
    Game.prototype.setOutfitString = function (outfitString, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setOutfitString",
            setOutfitString: {
                outfitString: outfitString,
                targetId: targetId
            }
        });
    };
    Game.prototype.clearItem = function (targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setItemString",
            setItemString: {
                itemString: "",
                targetId: targetId
            }
        });
    };
    Game.prototype.setItem = function (itemId, itemImage, targetId) {
        var _a;
        var itemString = itemId
            ? JSON.stringify({
                id: itemId,
                image: itemImage
            })
            : "";
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setItemString",
            setItemString: {
                itemString: itemString,
                targetId: targetId
            }
        });
    };
    Game.prototype.triggerItem = function (closestObject, closestObjectTemplate, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "triggerItem",
            triggerItem: {
                closestObject: closestObject,
                closestObjectTemplate: closestObjectTemplate,
                targetId: targetId
            }
        });
    };
    Game.prototype.setSpotlight = function (user, spotlighted) {
        this.engine.sendAction({
            $case: "spotlight",
            spotlight: {
                spotlightedUser: user,
                isSpotlighted: spotlighted
            }
        });
    };
    Game.prototype.banPlayer = function (user) {
        this.engine.sendAction({
            $case: "ban",
            ban: {
                user: user
            }
        });
    };
    Game.prototype.kickPlayer = function (user) {
        this.engine.sendAction({
            $case: "kick",
            kick: {
                user: user
            }
        });
    };
    Game.prototype.interact = function (objId, data) {
        this.engine.sendAction({
            $case: "interact",
            interact: {
                objId: objId,
                dataJson: JSON.stringify(data)
            }
        });
    };
    Game.prototype.chat = function (chatRecipient, localPlayers, mapId, data) {
        this.engine.sendAction({
            $case: "chat",
            chat: __assign({ chatRecipient: chatRecipient, localPlayerIds: localPlayers, mapId: mapId }, data)
        });
    };
    Game.prototype.chatMessageUpdated = function (message) {
        this.engine.sendAction({
            $case: "chatMessageUpdated",
            chatMessageUpdated: message
        });
    };
    Game.prototype.registerCommand = function (command) {
        return this.engine.sendAction({
            $case: "registerCommand",
            registerCommand: {
                command: command
            }
        }, false, true);
    };
    Game.prototype.sendCommand = function (command, targetId) {
        this.engine.sendAction({
            $case: "sendCommand",
            sendCommand: {
                command: command,
                targetId: targetId
            }
        });
    };
    Game.prototype.notify = function (notification) {
        this.engine.sendAction({
            $case: "notify",
            notify: {
                notification: notification
            }
        });
    };
    Game.prototype.shootConfetti = function (targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "shootConfetti",
            shootConfetti: {
                targetId: targetId
            }
        });
    };
    Game.prototype.setVehicleId = function (vehicleId, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setVehicleId",
            setVehicleId: {
                vehicleId: vehicleId,
                targetId: targetId
            }
        });
    };
    Game.prototype.setSpeedModifier = function (speedModifier, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setSpeedModifier",
            setSpeedModifier: {
                speedModifier: speedModifier,
                targetId: targetId
            }
        });
    };
    Game.prototype.setIsAlone = function (isAlone, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setIsAlone",
            setIsAlone: {
                isAlone: isAlone,
                targetId: targetId
            }
        });
    };
    Game.prototype.setFocusModeEndTime = function (focusModeEndTime, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setFocusModeEndTime",
            setFocusModeEndTime: {
                focusModeEndTime: focusModeEndTime,
                targetId: targetId
            }
        });
    };
    Game.prototype.setFollowTarget = function (followTarget) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "setFollowTarget",
            setFollowTarget: {
                followTarget: followTarget
            }
        });
    };
    Game.prototype.enterPortal = function (targetUrl, targetId, bypassPrompt) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "enterPortal",
            enterPortal: {
                targetUrl: targetUrl,
                targetId: targetId,
                bypassPrompt: bypassPrompt
            }
        });
    };
    Game.prototype.setMapDimensions = function (mapId, width, height) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDimensions",
            mapSetDimensions: {
                mapId: mapId,
                width: width,
                height: height
            }
        });
    };
    Game.prototype.setMapCollisions = function (mapId, x, y, w, h, mask) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetCollisions",
            mapSetCollisions: {
                mapId: mapId,
                x: x,
                y: y,
                w: w,
                h: h,
                mask: mask
            }
        });
    };
    Game.prototype.setMapBackgroundImagePath = function (mapId, backgroundImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetBackgroundImagePath",
            mapSetBackgroundImagePath: {
                mapId: mapId,
                backgroundImagePath: backgroundImagePath
            }
        });
    };
    Game.prototype.setMapForegroundImagePath = function (mapId, foregroundImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetForegroundImagePath",
            mapSetForegroundImagePath: {
                mapId: mapId,
                foregroundImagePath: foregroundImagePath
            }
        });
    };
    Game.prototype.setMapSprites = function (mapId, sprites) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetSprites",
            mapSetSprites: {
                mapId: mapId,
                sprites: sprites
            }
        });
    };
    Game.prototype.setMapSpawns = function (mapId, spawns) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetSpawns",
            mapSetSpawns: {
                mapId: mapId,
                spawns: spawns
            }
        });
    };
    Game.prototype.setMapSpaces = function (mapId, spaces) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetSpaces",
            mapSetSpaces: {
                mapId: mapId,
                spaces: spaces
            }
        });
    };
    Game.prototype.setMapPortals = function (mapId, portals) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetPortals",
            mapSetPortals: {
                mapId: mapId,
                portals: portals
            }
        });
    };
    Game.prototype.setMapAnnouncer = function (mapId, announcer) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetAnnouncer",
            mapSetAnnouncer: {
                mapId: mapId,
                announcer: announcer
            }
        });
    };
    Game.prototype.setMapObjects = function (mapId, objects, updatesAreOverwrites) {
        var _a;
        var wireObjects = {};
        Object.keys(objects).reduce(function (wireObjects, keyString) {
            var key = parseInt(keyString);
            wireObjects[key] = (0, gameMap_1.convertMapObjectToWireObject)(objects[key]);
            return wireObjects;
        }, wireObjects);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetObjects",
            mapSetObjects: {
                mapId: mapId,
                objects: wireObjects,
                updatesAreOverwrites: updatesAreOverwrites
            }
        });
    };
    Game.prototype.moveMapObject = function (mapId, objectId, targetWorldPos, durationMs, easing) {
        var _a;
        if (easing === void 0) { easing = "Linear"; }
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapMoveObject",
            mapMoveObject: {
                mapId: mapId,
                objectId: objectId,
                targetX: targetWorldPos.x,
                targetY: targetWorldPos.y,
                targetXOffset: targetWorldPos.xOffset || 0,
                targetYOffset: targetWorldPos.yOffset || 0,
                duration: durationMs,
                easing: easing
            }
        });
    };
    Game.prototype.fxShakeObject = function (mapId, targetObjId, intensity, durationMs, mode) {
        var _a;
        if (intensity === void 0) { intensity = 0.1; }
        if (durationMs === void 0) { durationMs = 1000; }
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "fxShakeObject",
            fxShakeObject: {
                mapId: mapId,
                targetId: targetObjId,
                intensity: intensity,
                durationMs: durationMs,
                mode: mode
            }
        });
    };
    Game.prototype.fxShakeCamera = function (mapId, playerId, intensity, durationMs) {
        var _a;
        if (intensity === void 0) { intensity = 0.1; }
        if (durationMs === void 0) { durationMs = 1000; }
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "fxShakeCamera",
            fxShakeCamera: {
                intensity: intensity,
                durationMs: durationMs,
                mapId: mapId,
                targetUserId: playerId
            }
        });
    };
    Game.prototype.setMapName = function (mapId, name) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetName",
            mapSetName: {
                mapId: mapId,
                name: name
            }
        });
    };
    Game.prototype.setMapMuteOnEntry = function (mapId, muteOnEntry) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetMuteOnEntry",
            mapSetMuteOnEntry: {
                mapId: mapId,
                muteOnEntry: muteOnEntry
            }
        });
    };
    Game.prototype.setMapUseDrawnBG = function (mapId, useDrawnBG) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetUseDrawnBG",
            mapSetUseDrawnBG: {
                mapId: mapId,
                useDrawnBG: useDrawnBG
            }
        });
    };
    Game.prototype.setMapWalls = function (mapId, walls) {
        var _a;
        var map = this.partialMaps[mapId];
        if (!map.dimensions) {
            return;
        }
        var wireWalls = (0, gameMap_1.wallFloorConvertToDB)(walls, map.dimensions);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetWalls",
            mapSetWalls: {
                mapId: mapId,
                walls: wireWalls
            }
        });
    };
    Game.prototype.setMapFloors = function (mapId, floors) {
        var _a;
        var map = this.partialMaps[mapId];
        if (!map.dimensions) {
            return;
        }
        var wireFloors = (0, gameMap_1.wallFloorConvertToDB)(floors, map.dimensions);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetFloors",
            mapSetFloors: {
                mapId: mapId,
                floors: wireFloors
            }
        });
    };
    Game.prototype.setMapAreas = function (mapId, areas) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetAreas",
            mapSetAreas: {
                mapId: mapId,
                areas: areas
            }
        });
    };
    Game.prototype.setMapMiniMapImagePath = function (mapId, miniMapImagePath) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetMiniMapImagePath",
            mapSetMiniMapImagePath: {
                mapId: mapId,
                miniMapImagePath: miniMapImagePath
            }
        });
    };
    Game.prototype.setMapEnabledChats = function (mapId, enabledChats) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetEnabledChats",
            mapSetEnabledChats: {
                mapId: mapId,
                enabledChats: enabledChats
            }
        });
    };
    Game.prototype.setMapDescription = function (mapId, description) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDescription",
            mapSetDescription: {
                mapId: mapId,
                description: description
            }
        });
    };
    Game.prototype.setMapDecoration = function (mapId, decoration) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetDecoration",
            mapSetDecoration: {
                mapId: mapId,
                decoration: decoration
            }
        });
    };
    Game.prototype.setMapTutorialTasks = function (mapId, tutorialTasks) {
        var _a;
        var wireTutorialTasks = (0, gameMap_1.convertTutorialTasksToWireTutorialTasks)(tutorialTasks);
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "mapSetTutorialTasks",
            mapSetTutorialTasks: {
                mapId: mapId,
                tutorialTasks: wireTutorialTasks
            }
        });
    };
    Game.prototype.setImpassable = function (mapId, x, y, impassable) {
        if (impassable === void 0) { impassable = true; }
        this.engine.sendAction({
            $case: "setImpassable",
            setImpassable: {
                mapId: mapId,
                x: x,
                y: y,
                impassable: impassable
            }
        });
    };
    Game.prototype.getImpassable = function (mapId, x, y) {
        var _a, _b;
        var currMap = (_a = this.completeMaps) === null || _a === void 0 ? void 0 : _a[mapId];
        if (!currMap) {
            throw new Error("mapId not found: " + mapId);
        }
        var currentImpassable = currMap.collisions;
        if (((_b = currentImpassable[y]) === null || _b === void 0 ? void 0 : _b[x]) === false) {
            return false;
        }
        return true;
    };
    Game.prototype.getObject = function (objId, mapId) {
        var e_2, _a;
        var _b, _c, _d;
        var mapIds = mapId ? [mapId] : Object.keys(this.completeMaps);
        try {
            for (var mapIds_1 = __values(mapIds), mapIds_1_1 = mapIds_1.next(); !mapIds_1_1.done; mapIds_1_1 = mapIds_1.next()) {
                var mapId_1 = mapIds_1_1.value;
                var objects = (_c = (_b = this.completeMaps) === null || _b === void 0 ? void 0 : _b[mapId_1]) === null || _c === void 0 ? void 0 : _c.objects;
                if (!objects) {
                    continue;
                }
                for (var key in objects) {
                    if (((_d = objects[key]) === null || _d === void 0 ? void 0 : _d.id) === objId) {
                        return { mapId: mapId_1, obj: objects[key] };
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (mapIds_1_1 && !mapIds_1_1.done && (_a = mapIds_1["return"])) _a.call(mapIds_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return null;
    };
    Game.prototype.setObject = function (mapId, objId, obj, useTxnId) {
        var _a;
        var _b, _c, _d, _e;
        if (useTxnId === void 0) { useTxnId = false; }
        var currMap = (_b = this.completeMaps) === null || _b === void 0 ? void 0 : _b[mapId];
        if (!currMap) {
            throw new Error("mapId not found: " + mapId);
        }
        var key = -1;
        for (var k in (_c = currMap.objects) !== null && _c !== void 0 ? _c : {}) {
            if (((_e = (_d = currMap.objects) === null || _d === void 0 ? void 0 : _d[k]) === null || _e === void 0 ? void 0 : _e.id) === objId) {
                key = parseInt(k);
                break;
            }
        }
        if (key >= 0) {
            return this.engine.sendAction({
                $case: "mapSetObjects",
                mapSetObjects: {
                    mapId: mapId,
                    objects: (_a = {},
                        _a[key] = (0, gameMap_1.convertMapObjectToWireObject)(obj),
                        _a)
                }
            }, false, useTxnId);
        }
        else {
            return this.engine.sendAction({
                $case: "mapAddObject",
                mapAddObject: {
                    mapId: mapId,
                    object: (0, gameMap_1.convertMapObjectToWireObject)(obj)
                }
            }, false, useTxnId);
        }
    };
    Game.prototype.deleteObjectByKey = function (mapId, key, createTxnId) {
        if (createTxnId === void 0) { createTxnId = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "mapDeleteObject",
                        mapDeleteObject: {
                            mapId: mapId,
                            key: key
                        }
                    }, false, createTxnId)];
            });
        });
    };
    Game.prototype.deleteObject = function (mapId, objId, createTxnId) {
        if (createTxnId === void 0) { createTxnId = false; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "mapDeleteObjectById",
                        mapDeleteObjectById: {
                            mapId: mapId,
                            id: objId
                        }
                    }, false, createTxnId)];
            });
        });
    };
    Game.prototype.requestToLead = function (target, snapshot) {
        if (snapshot === void 0) { snapshot = ""; }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "requestToLead",
                        requestToLead: {
                            target: target,
                            snapshot: snapshot
                        }
                    })];
            });
        });
    };
    Game.prototype.setManualVideoSrc = function (manualVideoSrc, targetId) {
        return this.engine.sendAction({
            $case: "setManualVideoSrc",
            setManualVideoSrc: {
                manualVideoSrc: manualVideoSrc,
                targetId: targetId
            }
        });
    };
    Game.prototype.setSubtitle = function (subtitle, targetId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "setSubtitle",
                        setSubtitle: {
                            subtitle: subtitle,
                            targetId: targetId
                        }
                    })];
            });
        });
    };
    Game.prototype.highFive = function (targetId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "highFive",
                        highFive: {
                            targetId: targetId
                        }
                    })];
            });
        });
    };
    Game.prototype.setArbitraryMapData = function (mapId, dataJson, deleteMap) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.engine.sendAction({
                        $case: "setArbitraryMapData",
                        setArbitraryMapData: {
                            mapId: mapId,
                            dataJson: dataJson,
                            deleteMap: deleteMap
                        }
                    }, false, true)];
            });
        });
    };
    Game.prototype.updateSpaceItems = function (items) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "updateSpaceItems",
            updateSpaceItems: {
                items: items
            }
        });
    };
    Game.prototype.addInventoryItem = function (itemId, delta, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "addInventoryItem",
            addInventoryItem: {
                itemId: itemId,
                delta: delta,
                targetId: targetId
            }
        });
    };
    Game.prototype.removeInventoryItem = function (itemId, delta, targetId) {
        var _a;
        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.sendAction({
            $case: "removeInventoryItem",
            removeInventoryItem: {
                itemId: itemId,
                delta: delta,
                targetId: targetId
            }
        });
    };
    Game.prototype.getStats = function () {
        var _a, _b;
        if (this.engine.clientUid === undefined) {
            Logger_1.logger.error("Client uid is undefined in getStats");
        }
        else if (this.players[this.engine.clientUid] === undefined) {
            Logger_1.logger.error("Current player is undefined in getStats");
        }
        var metrics = {
            serverURL: this.engine.serverURL,
            engine: this.engine.getMetrics(),
            wsReadyState: (_a = this.engine.ws) === null || _a === void 0 ? void 0 : _a.readyState,
            timeToConnect: this._timeToConnect,
            timeToFirstOnMapMs: this.timeToFirstOnMapsMs,
            onMapCountsAllTime: this._onMapCounts,
            gameClientAgeMs: Date.now() - this._initializedAtMs,
            numPlayers: Object.keys(this.players).length,
            currentMap: (_b = this.players[this.engine.clientUid || ""]) === null || _b === void 0 ? void 0 : _b.map,
            gameClientVersion: version_1.GAME_CLIENT_VERSION
        };
        this.putMetric("get-stats", metrics);
        return metrics;
    };
    Game.prototype.subscribeToAll = function () {
        var _this = this;
        var onSuccess = function () {
            _this.subscriptionFinishedCallback();
            _this.engine.logInitialSyncComplete();
        };
        this.engine
            .sendAction({
            $case: "updateSubscriptions",
            updateSubscriptions: {
                subscriptions: this.eventSubscriptions,
                mapUpdateIds: this.lastMapUpdateIds
            }
        }, false, true)
            .then(function () {
            onSuccess();
        })["catch"](function (err) {
            if (err.message.includes("Invalid subscriptions")) {
                onSuccess();
                return;
            }
        });
    };
    Game.prototype._startMapDataCheckInterval = function () {
        var _this = this;
        this.timeToFirstOnMapsMs = {};
        this.mapDataChecks = 0;
        this.mapDataCheckInterval && clearInterval(this.mapDataCheckInterval);
        this.mapDataCheckInterval = setInterval(function () {
            _this.mapDataChecks += 1;
            _this.putMetric("still-no-map-data-ms", {
                gameClientAgeMs: Date.now() - _this._initializedAtMs,
                mapDataChecksCount: _this.mapDataChecks,
                timeToFirstMapDataMs: _this.timeToFirstOnMapsMs
            });
        }, 2500);
    };
    Game.prototype.getDebugHistory = function () {
        return Logger_1.logger.exportHistory();
    };
    Game.prototype.getPlayersInMap = function (mapId) {
        if (!this.completeMaps[mapId]) {
            throw new Error("Can't get players in map: no map for " + mapId);
        }
        var sameMapPlayers = Object.values(this.players).filter(function (player) { return player.map === mapId; });
        return sameMapPlayers;
    };
    Game.prototype.getKnownPartialMaps = function () {
        return Object.keys(this.partialMaps);
    };
    Game.prototype.getKnownCompletedMaps = function () {
        return Object.keys(this.completeMaps);
    };
    Game.prototype.filterObjectsInSpace = function (filter) {
        var _this = this;
        var foundObjects = [];
        this.getKnownCompletedMaps().forEach(function (mapId) {
            foundObjects.push.apply(foundObjects, __spreadArray([], __read(_this.filterObjectsInMap(mapId, filter)), false));
        });
        return foundObjects;
    };
    Game.prototype.filterObjectsInMap = function (mapId, filter) {
        var map = this.partialMaps[mapId];
        if (!map) {
            throw new Error("Can't filter objects in map: no map for " + mapId);
        }
        if (!map.objects) {
            return [];
        }
        return Object.values(map.objects).filter(filter);
    };
    Game.prototype.filterUidsInSpace = function (filter) {
        var _this = this;
        return Object.keys(this.players).filter(function (key) {
            var player = _this.players[key];
            if (player) {
                return filter(player);
            }
            return false;
        });
    };
    Game.prototype.filterPlayersInSpace = function (filter) {
        return Object.values(this.players).filter(filter);
    };
    Game.prototype.patchGatherEventsSpaceSession = function (speakerUpdatesSession) {
        this.engine.sendAction({
            $case: "speakerUpdatesSession",
            speakerUpdatesSession: speakerUpdatesSession
        });
    };
    Game.prototype.getMyPlayer = function () {
        if (!this.engine.clientUid) {
            throw new Error("Client has not received ready event from server and is still connecting");
        }
        var currentPlayer = this.players[this.engine.clientUid];
        if (!currentPlayer) {
            throw new Error("Current player not found. Did you call game.enter?");
        }
        return currentPlayer;
    };
    return Game;
}());
exports.Game = Game;
//# sourceMappingURL=Game.js.map