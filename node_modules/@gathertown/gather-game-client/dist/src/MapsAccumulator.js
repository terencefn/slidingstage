"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
exports.__esModule = true;
exports.MapsAccumulator = void 0;
var gameMap_1 = require("@gathertown/gather-game-common/dist/src/public/gameMap");
var buffer_1 = require("buffer");
var Logger_1 = require("./Logger");
var MapsAccumulator = (function () {
    function MapsAccumulator() {
        this.partialMaps = {};
        this.completeMaps = {};
        this.lastMapUpdateIds = {};
    }
    MapsAccumulator.prototype.addChunk = function (event) {
        var _a;
        switch (event.$case) {
            case "mapSetBackgroundImagePath":
            case "mapSetForegroundImagePath":
            case "mapSetSprites":
            case "mapSetSpaces":
            case "mapSetSpawns":
            case "mapSetPortals":
            case "mapSetAnnouncer":
            case "mapSetAssets":
            case "mapSetSpawn":
            case "mapSetName":
            case "mapSetMuteOnEntry":
            case "mapSetUseDrawnBG":
            case "mapSetMiniMapImagePath":
            case "mapSetEnabledChats":
            case "mapSetDescription":
            case "mapSetDecoration":
            case "mapSetScript": {
                this.simpleCopyFromEventPayloadToMap(event);
                break;
            }
            case "mapSetDimensions": {
                var _b = event.mapSetDimensions, mapId_1 = _b.mapId, width = _b.width, height = _b.height;
                this.getMap(mapId_1).dimensions = [width, height];
                break;
            }
            case "mapSetCollisions": {
                var _c = event.mapSetCollisions, mapId_2 = _c.mapId, x = _c.x, y = _c.y, w_1 = _c.w, h = _c.h, mask = _c.mask;
                var maskBytes = buffer_1.Buffer.from(mask, "base64");
                var map = this.getMap(mapId_2);
                if (!map.collisions) {
                    map.collisions = Array(h)
                        .fill(undefined)
                        .map(function () { return Array(w_1).fill(undefined); });
                }
                for (var i = 0; i < h; i++) {
                    for (var j = 0; j < w_1; j++) {
                        map.collisions[i + y][j + x] = !!maskBytes[i * w_1 + j];
                    }
                }
                break;
            }
            case "mapSetObjects": {
                var _d = event.mapSetObjects, mapId_3 = _d.mapId, wireObjects = _d.objects, updatesAreOverwrites = _d.updatesAreOverwrites;
                var map = this.getMap(mapId_3);
                if (!map.objects) {
                    map.objects = {};
                }
                for (var stringKey in wireObjects) {
                    var key = parseInt(stringKey);
                    try {
                        var newObject = updatesAreOverwrites
                            ? wireObjects[key]
                            : __assign(__assign({}, map.objects[key]), wireObjects[key]);
                        map.objects[key] = (0, gameMap_1.convertWireObjectToMapObject)(newObject, key);
                    }
                    catch (err) {
                        Logger_1.logger.warn("object ".concat(key, " in map ").concat(mapId_3, " is badly formated and is being ignored. err: ").concat(Logger_1.logger.errString(err), " data: ").concat(Logger_1.logger.errString(wireObjects[key])));
                    }
                }
                break;
            }
            case "mapSetWalls": {
                var _e = event.mapSetWalls, mapId_4 = _e.mapId, walls = _e.walls, shouldDelete = _e["delete"];
                if (shouldDelete) {
                    delete this.partialMaps[mapId_4].walls;
                    break;
                }
                var map = this.getMap(mapId_4);
                if (map.dimensions === undefined) {
                    throw new Error("Cannot set map walls when map dimensions are undefined");
                }
                map.walls = (0, gameMap_1.wallFloorConvertFromDB)(walls, map.dimensions, true);
                break;
            }
            case "mapSetFloors": {
                var _f = event.mapSetFloors, mapId_5 = _f.mapId, floors = _f.floors, shouldDelete = _f["delete"];
                if (shouldDelete) {
                    delete this.partialMaps[mapId_5].floors;
                    break;
                }
                var map = this.getMap(mapId_5);
                if (map.dimensions === undefined) {
                    throw new Error("Cannot set map floors when map dimensions are undefined");
                }
                map.floors = (0, gameMap_1.wallFloorConvertFromDB)(floors, map.dimensions, false);
                break;
            }
            case "mapSetAreas": {
                var _g = event.mapSetAreas, mapId_6 = _g.mapId, areas = _g.areas, shouldDelete = _g["delete"];
                if (shouldDelete) {
                    delete this.partialMaps[mapId_6].areas;
                    break;
                }
                var map = this.getMap(mapId_6);
                map.areas = (0, gameMap_1.convertWireAreasToAreas)(areas, map.dimensions);
                break;
            }
            case "mapSetDesks": {
                var _h = event.mapSetDesks, mapId_7 = _h.mapId, desks = _h.desks;
                var map = this.getMap(mapId_7);
                map.desks = (0, gameMap_1.convertDBDesksToDesks)(desks, map.dimensions);
                break;
            }
            case "mapDeleteObject": {
                var _j = event.mapDeleteObject, mapId_8 = _j.mapId, key = _j.key;
                var map = this.getMap(mapId_8);
                (_a = map.objects) === null || _a === void 0 ? true : delete _a[key];
                break;
            }
            case "mapSetTutorialTasks": {
                var _k = event.mapSetTutorialTasks, mapId_9 = _k.mapId, wireTutorialTasks = _k.tutorialTasks, shouldDelete = _k["delete"];
                if (shouldDelete) {
                    delete this.partialMaps[mapId_9].tutorialTasks;
                    break;
                }
                if (wireTutorialTasks === undefined) {
                    throw new Error("Cannot set tutorialTasks because it is undefined");
                }
                this.getMap(mapId_9).tutorialTasks =
                    (0, gameMap_1.convertWireTutorialTasksToTutorialTasks)(wireTutorialTasks);
                break;
            }
            case "mapCommitsChanges": {
                var _l = event.mapCommitsChanges, mapId_10 = _l.mapId, updateId = _l.updateId;
                this.lastMapUpdateIds[mapId_10] = updateId;
                break;
            }
            case "mapMoveObject": {
                var _m = event.mapMoveObject, mapId_11 = _m.mapId, objectId_1 = _m.objectId, targetX = _m.targetX, targetY = _m.targetY, targetXOffset = _m.targetXOffset, targetYOffset = _m.targetYOffset;
                var map = this.getMap(mapId_11);
                if (map) {
                    var obj = Object.values(map.objects || []).find(function (x) { return x.id === objectId_1; });
                    if (obj) {
                        obj.x = targetX;
                        obj.offsetX = targetXOffset;
                        obj.y = targetY;
                        obj.offsetY = targetYOffset;
                    }
                }
                break;
            }
            default: {
                throw new Error("Unexpected map event: ".concat(event.$case));
            }
        }
        var mapId = this.getMapIdFromEvent(event);
        if (event.$case !== "mapCommitsChanges") {
            delete this.lastMapUpdateIds[mapId];
        }
        this.updateCompleteMaps(mapId);
        return this.completeMaps[mapId];
    };
    MapsAccumulator.prototype.getMap = function (mapId) {
        if (!this.partialMaps[mapId]) {
            this.partialMaps[mapId] = this.initializeMap(mapId);
        }
        return this.partialMaps[mapId];
    };
    MapsAccumulator.prototype.simpleCopyFromEventPayloadToMap = function (event) {
        var _a = event[event.$case], mapId = _a.mapId, shouldDelete = _a["delete"], rest = __rest(_a, ["mapId", "delete"]);
        var map = this.getMap(mapId);
        Object.keys(rest).forEach(function (field) {
            if (shouldDelete) {
                delete map[field];
            }
            else {
                map[field] = rest[field];
            }
        });
    };
    MapsAccumulator.prototype.updateCompleteMaps = function (mapId) {
        if (this.completeMaps[mapId]) {
            return;
        }
        var map = this.partialMaps[mapId];
        if ((0, gameMap_1.verifyMapIsComplete)(map)) {
            this.completeMaps[mapId] = map;
        }
    };
    MapsAccumulator.prototype.initializeMap = function (mapId) {
        return { id: mapId };
    };
    MapsAccumulator.prototype.getMapIdFromEvent = function (event) {
        var mapId = event[event.$case]["mapId"];
        if (mapId == null) {
            throw new Error("no mapId on map event ".concat(event.$case));
        }
        return mapId;
    };
    return MapsAccumulator;
}());
exports.MapsAccumulator = MapsAccumulator;
//# sourceMappingURL=MapsAccumulator.js.map