"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapsAccumulator = void 0;
const gameMap_1 = require("@gathertown/gather-game-common/dist/src/public/gameMap");
const buffer_1 = require("buffer");
const Logger_1 = require("./Logger");
const GameMap_1 = require("./GameMap");
class MapsAccumulator {
    constructor() {
        this.partialMaps = {};
        this.completeMaps = {};
        this.lastMapUpdateIds = {};
    }
    addChunk(event) {
        var _a, _b, _c;
        switch (event.$case) {
            case "mapSetBackgroundImagePath":
            case "mapSetForegroundImagePath":
            case "mapSetSprites":
            case "mapSetSpawns":
            case "mapSetPortals":
            case "mapSetAnnouncer":
            case "mapSetAssets":
            case "mapSetSpawn":
            case "mapSetName":
            case "mapSetMuteOnEntry":
            case "mapSetUseDrawnBG":
            case "mapSetMiniMapImagePath":
            case "mapSetEnabledChats":
            case "mapSetDescription":
            case "mapSetDecoration":
            case "mapSetScript": {
                this.simpleCopyFromEventPayloadToMap(event);
                break;
            }
            case "mapSetNooks": {
                const { mapId, nooks, overwrite } = event.mapSetNooks;
                const map = this.getMap(mapId);
                if (!map) {
                    throw new Error(`Map ${mapId} not found`);
                }
                const newNooks = (0, gameMap_1.mergeNooks)(map.nooks || {}, nooks, overwrite);
                map.nooks = newNooks;
                break;
            }
            case "mapSetDimensions": {
                const { mapId, width, height } = event.mapSetDimensions;
                this.getMap(mapId).dimensions = [width, height];
                break;
            }
            case "mapSetCollisions": {
                const { mapId, x: offsetX, y: offsetY, w, h, mask } = event.mapSetCollisions;
                const maskBytes = buffer_1.Buffer.from(mask, "base64");
                const map = this.getMap(mapId);
                if (!map) {
                    throw new Error(`Map ${mapId} not found`);
                }
                if (!map.collisions) {
                    map.collisions = {};
                }
                for (let i = 0; i < h; i++) {
                    for (let j = 0; j < w; j++) {
                        const y = i + offsetY;
                        const x = j + offsetX;
                        if (!maskBytes[i * w + j]) {
                            (_a = map.collisions[y]) === null || _a === void 0 ? true : delete _a[x];
                            continue;
                        }
                        const temp = (_b = map.collisions[y]) !== null && _b !== void 0 ? _b : {};
                        temp[x] = true;
                        map.collisions[y] = temp;
                    }
                }
                break;
            }
            case "mapSetObjects": {
                const { mapId, objects: wireObjects, updatesAreOverwrites } = event.mapSetObjects;
                const map = this.getMap(mapId);
                if (!map.objects) {
                    map.objects = {};
                }
                for (const stringKey in wireObjects) {
                    const key = parseInt(stringKey);
                    try {
                        const newObject = updatesAreOverwrites
                            ? wireObjects[key]
                            : Object.assign(Object.assign({}, map.objects[key]), wireObjects[key]);
                        map.objects[key] = (0, gameMap_1.convertWireObjectToMapObject)(newObject, key);
                    }
                    catch (err) {
                        Logger_1.logger.warn(`object ${key} in map ${mapId} is badly formated and is being ignored. err: ${Logger_1.logger.errString(err)} data: ${Logger_1.logger.errString(wireObjects[key])}`);
                    }
                }
                break;
            }
            case "mapSetWalls": {
                const { mapId, walls, delete: shouldDelete } = event.mapSetWalls;
                if (shouldDelete) {
                    delete this.partialMaps[mapId].walls;
                    break;
                }
                const map = this.getMap(mapId);
                if (map.dimensions === undefined) {
                    throw new Error("Cannot set map walls when map dimensions are undefined");
                }
                map.walls = (0, gameMap_1.wallFloorConvertFromDB)(walls, map.dimensions, true);
                break;
            }
            case "mapSetFloors": {
                const { mapId, floors, delete: shouldDelete } = event.mapSetFloors;
                if (shouldDelete) {
                    delete this.partialMaps[mapId].floors;
                    break;
                }
                const map = this.getMap(mapId);
                if (map.dimensions === undefined) {
                    throw new Error("Cannot set map floors when map dimensions are undefined");
                }
                map.floors = (0, gameMap_1.wallFloorConvertFromDB)(floors, map.dimensions, false);
                break;
            }
            case "mapSetAreas": {
                const { mapId, areas, delete: shouldDelete } = event.mapSetAreas;
                if (shouldDelete) {
                    delete this.partialMaps[mapId].areas;
                    break;
                }
                const map = this.getMap(mapId);
                map.areas = (0, gameMap_1.convertWireAreasToAreas)(areas, map.dimensions);
                break;
            }
            case "mapDeleteObject": {
                const { mapId, key } = event.mapDeleteObject;
                const map = this.getMap(mapId);
                (_c = map.objects) === null || _c === void 0 ? true : delete _c[key];
                break;
            }
            case "mapSetTutorialTasks": {
                const { mapId, tutorialTasks: wireTutorialTasks, delete: shouldDelete, } = event.mapSetTutorialTasks;
                if (shouldDelete) {
                    delete this.partialMaps[mapId].tutorialTasks;
                    break;
                }
                if (wireTutorialTasks === undefined) {
                    throw new Error("Cannot set tutorialTasks because it is undefined");
                }
                this.getMap(mapId).tutorialTasks =
                    (0, gameMap_1.convertWireTutorialTasksToTutorialTasks)(wireTutorialTasks);
                break;
            }
            case "mapCommitsChanges": {
                const { mapId, updateId } = event.mapCommitsChanges;
                this.lastMapUpdateIds[mapId] = updateId;
                break;
            }
            case "mapMoveObject": {
                const { mapId, objectId, targetX, targetY, targetXOffset, targetYOffset } = event.mapMoveObject;
                const map = this.getMap(mapId);
                if (map) {
                    const obj = Object.values(map.objects || []).find((x) => x.id === objectId);
                    if (obj) {
                        obj.x = targetX;
                        obj.offsetX = targetXOffset;
                        obj.y = targetY;
                        obj.offsetY = targetYOffset;
                    }
                }
                break;
            }
            default: {
                throw new Error(`Unexpected map event: ${event.$case}`);
            }
        }
        const mapId = this.getMapIdFromEvent(event);
        if (event.$case !== "mapCommitsChanges") {
            delete this.lastMapUpdateIds[mapId];
        }
        this.updateCompleteMaps(mapId);
        return this.completeMaps[mapId];
    }
    getMap(mapId) {
        if (!this.partialMaps[mapId]) {
            this.partialMaps[mapId] = this.initializeMap(mapId);
        }
        return this.partialMaps[mapId];
    }
    simpleCopyFromEventPayloadToMap(event) {
        const _a = event[event.$case], { mapId, delete: shouldDelete } = _a, rest = __rest(_a, ["mapId", "delete"]);
        const map = this.getMap(mapId);
        Object.keys(rest).forEach((field) => {
            if (shouldDelete) {
                delete map[field];
            }
            else {
                map[field] = rest[field];
            }
        });
    }
    updateCompleteMaps(mapId) {
        if (this.completeMaps[mapId])
            return;
        const map = this.partialMaps[mapId];
        if (map && (0, GameMap_1.verifyMapIsComplete)(map)) {
            this.completeMaps[mapId] = map;
        }
    }
    initializeMap(mapId) {
        return { id: mapId };
    }
    getMapIdFromEvent(event) {
        const mapId = event[event.$case]["mapId"];
        if (mapId == null) {
            throw new Error(`no mapId on map event ${event.$case}`);
        }
        return mapId;
    }
}
exports.MapsAccumulator = MapsAccumulator;
//# sourceMappingURL=MapsAccumulator.js.map