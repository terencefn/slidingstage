import { CancelTokenSource } from "axios";
import { PlayerInitInfo, ServerClientEvent } from "@gathertown/gather-game-common/dist/src/public/events";
import { GameWsCloseCode } from "@gathertown/gather-game-common/dist/src/public/responseCodes";
import { ClientServerActionAction } from "@gathertown/gather-game-common/dist/src/public/utils";
import { SlidingWindow } from "./Utils";
export declare type EngineAuth = {
    token: string;
} | {
    apiKey: string;
};
declare type DisconnectInfo = {
    code: GameWsCloseCode;
    reason: string;
};
export declare class Engine {
    ws?: WebSocket;
    serverURL: string;
    getAuth: () => Promise<EngineAuth>;
    spaceId: string;
    clientUid?: string;
    debugOverrideServer?: string;
    debugOverrideHttpServer?: string;
    private originalServerURL;
    private started;
    private startTime;
    _connected: boolean;
    private connectionInitTime;
    private gotFirstMessage;
    private sizeOfNextLargeMessage;
    private _sendQ;
    private numMoveEventsBuffered;
    private transactionManager;
    private connectionFailedTimeout;
    private uploadLogTimeout;
    private uploadLogTimeoutLong;
    private lastSignOfLife;
    private cancelGsFetch;
    private lastSuccessfulFetch;
    _bufferedAmounts: SlidingWindow;
    private latencies;
    _timeSpentDisconnected: SlidingWindow;
    _eventCountsSinceOpen: {
        [event: string]: number;
    };
    _closeCounts: {
        [code: number]: number;
    };
    onevent(_e: ServerClientEvent): void;
    onconnect(): void;
    ondisconnect(_code?: number, _reason?: string): void;
    onmetric(_metricName: string, _metricValue: any): void;
    subscriptionHook(): void;
    constructor(spaceId: string, getAuth: () => Promise<EngineAuth>, overrideServer?: string, overrideHttpServer?: string);
    start(): Promise<void>;
    stop(disconnectInfo?: DisconnectInfo): void;
    private shouldUseSubdomains;
    private createConnection;
    private destroyConnection;
    private reconnectTimeout;
    private _reconnectionAttempts;
    private lastReconnectQueued;
    private cleanUpAndQueueReconnect;
    private wantsToEnter;
    private tempInitInfo?;
    private tempSpawnToken?;
    private tempTargetId?;
    queueOrExecuteEnter(info?: PlayerInitInfo, spawnToken?: string, targetId?: string): void;
    exit(): void;
    private processEvent;
    private _lastActionSentAt;
    sendAction(action: ClientServerActionAction, bypass: boolean, createTxnId: true, txnId?: number): Promise<unknown>;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: false, txnId?: number): void;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: boolean, txnId?: number): Promise<unknown> | void;
    private recordHeartbeatTime;
    _heartbeatInterval: any;
    startHeartbeat(): void;
    stopHeartbeat(): void;
    private _byteTrackerInterval;
    private _bytesSentSinceConnect;
    private _bytesReceivedSinceConnect;
    private _lastBytesSent;
    private _lastBytesReceived;
    startByteTracker(): void;
    stopByteTracker(): void;
    private CONNECT_INTENT_POST_INTERVAL;
    private connectIntentInterval;
    private startRecordingIntentToConnect;
    private stopRecordingIntentToConnect;
    LOG_THRESH_MS: number;
    private hasEverFullyConnected;
    private disconnectedStartTime;
    private dcLogTimeout;
    logDisconnectionStart(): void;
    logInitialSyncComplete(): void;
    resetDisconnectionTracking(): void;
    queueDebugUpload(): void;
    private lastSuspendCheck;
    private suspendCheckInterval;
    private lastSuspendDate;
    private isThrottled;
    checkAndHandleSuspend(): void;
    startSuspendCheck(): void;
    stopSuspendCheck(): void;
    getBaseMetricsInfo(): {
        usingKube: boolean | null;
        usingSubdomains: boolean;
    };
    getGameServerUrl(cancelToken: CancelTokenSource["token"]): Promise<any>;
    getMetrics(): {
        connected: boolean;
        latency: import("./Utils").SlidingWindowMetrics;
        reconnects: {
            recentAttempts: number;
            timeSpentDisconnectedMs: import("./Utils").SlidingWindowMetrics;
        };
        bufferedAmount: import("./Utils").SlidingWindowMetrics;
        bytesSentSinceConnect: number;
        bytesReceivedSinceConnect: number;
        eventCountsSinceOpen: {
            [event: string]: number;
        };
        closeCodeCount: {
            [code: number]: number;
        };
    };
}
export {};
