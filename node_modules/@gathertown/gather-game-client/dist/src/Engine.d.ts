import { ServerClientEvent, SpaceUserInfo } from "@gathertown/gather-game-common/dist/src/public/events";
import { ClientServerActionAction } from "@gathertown/gather-game-common/dist/src/public/utils";
import { SlidingWindow } from "./Utils";
export declare type EngineAuth = {
    token: string;
} | {
    apiKey: string;
};
export declare class Engine {
    ws?: WebSocket;
    serverURL: string;
    getAuth: () => Promise<EngineAuth>;
    spaceId: string;
    clientUid?: string;
    debugOverrideServer?: string;
    private started;
    _connected: boolean;
    private connectionInitTime;
    private gotFirstMessage;
    private _sendQ;
    private numMoveEventsBuffered;
    private transactionManager;
    private connectionFailedTimeout;
    private lastSignOfLife;
    _bufferedAmounts: SlidingWindow;
    private latencies;
    _timeSpentDisconnected: SlidingWindow;
    _eventCountsSinceOpen: {
        [event: string]: number;
    };
    _closeCounts: {
        [code: number]: number;
    };
    onevent(_e: ServerClientEvent): void;
    onconnect(): void;
    ondisconnect(_code?: number, _reason?: string): void;
    onmetric(_metricName: string, _metricValue: any): void;
    subscriptionHook(): void;
    constructor(spaceId: string, getAuth: () => Promise<EngineAuth>, overrideServer?: string);
    start(): Promise<void>;
    stop(): void;
    private createConnection;
    private destroyConnection;
    private reconnectTimeout;
    private _reconnectionAttempts;
    private lastReconnectQueued;
    private cleanUpAndQueueReconnect;
    private wantsToEnter;
    private tempSpaceUserInfo?;
    private tempSpawnToken?;
    private tempTargetId?;
    queueOrExecuteEnter(info?: SpaceUserInfo, spawnToken?: string, targetId?: string): void;
    exit(): void;
    private processEvent;
    sendAction(action: ClientServerActionAction, bypass: boolean, createTxnId: true, txnId?: number): Promise<unknown>;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: false, txnId?: number): void;
    sendAction(action: ClientServerActionAction, bypass?: boolean, createTxnId?: boolean, txnId?: number): Promise<unknown> | void;
    private recordHeartbeatTime;
    _heartbeatInterval: any;
    startHeartbeat(): void;
    stopHeartbeat(): void;
    private _byteTrackerInterval;
    private _bytesSentSinceConnect;
    private _bytesReceivedSinceConnect;
    private _lastBytesSent;
    private _lastBytesReceived;
    startByteTracker(): void;
    stopByteTracker(): void;
    private CONNECT_INTENT_POST_INTERVAL;
    private connectIntentInterval;
    private startRecordingIntentToConnect;
    private stopRecordingIntentToConnect;
    LOG_THRESH_MS: number;
    private hasEverFullyConnected;
    private disconnectedStartTime;
    private dcLogTimeout;
    logDisconnectionStart(): void;
    logInitialSyncComplete(): void;
    getGameServerUrl(): Promise<any>;
    getMetrics(): {
        connected: boolean;
        latency: import("./Utils").SlidingWindowMetrics;
        reconnects: {
            recentAttempts: number;
            timeSpentDisconnectedMs: import("./Utils").SlidingWindowMetrics;
        };
        bufferedAmount: import("./Utils").SlidingWindowMetrics;
        bytesSentSinceConnect: number;
        bytesReceivedSinceConnect: number;
        eventCountsSinceOpen: {
            [event: string]: number;
        };
        closeCodeCount: {
            [code: number]: number;
        };
    };
}
